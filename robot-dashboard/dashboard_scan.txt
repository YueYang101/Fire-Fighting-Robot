================================================================================
ROBOT DASHBOARD COMPLETE SCAN
Path: /Users/yang/Library/CloudStorage/OneDrive-Personal/UCL/Year 4 UCL/MECH0073/GitHub_Repositories/Fire-fighting-Robot/robot-dashboard
================================================================================

DIRECTORY STRUCTURE:
----------------------------------------
├── backend
│   ├── __pycache__
│   ├── sensors
│   │   ├── __pycache__
│   │   ├── __init__.py
│   │   └── lidar.py
│   ├── venv
│   ├── __init__.py
│   ├── config_manager.py
│   ├── host_backend.py
│   └── ros_bridge.py
├── frontend
│   └── templates
│       ├── dashboard_home.html
│       ├── lidar_visualization.html
│       └── motor_control.html
├── ui
│   └── node_modules
├── dashboard_scan.txt
├── dashboard_scan_output.txt
├── dashboard_scanner.py
├── requirements.txt
└── run.py

================================================================================
FILE CONTENTS:
================================================================================

================================================================================
FILE: backend/__init__.py
================================================================================
"""
Backend package for ROS 2 Motor Control
"""

from .ros_bridge import ROSBridgeConnection, MotorController, get_ros_bridge, get_motor_controller

__all__ = [
    'ROSBridgeConnection',
    'MotorController', 
    'get_ros_bridge',
    'get_motor_controller'
]

__version__ = '1.0.0'
================================================================================


================================================================================
FILE: backend/config_manager.py
================================================================================
#!/usr/bin/env python3
"""
Configuration manager for persistent settings
Saves and loads configuration from a JSON file
"""

import json
import os
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class ConfigManager:
    """Manages persistent configuration settings"""
    
    def __init__(self, config_file: str = None):
        """
        Initialize configuration manager
        
        Args:
            config_file: Path to configuration file (default: ~/.robot_dashboard_config.json)
        """
        if config_file is None:
            # Use home directory for config file
            self.config_file = Path.home() / ".robot_dashboard_config.json"
        else:
            self.config_file = Path(config_file)
        
        # Default configuration
        self.default_config = {
            "PI_IP": "192.168.2.1",
            "ROS_BRIDGE_PORT": 9090,
            "FLASK_PORT": 5001,
            "FLASK_HOST": "0.0.0.0"
        }
        
        # Load configuration
        self.config = self.load_config()
    
    def load_config(self) -> dict:
        """Load configuration from file or return defaults"""
        try:
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    loaded_config = json.load(f)
                    # Merge with defaults (in case new fields are added)
                    config = self.default_config.copy()
                    config.update(loaded_config)
                    logger.info(f"Loaded configuration from {self.config_file}")
                    return config
            else:
                logger.info("No config file found, using defaults")
                return self.default_config.copy()
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            return self.default_config.copy()
    
    def save_config(self):
        """Save current configuration to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
            logger.info(f"Saved configuration to {self.config_file}")
            return True
        except Exception as e:
            logger.error(f"Error saving config: {e}")
            return False
    
    def update_config(self, updates: dict) -> bool:
        """
        Update configuration values
        
        Args:
            updates: Dictionary of configuration updates
            
        Returns:
            bool: True if successful
        """
        try:
            # Update configuration
            self.config.update(updates)
            # Save to file
            return self.save_config()
        except Exception as e:
            logger.error(f"Error updating config: {e}")
            return False
    
    def get(self, key: str, default=None):
        """Get configuration value"""
        return self.config.get(key, default)
    
    def get_all(self) -> dict:
        """Get all configuration values"""
        return self.config.copy()

# Singleton instance
_config_manager = None

def get_config_manager(config_file: str = None) -> ConfigManager:
    """Get or create ConfigManager instance"""
    global _config_manager
    if _config_manager is None:
        _config_manager = ConfigManager(config_file)
    return _config_manager
================================================================================


================================================================================
FILE: backend/host_backend.py
================================================================================
#!/usr/bin/env python3
"""
Flask backend server for ROS 2 robot control
Main application entry point with multi-component support
"""

import os
import sys
from pathlib import Path

# Add parent directory to path for imports
sys.path.append(str(Path(__file__).parent.parent))

from flask import Flask, render_template, jsonify, request
from flask_cors import CORS
from flask_socketio import SocketIO, emit
import logging

# Import configuration manager
from backend.config_manager import get_config_manager

# Import ROS bridge components
from backend.ros_bridge import get_ros_bridge, get_motor_controller
from backend.sensors.lidar import get_lidar_sensor

# Create Flask app
app = Flask(__name__, 
            template_folder='../frontend/templates',
            static_folder='../frontend/static')
CORS(app)  # Enable CORS for API requests
socketio = SocketIO(app, cors_allowed_origins="*")  # For real-time lidar data

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Load configuration from persistent storage
config_manager = get_config_manager()
CONFIG = config_manager.get_all()

# Initialize ROS components with saved configuration
ros_bridge = get_ros_bridge(CONFIG["PI_IP"], CONFIG["ROS_BRIDGE_PORT"])
motor_controller = get_motor_controller()
lidar_sensor = get_lidar_sensor()

# Lidar data streaming state
lidar_streaming = False

# =============================================================================
# MAIN DASHBOARD ROUTES
# =============================================================================

@app.route('/')
def index():
    """Serve the main dashboard home page"""
    return render_template('dashboard_home.html')

@app.route('/motors')
def motors_page():
    """Serve the motor control interface"""
    return render_template('motor_control.html')

@app.route('/lidar')
def lidar_page():
    """Serve the lidar visualization interface"""
    return render_template('lidar_visualization.html')

# =============================================================================
# MOTOR CONTROL API ROUTES
# =============================================================================

@app.route('/api/motor/<int:motor_id>', methods=['POST'])
def control_motor(motor_id):
    """Control a specific motor"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        # Use motor controller
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in control_motor: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/motor/<int:motor_id>', methods=['GET'])
def get_motor_status(motor_id):
    """Get current status of a specific motor"""
    state = motor_controller.get_motor_state(motor_id)
    
    if state:
        return jsonify({
            "success": True,
            "motor_id": motor_id,
            "state": state
        })
    else:
        return jsonify({
            "success": False,
            "error": "Invalid motor ID"
        }), 404

@app.route('/api/motors', methods=['GET'])
def get_all_motors_status():
    """Get current status of all motors"""
    states = motor_controller.get_all_motor_states()
    
    return jsonify({
        "success": True,
        "motors": states
    })

@app.route('/api/motors/stop', methods=['POST'])
def stop_all_motors():
    """Emergency stop - brake all motors"""
    result = motor_controller.stop_all_motors()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

# =============================================================================
# LIDAR API ROUTES
# =============================================================================

@app.route('/api/lidar/status', methods=['GET'])
def get_lidar_status():
    """Get lidar sensor status"""
    latest_scan = lidar_sensor.get_latest_scan()
    
    return jsonify({
        "connected": lidar_sensor.subscription_active,
        "has_data": latest_scan is not None,
        "timestamp": latest_scan["timestamp"] if latest_scan else None
    })

@app.route('/api/lidar/latest', methods=['GET'])
def get_latest_lidar_scan():
    """Get the most recent lidar scan data"""
    scan_data = lidar_sensor.get_latest_scan()
    
    if scan_data:
        return jsonify({
            "success": True,
            "data": scan_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "No scan data available"
        }), 404

@app.route('/api/lidar/subscribe', methods=['POST'])
def subscribe_lidar():
    """Start lidar data subscription"""
    global lidar_streaming
    
    def lidar_callback(scan_data):
        """Emit lidar data through WebSocket"""
        if lidar_streaming:
            socketio.emit('lidar_data', scan_data)
    
    success = lidar_sensor.subscribe(callback=lidar_callback, processed_data=True)
    
    if success:
        lidar_streaming = True
        return jsonify({"success": True, "message": "Lidar subscription started"})
    else:
        return jsonify({"success": False, "error": "Failed to subscribe to lidar"}), 500

@app.route('/api/lidar/unsubscribe', methods=['POST'])
def unsubscribe_lidar():
    """Stop lidar data subscription"""
    global lidar_streaming
    
    lidar_streaming = False
    lidar_sensor.unsubscribe()
    
    return jsonify({"success": True, "message": "Lidar subscription stopped"})

# =============================================================================
# SYSTEM STATUS ROUTES
# =============================================================================

@app.route('/api/status', methods=['GET'])
def get_system_status():
    """Check connection status to ROS bridge and system info"""
    ros_connected = ros_bridge.test_connection()
    
    return jsonify({
        "connected": ros_connected,
        "rosbridge_url": ros_bridge.url,
        "config": {
            "robot_ip": CONFIG["PI_IP"],
            "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"]
        },
        "components": {
            "motors": True,
            "lidar": lidar_sensor.subscription_active
        }
    }), 200 if ros_connected else 503

@app.route('/api/config', methods=['GET'])
def get_config():
    """Get current configuration"""
    return jsonify({
        "robot_ip": CONFIG["PI_IP"],
        "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"],
        "flask_port": CONFIG["FLASK_PORT"],
        "flask_host": CONFIG["FLASK_HOST"]
    })

@app.route('/api/config', methods=['POST'])
def update_config():
    """Update configuration with new connection settings"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        # Get new settings
        new_ip = data.get('robot_ip')
        new_port = data.get('rosbridge_port')
        
        if not new_ip or not new_port:
            return jsonify({"error": "Missing robot_ip or rosbridge_port"}), 400
        
        # Update configuration in memory
        CONFIG["PI_IP"] = new_ip
        CONFIG["ROS_BRIDGE_PORT"] = int(new_port)
        
        # Save to persistent storage
        config_updates = {
            "PI_IP": new_ip,
            "ROS_BRIDGE_PORT": int(new_port)
        }
        config_manager.update_config(config_updates)
        
        # Update ROS bridge connection
        global ros_bridge, motor_controller, lidar_sensor
        ros_bridge = get_ros_bridge(CONFIG["PI_IP"], CONFIG["ROS_BRIDGE_PORT"])
        motor_controller = get_motor_controller()
        lidar_sensor = get_lidar_sensor()
        
        logger.info(f"Configuration updated and saved: IP={new_ip}, Port={new_port}")
        
        return jsonify({
            "success": True,
            "message": "Configuration updated successfully",
            "config": {
                "robot_ip": CONFIG["PI_IP"],
                "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"]
            }
        })
        
    except Exception as e:
        logger.error(f"Error updating configuration: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

# =============================================================================
# WEBSOCKET EVENTS
# =============================================================================

@socketio.on('connect')
def handle_connect():
    """Handle WebSocket connection"""
    logger.info("Client connected to WebSocket")
    emit('connected', {'data': 'Connected to robot dashboard'})

@socketio.on('disconnect')
def handle_disconnect():
    """Handle WebSocket disconnection"""
    logger.info("Client disconnected from WebSocket")

# =============================================================================
# ERROR HANDLERS
# =============================================================================

@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Not found"}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Internal server error"}), 500

# Health check endpoint
@app.route('/health', methods=['GET'])
def health_check():
    """Simple health check endpoint"""
    return jsonify({
        "status": "healthy",
        "service": "robot-dashboard-backend"
    })

def main():
    """Main entry point"""
    logger.info("=" * 50)
    logger.info("ROS 2 Robot Dashboard Backend")
    logger.info(f"Robot IP: {CONFIG['PI_IP']}")
    logger.info(f"ROS Bridge Port: {CONFIG['ROS_BRIDGE_PORT']}")
    logger.info(f"Flask Server: {CONFIG['FLASK_HOST']}:{CONFIG['FLASK_PORT']}")
    logger.info(f"Config file: {config_manager.config_file}")
    logger.info("=" * 50)
    
    # Run Flask app with SocketIO
    debug_mode = os.environ.get('FLASK_ENV', 'development') == 'development'
    
    socketio.run(
        app,
        debug=debug_mode,
        host=CONFIG['FLASK_HOST'],
        port=CONFIG['FLASK_PORT'],
        use_reloader=False  # Disable auto-reloader to prevent numpy reload issues
    )

if __name__ == '__main__':
    main()
================================================================================


================================================================================
FILE: backend/ros_bridge.py
================================================================================
#!/usr/bin/env python3
"""
ROS Bridge WebSocket communication module
Handles all ROS 2 communication via rosbridge
"""

import json
import logging
from websocket import create_connection
from typing import Dict, Any, Optional, Tuple

# Setup logging
logger = logging.getLogger(__name__)

class ROSBridgeConnection:
    """Manages WebSocket connection to ROS 2 via rosbridge"""
    
    def __init__(self, host: str = "192.168.2.4", port: int = 9090):
        """
        Initialize ROS Bridge connection parameters
        
        Args:
            host: IP address of the ROS 2 robot
            port: rosbridge websocket port (default: 9090)
        """
        self.host = host
        self.port = port
        self.url = f"ws://{host}:{port}"
        self._connection = None
    
    def connect(self) -> bool:
        """
        Establish connection to rosbridge
        
        Returns:
            bool: True if connection successful, False otherwise
        """
        try:
            self._connection = create_connection(self.url, timeout=5)
            logger.info(f"Connected to rosbridge at {self.url}")
            return True
        except Exception as e:
            logger.error(f"Failed to connect to rosbridge: {e}")
            return False
    
    def disconnect(self):
        """Close the websocket connection"""
        if self._connection:
            self._connection.close()
            self._connection = None
            logger.info("Disconnected from rosbridge")
    
    def is_connected(self) -> bool:
        """Check if connection is active"""
        return self._connection is not None
    
    def call_service(self, service_name: str, args: Dict[str, Any], 
                    service_id: Optional[str] = None) -> Tuple[bool, Dict[str, Any]]:
        """
        Call a ROS service through rosbridge
        
        Args:
            service_name: Name of the ROS service (e.g., "/set_motor")
            args: Service arguments as dictionary
            service_id: Optional ID for the service call
        
        Returns:
            Tuple[bool, Dict]: (success, response_data)
        """
        try:
            # Try to create a new connection for each call to avoid broken pipe
            ws = create_connection(self.url, timeout=5)
            
            # Prepare service call message
            request = {
                "op": "call_service",
                "service": service_name,
                "args": args
            }
            
            if service_id:
                request["id"] = service_id
            
            # Send request
            ws.send(json.dumps(request))
            
            # Get response
            response = ws.recv()
            response_data = json.loads(response)
            
            # Close connection
            ws.close()
            
            logger.debug(f"Service call response: {response_data}")
            return True, response_data
            
        except Exception as e:
            logger.error(f"Service call failed: {e}")
            return False, {"error": str(e)}
    
    def test_connection(self) -> bool:
        """
        Test if rosbridge connection is working
        
        Returns:
            bool: True if connection is working
        """
        try:
            temp_conn = create_connection(self.url, timeout=2)
            temp_conn.close()
            return True
        except Exception:
            return False

class MotorController:
    """High-level motor control interface using ROSBridge"""
    
    def __init__(self, ros_bridge: ROSBridgeConnection):
        """
        Initialize motor controller
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.motor_states = {
            0: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            1: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            2: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            3: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0}
        }
    
    @staticmethod
    def percent_to_pwm(percent: float) -> int:
        """
        Convert percentage (0-100) to PWM value (0-65535)
        
        For dual-PWM motor drivers, use NORMAL mapping:
        - 0% speed → PWM 0 (motor stopped)
        - 100% speed → PWM 65535 (motor full speed)
        
        Note: The previous INVERTED mapping was for different motor drivers
        """
        # Ensure percent is within bounds
        percent = max(0, min(100, percent))
        
        # NORMAL PWM calculation (not inverted)
        # 0% → 0, 100% → 65535
        pwm = int((percent / 100.0) * 65535)
        
        logger.debug(f"Converting {percent}% to PWM: {pwm}")
        return pwm
    
    @staticmethod
    def pwm_to_percent(pwm: int) -> float:
        """
        Convert PWM value (0-65535) to percentage (0-100)
        
        Using NORMAL mapping:
        - PWM 0 = 0% speed
        - PWM 65535 = 100% speed
        """
        # NORMAL calculation (not inverted)
        return round((pwm / 65535.0) * 100, 1)
    
    def set_motor(self, motor_id: int, direction: str, speed_percent: float) -> Dict[str, Any]:
        """
        Set motor speed and direction
        
        Args:
            motor_id: Motor ID (0-3)
            direction: Direction ("forward", "backward", "brake")
            speed_percent: Speed in percentage (0-100)
        
        Returns:
            Dict containing operation result
        """
        # Validate inputs
        if motor_id < 0 or motor_id > 3:
            return {
                "success": False,
                "error": "Invalid motor ID. Must be 0-3"
            }
        
        if direction not in ["forward", "backward", "brake"]:
            return {
                "success": False,
                "error": "Invalid direction. Must be 'forward', 'backward', or 'brake'"
            }
        
        if not isinstance(speed_percent, (int, float)) or speed_percent < 0 or speed_percent > 100:
            return {
                "success": False,
                "error": "Invalid speed. Must be 0-100"
            }
        
        # Convert to PWM with NORMAL mapping
        if direction == "brake":
            # Brake always uses PWM 0
            speed_pwm = 0
        else:
            # Use normal PWM mapping: 0% = PWM 0, 100% = PWM 65535
            speed_pwm = self.percent_to_pwm(speed_percent)
        
        # Call ROS service (connection is handled in call_service)
        service_args = {
            "motor_id": motor_id,
            "direction": direction,
            "speed": speed_pwm
        }
        
        logger.info(f"Sending to ROS - Motor: {motor_id}, Direction: {direction}, Speed: {speed_percent}% (PWM: {speed_pwm})")
        
        success, response = self.ros_bridge.call_service(
            "/set_motor", 
            service_args,
            f"motor_cmd_{motor_id}"
        )
        
        if success:
            # Update internal state
            self.motor_states[motor_id] = {
                "direction": direction,
                "speed_percent": speed_percent,
                "speed_pwm": speed_pwm
            }
            
            logger.info(f"Motor {motor_id} set to {direction} at {speed_percent}% (PWM: {speed_pwm})")
            
            return {
                "success": True,
                "motor_id": motor_id,
                "direction": direction,
                "speed_percent": speed_percent,
                "speed_pwm": speed_pwm,
                "response": response
            }
        else:
            return {
                "success": False,
                "error": response.get("error", "Unknown error"),
                "motor_id": motor_id
            }
    
    def stop_all_motors(self) -> Dict[str, Any]:
        """
        Emergency stop - brake all motors
        
        Returns:
            Dict containing results for all motors
        """
        results = []
        
        for motor_id in range(4):
            # Brake with speed 0
            result = self.set_motor(motor_id, "brake", 0)
            results.append(result)
        
        all_success = all(r["success"] for r in results)
        
        return {
            "success": all_success,
            "results": results
        }
    
    def get_motor_state(self, motor_id: int) -> Optional[Dict[str, Any]]:
        """
        Get current state of a motor
        
        Args:
            motor_id: Motor ID (0-3)
        
        Returns:
            Dict with motor state or None if invalid ID
        """
        if motor_id in self.motor_states:
            return self.motor_states[motor_id].copy()
        return None
    
    def get_all_motor_states(self) -> Dict[int, Dict[str, Any]]:
        """Get current state of all motors"""
        return self.motor_states.copy()

# Create singleton instances for easy import
_ros_bridge = None
_motor_controller = None

def get_ros_bridge(host: str = None, port: int = None) -> ROSBridgeConnection:
    """Get or create ROSBridge connection instance"""
    global _ros_bridge
    
    # If host/port provided, update or create new connection
    if host is not None or port is not None:
        if _ros_bridge:
            # Update existing connection
            if host:
                _ros_bridge.host = host
                _ros_bridge.url = f"ws://{host}:{_ros_bridge.port}"
            if port:
                _ros_bridge.port = port
                _ros_bridge.url = f"ws://{_ros_bridge.host}:{port}"
        else:
            # Create new connection with provided settings
            _ros_bridge = ROSBridgeConnection(
                host or "192.168.2.4", 
                port or 9090
            )
    elif _ros_bridge is None:
        # Create with defaults if not exists
        _ros_bridge = ROSBridgeConnection()
    
    return _ros_bridge

def get_motor_controller() -> MotorController:
    """Get or create MotorController instance"""
    global _motor_controller
    if _motor_controller is None:
        _motor_controller = MotorController(get_ros_bridge())
    return _motor_controller
================================================================================


================================================================================
FILE: backend/sensors/__init__.py
================================================================================
"""
Sensor modules for ROS 2 robot
"""

from .lidar import LidarSensor, get_lidar_sensor

__all__ = [
    'LidarSensor',
    'get_lidar_sensor'
]
================================================================================


================================================================================
FILE: backend/sensors/lidar.py
================================================================================
#!/usr/bin/env python3
"""
Lidar sensor module for ROS 2
Handles lidar data subscription and processing
"""

import json
import logging
import threading
import time
from typing import Dict, Any, Optional, Callable, List
import numpy as np
from websocket import create_connection

logger = logging.getLogger(__name__)

class LidarSensor:
    """Subscribe to and process lidar scan data via ROSBridge"""
    
    def __init__(self, ros_bridge):
        """
        Initialize lidar sensor
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.scan_callback = None
        self.latest_scan = None
        self.subscription_active = False
        self._ws = None
        self._ws_thread = None
        self._stop_thread = False
        
    def subscribe(self, callback: Optional[Callable] = None, 
                 processed_data: bool = True) -> bool:
        """
        Subscribe to /scan topic
        
        Args:
            callback: Optional callback function for new scan data
            processed_data: If True, return processed data; if False, return raw
        
        Returns:
            bool: Success status
        """
        try:
            # Create a dedicated connection for subscription
            self._ws = create_connection(self.ros_bridge.url, timeout=5)
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": "/scan",
                "type": "sensor_msgs/LaserScan"
            }
            
            self._ws.send(json.dumps(subscribe_msg))
            logger.info("Subscribed to /scan topic")
            
            # Start receiving thread
            self.subscription_active = True
            self._stop_thread = False
            self._ws_thread = threading.Thread(
                target=self._receive_scan_data, 
                args=(callback, processed_data)
            )
            self._ws_thread.daemon = True
            self._ws_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to scan: {e}")
            return False
    
    def _receive_scan_data(self, callback, processed_data):
        """Receive scan data in separate thread"""
        while self.subscription_active and not self._stop_thread:
            try:
                response = self._ws.recv()
                data = json.loads(response)
                
                if data.get("op") == "publish" and data.get("topic") == "/scan":
                    msg = data["msg"]
                    
                    if processed_data:
                        # Process the data for easier use
                        processed = self._process_scan_data(msg)
                        self.latest_scan = processed
                        
                        if callback:
                            callback(processed)
                    else:
                        # Return raw data
                        self.latest_scan = msg
                        
                        if callback:
                            callback(msg)
                            
            except Exception as e:
                if self.subscription_active:
                    logger.error(f"Error receiving scan data: {e}")
                break
        
        if self._ws:
            self._ws.close()
        logger.info("Scan subscription thread ended")
    
    def _process_scan_data(self, scan_msg: Dict) -> Dict[str, Any]:
        """
        Process raw scan data into more useful format
        
        Args:
            scan_msg: Raw LaserScan message
            
        Returns:
            Dict with processed data including points for visualization
        """
        ranges = scan_msg["ranges"]
        angle_min = scan_msg["angle_min"]
        angle_increment = scan_msg["angle_increment"]
        
        # Filter out invalid readings (0.0 or inf)
        valid_ranges = [(i, r) for i, r in enumerate(ranges) 
                       if r > 0.1 and r < 10.0]
        
        if not valid_ranges:
            return {
                "min_distance": float('inf'),
                "min_angle": 0,
                "obstacles": [],
                "safe_directions": ["all"],
                "points": [],
                "timestamp": time.time(),
                "point_count": 0
            }
        
        # Find minimum distance
        min_idx, min_dist = min(valid_ranges, key=lambda x: x[1])
        min_angle = angle_min + min_idx * angle_increment
        
        # Convert to cartesian coordinates for visualization
        points = []
        obstacles = []
        
        for idx, dist in valid_ranges:
            angle = angle_min + idx * angle_increment
            x = dist * np.cos(angle)
            y = dist * np.sin(angle)
            
            points.append({
                "x": float(x),
                "y": float(y),
                "r": float(dist),
                "theta": float(angle),
                "theta_deg": float(np.degrees(angle))
            })
            
            # Detect obstacles (anything closer than 0.5m)
            if dist < 0.5:
                obstacles.append({
                    "angle": float(angle),
                    "angle_deg": float(np.degrees(angle)),
                    "distance": float(dist),
                    "x": float(x),
                    "y": float(y)
                })
        
        # Determine safe directions
        safe_directions = self._calculate_safe_directions(valid_ranges, angle_min, angle_increment)
        
        return {
            "min_distance": float(min_dist),
            "min_angle": float(min_angle),
            "min_angle_deg": float(np.degrees(min_angle)),
            "obstacles": obstacles,
            "safe_directions": safe_directions,
            "obstacle_count": len(obstacles),
            "points": points,
            "point_count": len(points),
            "timestamp": time.time()
        }
    
    def _calculate_safe_directions(self, valid_ranges, angle_min, angle_increment):
        """Calculate safe movement directions based on scan data"""
        safe_directions = []
        
        # Check sectors (front, left, right, back)
        sectors = {
            "front": (-30, 30),
            "left": (60, 120),
            "right": (-120, -60),
            "back": (150, 180)  # and (-180, -150)
        }
        
        for direction, (start_deg, end_deg) in sectors.items():
            start_rad = np.radians(start_deg)
            end_rad = np.radians(end_deg)
            
            # Check if sector is clear
            sector_clear = True
            for idx, dist in valid_ranges:
                angle = angle_min + idx * angle_increment
                
                # Handle back sector wraparound
                if direction == "back":
                    if (angle > np.radians(150) or angle < np.radians(-150)):
                        if dist < 0.5:
                            sector_clear = False
                            break
                else:
                    if start_rad <= angle <= end_rad and dist < 0.5:
                        sector_clear = False
                        break
            
            if sector_clear:
                safe_directions.append(direction)
        
        return safe_directions
    
    def get_latest_scan(self) -> Optional[Dict[str, Any]]:
        """Get the most recent scan data"""
        return self.latest_scan
    
    def unsubscribe(self):
        """Stop subscription"""
        self.subscription_active = False
        self._stop_thread = True
        if self._ws_thread:
            self._ws_thread.join(timeout=2)
        logger.info("Unsubscribed from scan topic")

# Singleton instance
_lidar_sensor = None

def get_lidar_sensor():
    """Get or create LidarSensor instance"""
    global _lidar_sensor
    if _lidar_sensor is None:
        from backend.ros_bridge import get_ros_bridge
        _lidar_sensor = LidarSensor(get_ros_bridge())
    return _lidar_sensor
================================================================================


================================================================================
FILE: dashboard_scan.txt
================================================================================
================================================================================
ROBOT DASHBOARD COMPLETE SCAN
Path: /Users/yang/Library/CloudStorage/OneDrive-Personal/UCL/Year 4 UCL/MECH0073/GitHub_Repositories/Fire-fighting-Robot/robot-dashboard
================================================================================

DIRECTORY STRUCTURE:
----------------------------------------
├── backend
│   ├── __pycache__
│   ├── sensors
│   │   ├── __pycache__
│   │   ├── __init__.py
│   │   └── lidar.py
│   ├── venv
│   ├── __init__.py
│   ├── config_manager.py
│   ├── host_backend.py
│   └── ros_bridge.py
├── frontend
│   └── templates
│       ├── dashboard_home.html
│       ├── lidar_visualization.html
│       └── motor_control.html
├── ui
│   └── node_modules
├── dashboard_scan.txt
├── dashboard_scan_output.txt
├── dashboard_scanner.py
├── requirements.txt
└── run.py

================================================================================
FILE CONTENTS:
================================================================================

================================================================================
FILE: backend/__init__.py
================================================================================
"""
Backend package for ROS 2 Motor Control
"""

from .ros_bridge import ROSBridgeConnection, MotorController, get_ros_bridge, get_motor_controller

__all__ = [
    'ROSBridgeConnection',
    'MotorController', 
    'get_ros_bridge',
    'get_motor_controller'
]

__version__ = '1.0.0'
================================================================================


================================================================================
FILE: backend/config_manager.py
================================================================================
#!/usr/bin/env python3
"""
Configuration manager for persistent settings
Saves and loads configuration from a JSON file
"""

import json
import os
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class ConfigManager:
    """Manages persistent configuration settings"""
    
    def __init__(self, config_file: str = None):
        """
        Initialize configuration manager
        
        Args:
            config_file: Path to configuration file (default: ~/.robot_dashboard_config.json)
        """
        if config_file is None:
            # Use home directory for config file
            self.config_file = Path.home() / ".robot_dashboard_config.json"
        else:
            self.config_file = Path(config_file)
        
        # Default configuration
        self.default_config = {
            "PI_IP": "192.168.2.1",
            "ROS_BRIDGE_PORT": 9090,
            "FLASK_PORT": 5001,
            "FLASK_HOST": "0.0.0.0"
        }
        
        # Load configuration
        self.config = self.load_config()
    
    def load_config(self) -> dict:
        """Load configuration from file or return defaults"""
        try:
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    loaded_config = json.load(f)
                    # Merge with defaults (in case new fields are added)
                    config = self.default_config.copy()
                    config.update(loaded_config)
                    logger.info(f"Loaded configuration from {self.config_file}")
                    return config
            else:
                logger.info("No config file found, using defaults")
                return self.default_config.copy()
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            return self.default_config.copy()
    
    def save_config(self):
        """Save current configuration to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
            logger.info(f"Saved configuration to {self.config_file}")
            return True
        except Exception as e:
            logger.error(f"Error saving config: {e}")
            return False
    
    def update_config(self, updates: dict) -> bool:
        """
        Update configuration values
        
        Args:
            updates: Dictionary of configuration updates
            
        Returns:
            bool: True if successful
        """
        try:
            # Update configuration
            self.config.update(updates)
            # Save to file
            return self.save_config()
        except Exception as e:
            logger.error(f"Error updating config: {e}")
            return False
    
    def get(self, key: str, default=None):
        """Get configuration value"""
        return self.config.get(key, default)
    
    def get_all(self) -> dict:
        """Get all configuration values"""
        return self.config.copy()

# Singleton instance
_config_manager = None

def get_config_manager(config_file: str = None) -> ConfigManager:
    """Get or create ConfigManager instance"""
    global _config_manager
    if _config_manager is None:
        _config_manager = ConfigManager(config_file)
    return _config_manager
================================================================================


================================================================================
FILE: backend/host_backend.py
================================================================================
#!/usr/bin/env python3
"""
Flask backend server for ROS 2 robot control
Main application entry point with multi-component support
"""

import os
import sys
from pathlib import Path

# Add parent directory to path for imports
sys.path.append(str(Path(__file__).parent.parent))

from flask import Flask, render_template, jsonify, request
from flask_cors import CORS
from flask_socketio import SocketIO, emit
import logging

# Import configuration manager
from backend.config_manager import get_config_manager

# Import ROS bridge components
from backend.ros_bridge import get_ros_bridge, get_motor_controller
from backend.sensors.lidar import get_lidar_sensor

# Create Flask app
app = Flask(__name__, 
            template_folder='../frontend/templates',
            static_folder='../frontend/static')
CORS(app)  # Enable CORS for API requests
socketio = SocketIO(app, cors_allowed_origins="*")  # For real-time lidar data

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Load configuration from persistent storage
config_manager = get_config_manager()
CONFIG = config_manager.get_all()

# Initialize ROS components with saved configuration
ros_bridge = get_ros_bridge(CONFIG["PI_IP"], CONFIG["ROS_BRIDGE_PORT"])
motor_controller = get_motor_controller()
lidar_sensor = get_lidar_sensor()

# Lidar data streaming state
lidar_streaming = False

# =============================================================================
# MAIN DASHBOARD ROUTES
# =============================================================================

@app.route('/')
def index():
    """Serve the main dashboard home page"""
    return render_template('dashboard_home.html')

@app.route('/motors')
def motors_page():
    """Serve the motor control interface"""
    return render_template('motor_control.html')

@app.route('/lidar')
def lidar_page():
    """Serve the lidar visualization interface"""
    return render_template('lidar_visualization.html')

# =============================================================================
# MOTOR CONTROL API ROUTES
# =============================================================================

@app.route('/api/motor/<int:motor_id>', methods=['POST'])
def control_motor(motor_id):
    """Control a specific motor"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        # Use motor controller
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in control_motor: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/motor/<int:motor_id>', methods=['GET'])
def get_motor_status(motor_id):
    """Get current status of a specific motor"""
    state = motor_controller.get_motor_state(motor_id)
    
    if state:
        return jsonify({
            "success": True,
            "motor_id": motor_id,
            "state": state
        })
    else:
        return jsonify({
            "success": False,
            "error": "Invalid motor ID"
        }), 404

@app.route('/api/motors', methods=['GET'])
def get_all_motors_status():
    """Get current status of all motors"""
    states = motor_controller.get_all_motor_states()
    
    return jsonify({
        "success": True,
        "motors": states
    })

@app.route('/api/motors/stop', methods=['POST'])
def stop_all_motors():
    """Emergency stop - brake all motors"""
    result = motor_controller.stop_all_motors()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

# =============================================================================
# LIDAR API ROUTES
# =============================================================================

@app.route('/api/lidar/status', methods=['GET'])
def get_lidar_status():
    """Get lidar sensor status"""
    latest_scan = lidar_sensor.get_latest_scan()
    
    return jsonify({
        "connected": lidar_sensor.subscription_active,
        "has_data": latest_scan is not None,
        "timestamp": latest_scan["timestamp"] if latest_scan else None
    })

@app.route('/api/lidar/latest', methods=['GET'])
def get_latest_lidar_scan():
    """Get the most recent lidar scan data"""
    scan_data = lidar_sensor.get_latest_scan()
    
    if scan_data:
        return jsonify({
            "success": True,
            "data": scan_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "No scan data available"
        }), 404

@app.route('/api/lidar/subscribe', methods=['POST'])
def subscribe_lidar():
    """Start lidar data subscription"""
    global lidar_streaming
    
    def lidar_callback(scan_data):
        """Emit lidar data through WebSocket"""
        if lidar_streaming:
            socketio.emit('lidar_data', scan_data)
    
    success = lidar_sensor.subscribe(callback=lidar_callback, processed_data=True)
    
    if success:
        lidar_streaming = True
        return jsonify({"success": True, "message": "Lidar subscription started"})
    else:
        return jsonify({"success": False, "error": "Failed to subscribe to lidar"}), 500

@app.route('/api/lidar/unsubscribe', methods=['POST'])
def unsubscribe_lidar():
    """Stop lidar data subscription"""
    global lidar_streaming
    
    lidar_streaming = False
    lidar_sensor.unsubscribe()
    
    return jsonify({"success": True, "message": "Lidar subscription stopped"})

# =============================================================================
# SYSTEM STATUS ROUTES
# =============================================================================

@app.route('/api/status', methods=['GET'])
def get_system_status():
    """Check connection status to ROS bridge and system info"""
    ros_connected = ros_bridge.test_connection()
    
    return jsonify({
        "connected": ros_connected,
        "rosbridge_url": ros_bridge.url,
        "config": {
            "robot_ip": CONFIG["PI_IP"],
            "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"]
        },
        "components": {
            "motors": True,
            "lidar": lidar_sensor.subscription_active
        }
    }), 200 if ros_connected else 503

@app.route('/api/config', methods=['GET'])
def get_config():
    """Get current configuration"""
    return jsonify({
        "robot_ip": CONFIG["PI_IP"],
        "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"],
        "flask_port": CONFIG["FLASK_PORT"],
        "flask_host": CONFIG["FLASK_HOST"]
    })

@app.route('/api/config', methods=['POST'])
def update_config():
    """Update configuration with new connection settings"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        # Get new settings
        new_ip = data.get('robot_ip')
        new_port = data.get('rosbridge_port')
        
        if not new_ip or not new_port:
            return jsonify({"error": "Missing robot_ip or rosbridge_port"}), 400
        
        # Update configuration in memory
        CONFIG["PI_IP"] = new_ip
        CONFIG["ROS_BRIDGE_PORT"] = int(new_port)
        
        # Save to persistent storage
        config_updates = {
            "PI_IP": new_ip,
            "ROS_BRIDGE_PORT": int(new_port)
        }
        config_manager.update_config(config_updates)
        
        # Update ROS bridge connection
        global ros_bridge, motor_controller, lidar_sensor
        ros_bridge = get_ros_bridge(CONFIG["PI_IP"], CONFIG["ROS_BRIDGE_PORT"])
        motor_controller = get_motor_controller()
        lidar_sensor = get_lidar_sensor()
        
        logger.info(f"Configuration updated and saved: IP={new_ip}, Port={new_port}")
        
        return jsonify({
            "success": True,
            "message": "Configuration updated successfully",
            "config": {
                "robot_ip": CONFIG["PI_IP"],
                "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"]
            }
        })
        
    except Exception as e:
        logger.error(f"Error updating configuration: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

# =============================================================================
# WEBSOCKET EVENTS
# =============================================================================

@socketio.on('connect')
def handle_connect():
    """Handle WebSocket connection"""
    logger.info("Client connected to WebSocket")
    emit('connected', {'data': 'Connected to robot dashboard'})

@socketio.on('disconnect')
def handle_disconnect():
    """Handle WebSocket disconnection"""
    logger.info("Client disconnected from WebSocket")

# =============================================================================
# ERROR HANDLERS
# =============================================================================

@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Not found"}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Internal server error"}), 500

# Health check endpoint
@app.route('/health', methods=['GET'])
def health_check():
    """Simple health check endpoint"""
    return jsonify({
        "status": "healthy",
        "service": "robot-dashboard-backend"
    })

def main():
    """Main entry point"""
    logger.info("=" * 50)
    logger.info("ROS 2 Robot Dashboard Backend")
    logger.info(f"Robot IP: {CONFIG['PI_IP']}")
    logger.info(f"ROS Bridge Port: {CONFIG['ROS_BRIDGE_PORT']}")
    logger.info(f"Flask Server: {CONFIG['FLASK_HOST']}:{CONFIG['FLASK_PORT']}")
    logger.info(f"Config file: {config_manager.config_file}")
    logger.info("=" * 50)
    
    # Run Flask app with SocketIO
    debug_mode = os.environ.get('FLASK_ENV', 'development') == 'development'
    
    socketio.run(
        app,
        debug=debug_mode,
        host=CONFIG['FLASK_HOST'],
        port=CONFIG['FLASK_PORT'],
        use_reloader=False  # Disable auto-reloader to prevent numpy reload issues
    )

if __name__ == '__main__':
    main()
================================================================================


================================================================================
FILE: backend/ros_bridge.py
================================================================================
#!/usr/bin/env python3
"""
ROS Bridge WebSocket communication module
Handles all ROS 2 communication via rosbridge
"""

import json
import logging
from websocket import create_connection
from typing import Dict, Any, Optional, Tuple

# Setup logging
logger = logging.getLogger(__name__)

class ROSBridgeConnection:
    """Manages WebSocket connection to ROS 2 via rosbridge"""
    
    def __init__(self, host: str = "192.168.2.4", port: int = 9090):
        """
        Initialize ROS Bridge connection parameters
        
        Args:
            host: IP address of the ROS 2 robot
            port: rosbridge websocket port (default: 9090)
        """
        self.host = host
        self.port = port
        self.url = f"ws://{host}:{port}"
        self._connection = None
    
    def connect(self) -> bool:
        """
        Establish connection to rosbridge
        
        Returns:
            bool: True if connection successful, False otherwise
        """
        try:
            self._connection = create_connection(self.url, timeout=5)
            logger.info(f"Connected to rosbridge at {self.url}")
            return True
        except Exception as e:
            logger.error(f"Failed to connect to rosbridge: {e}")
            return False
    
    def disconnect(self):
        """Close the websocket connection"""
        if self._connection:
            self._connection.close()
            self._connection = None
            logger.info("Disconnected from rosbridge")
    
    def is_connected(self) -> bool:
        """Check if connection is active"""
        return self._connection is not None
    
    def call_service(self, service_name: str, args: Dict[str, Any], 
                    service_id: Optional[str] = None) -> Tuple[bool, Dict[str, Any]]:
        """
        Call a ROS service through rosbridge
        
        Args:
            service_name: Name of the ROS service (e.g., "/set_motor")
            args: Service arguments as dictionary
            service_id: Optional ID for the service call
        
        Returns:
            Tuple[bool, Dict]: (success, response_data)
        """
        try:
            # Try to create a new connection for each call to avoid broken pipe
            ws = create_connection(self.url, timeout=5)
            
            # Prepare service call message
            request = {
                "op": "call_service",
                "service": service_name,
                "args": args
            }
            
            if service_id:
                request["id"] = service_id
            
            # Send request
            ws.send(json.dumps(request))
            
            # Get response
            response = ws.recv()
            response_data = json.loads(response)
            
            # Close connection
            ws.close()
            
            logger.debug(f"Service call response: {response_data}")
            return True, response_data
            
        except Exception as e:
            logger.error(f"Service call failed: {e}")
            return False, {"error": str(e)}
    
    def test_connection(self) -> bool:
        """
        Test if rosbridge connection is working
        
        Returns:
            bool: True if connection is working
        """
        try:
            temp_conn = create_connection(self.url, timeout=2)
            temp_conn.close()
            return True
        except Exception:
            return False

class MotorController:
    """High-level motor control interface using ROSBridge"""
    
    def __init__(self, ros_bridge: ROSBridgeConnection):
        """
        Initialize motor controller
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.motor_states = {
            0: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            1: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            2: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            3: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0}
        }
    
    @staticmethod
    def percent_to_pwm(percent: float) -> int:
        """
        Convert percentage (0-100) to PWM value (0-65535)
        
        For dual-PWM motor drivers, use NORMAL mapping:
        - 0% speed → PWM 0 (motor stopped)
        - 100% speed → PWM 65535 (motor full speed)
        
        Note: The previous INVERTED mapping was for different motor drivers
        """
        # Ensure percent is within bounds
        percent = max(0, min(100, percent))
        
        # NORMAL PWM calculation (not inverted)
        # 0% → 0, 100% → 65535
        pwm = int((percent / 100.0) * 65535)
        
        logger.debug(f"Converting {percent}% to PWM: {pwm}")
        return pwm
    
    @staticmethod
    def pwm_to_percent(pwm: int) -> float:
        """
        Convert PWM value (0-65535) to percentage (0-100)
        
        Using NORMAL mapping:
        - PWM 0 = 0% speed
        - PWM 65535 = 100% speed
        """
        # NORMAL calculation (not inverted)
        return round((pwm / 65535.0) * 100, 1)
    
    def set_motor(self, motor_id: int, direction: str, speed_percent: float) -> Dict[str, Any]:
        """
        Set motor speed and direction
        
        Args:
            motor_id: Motor ID (0-3)
            direction: Direction ("forward", "backward", "brake")
            speed_percent: Speed in percentage (0-100)
        
        Returns:
            Dict containing operation result
        """
        # Validate inputs
        if motor_id < 0 or motor_id > 3:
            return {
                "success": False,
                "error": "Invalid motor ID. Must be 0-3"
            }
        
        if direction not in ["forward", "backward", "brake"]:
            return {
                "success": False,
                "error": "Invalid direction. Must be 'forward', 'backward', or 'brake'"
            }
        
        if not isinstance(speed_percent, (int, float)) or speed_percent < 0 or speed_percent > 100:
            return {
                "success": False,
                "error": "Invalid speed. Must be 0-100"
            }
        
        # Convert to PWM with NORMAL mapping
        if direction == "brake":
            # Brake always uses PWM 0
            speed_pwm = 0
        else:
            # Use normal PWM mapping: 0% = PWM 0, 100% = PWM 65535
            speed_pwm = self.percent_to_pwm(speed_percent)
        
        # Call ROS service (connection is handled in call_service)
        service_args = {
            "motor_id": motor_id,
            "direction": direction,
            "speed": speed_pwm
        }
        
        logger.info(f"Sending to ROS - Motor: {motor_id}, Direction: {direction}, Speed: {speed_percent}% (PWM: {speed_pwm})")
        
        success, response = self.ros_bridge.call_service(
            "/set_motor", 
            service_args,
            f"motor_cmd_{motor_id}"
        )
        
        if success:
            # Update internal state
            self.motor_states[motor_id] = {
                "direction": direction,
                "speed_percent": speed_percent,
                "speed_pwm": speed_pwm
            }
            
            logger.info(f"Motor {motor_id} set to {direction} at {speed_percent}% (PWM: {speed_pwm})")
            
            return {
                "success": True,
                "motor_id": motor_id,
                "direction": direction,
                "speed_percent": speed_percent,
                "speed_pwm": speed_pwm,
                "response": response
            }
        else:
            return {
                "success": False,
                "error": response.get("error", "Unknown error"),
                "motor_id": motor_id
            }
    
    def stop_all_motors(self) -> Dict[str, Any]:
        """
        Emergency stop - brake all motors
        
        Returns:
            Dict containing results for all motors
        """
        results = []
        
        for motor_id in range(4):
            # Brake with speed 0
            result = self.set_motor(motor_id, "brake", 0)
            results.append(result)
        
        all_success = all(r["success"] for r in results)
        
        return {
            "success": all_success,
            "results": results
        }
    
    def get_motor_state(self, motor_id: int) -> Optional[Dict[str, Any]]:
        """
        Get current state of a motor
        
        Args:
            motor_id: Motor ID (0-3)
        
        Returns:
            Dict with motor state or None if invalid ID
        """
        if motor_id in self.motor_states:
            return self.motor_states[motor_id].copy()
        return None
    
    def get_all_motor_states(self) -> Dict[int, Dict[str, Any]]:
        """Get current state of all motors"""
        return self.motor_states.copy()

# Create singleton instances for easy import
_ros_bridge = None
_motor_controller = None

def get_ros_bridge(host: str = None, port: int = None) -> ROSBridgeConnection:
    """Get or create ROSBridge connection instance"""
    global _ros_bridge
    
    # If host/port provided, update or create new connection
    if host is not None or port is not None:
        if _ros_bridge:
            # Update existing connection
            if host:
                _ros_bridge.host = host
                _ros_bridge.url = f"ws://{host}:{_ros_bridge.port}"
            if port:
                _ros_bridge.port = port
                _ros_bridge.url = f"ws://{_ros_bridge.host}:{port}"
        else:
            # Create new connection with provided settings
            _ros_bridge = ROSBridgeConnection(
                host or "192.168.2.4", 
                port or 9090
            )
    elif _ros_bridge is None:
        # Create with defaults if not exists
        _ros_bridge = ROSBridgeConnection()
    
    return _ros_bridge

def get_motor_controller() -> MotorController:
    """Get or create MotorController instance"""
    global _motor_controller
    if _motor_controller is None:
        _motor_controller = MotorController(get_ros_bridge())
    return _motor_controller
================================================================================


================================================================================
FILE: backend/sensors/__init__.py
================================================================================
"""
Sensor modules for ROS 2 robot
"""

from .lidar import LidarSensor, get_lidar_sensor

__all__ = [
    'LidarSensor',
    'get_lidar_sensor'
]
================================================================================


================================================================================
FILE: backend/sensors/lidar.py
================================================================================
#!/usr/bin/env python3
"""
Lidar sensor module for ROS 2
Handles lidar data subscription and processing
"""

import json
import logging
import threading
import time
from typing import Dict, Any, Optional, Callable, List
import numpy as np
from websocket import create_connection

logger = logging.getLogger(__name__)

class LidarSensor:
    """Subscribe to and process lidar scan data via ROSBridge"""
    
    def __init__(self, ros_bridge):
        """
        Initialize lidar sensor
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.scan_callback = None
        self.latest_scan = None
        self.subscription_active = False
        self._ws = None
        self._ws_thread = None
        self._stop_thread = False
        
    def subscribe(self, callback: Optional[Callable] = None, 
                 processed_data: bool = True) -> bool:
        """
        Subscribe to /scan topic
        
        Args:
            callback: Optional callback function for new scan data
            processed_data: If True, return processed data; if False, return raw
        
        Returns:
            bool: Success status
        """
        try:
            # Create a dedicated connection for subscription
            self._ws = create_connection(self.ros_bridge.url, timeout=5)
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": "/scan",
                "type": "sensor_msgs/LaserScan"
            }
            
            self._ws.send(json.dumps(subscribe_msg))
            logger.info("Subscribed to /scan topic")
            
            # Start receiving thread
            self.subscription_active = True
            self._stop_thread = False
            self._ws_thread = threading.Thread(
                target=self._receive_scan_data, 
                args=(callback, processed_data)
            )
            self._ws_thread.daemon = True
            self._ws_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to scan: {e}")
            return False
    
    def _receive_scan_data(self, callback, processed_data):
        """Receive scan data in separate thread"""
        while self.subscription_active and not self._stop_thread:
            try:
                response = self._ws.recv()
                data = json.loads(response)
                
                if data.get("op") == "publish" and data.get("topic") == "/scan":
                    msg = data["msg"]
                    
                    if processed_data:
                        # Process the data for easier use
                        processed = self._process_scan_data(msg)
                        self.latest_scan = processed
                        
                        if callback:
                            callback(processed)
                    else:
                        # Return raw data
                        self.latest_scan = msg
                        
                        if callback:
                            callback(msg)
                            
            except Exception as e:
                if self.subscription_active:
                    logger.error(f"Error receiving scan data: {e}")
                break
        
        if self._ws:
            self._ws.close()
        logger.info("Scan subscription thread ended")
    
    def _process_scan_data(self, scan_msg: Dict) -> Dict[str, Any]:
        """
        Process raw scan data into more useful format
        
        Args:
            scan_msg: Raw LaserScan message
            
        Returns:
            Dict with processed data including points for visualization
        """
        ranges = scan_msg["ranges"]
        angle_min = scan_msg["angle_min"]
        angle_increment = scan_msg["angle_increment"]
        
        # Filter out invalid readings (0.0 or inf)
        valid_ranges = [(i, r) for i, r in enumerate(ranges) 
                       if r > 0.1 and r < 10.0]
        
        if not valid_ranges:
            return {
                "min_distance": float('inf'),
                "min_angle": 0,
                "obstacles": [],
                "safe_directions": ["all"],
                "points": [],
                "timestamp": time.time(),
                "point_count": 0
            }
        
        # Find minimum distance
        min_idx, min_dist = min(valid_ranges, key=lambda x: x[1])
        min_angle = angle_min + min_idx * angle_increment
        
        # Convert to cartesian coordinates for visualization
        points = []
        obstacles = []
        
        for idx, dist in valid_ranges:
            angle = angle_min + idx * angle_increment
            x = dist * np.cos(angle)
            y = dist * np.sin(angle)
            
            points.append({
                "x": float(x),
                "y": float(y),
                "r": float(dist),
                "theta": float(angle),
                "theta_deg": float(np.degrees(angle))
            })
            
            # Detect obstacles (anything closer than 0.5m)
            if dist < 0.5:
                obstacles.append({
                    "angle": float(angle),
                    "angle_deg": float(np.degrees(angle)),
                    "distance": float(dist),
                    "x": float(x),
                    "y": float(y)
                })
        
        # Determine safe directions
        safe_directions = self._calculate_safe_directions(valid_ranges, angle_min, angle_increment)
        
        return {
            "min_distance": float(min_dist),
            "min_angle": float(min_angle),
            "min_angle_deg": float(np.degrees(min_angle)),
            "obstacles": obstacles,
            "safe_directions": safe_directions,
            "obstacle_count": len(obstacles),
            "points": points,
            "point_count": len(points),
            "timestamp": time.time()
        }
    
    def _calculate_safe_directions(self, valid_ranges, angle_min, angle_increment):
        """Calculate safe movement directions based on scan data"""
        safe_directions = []
        
        # Check sectors (front, left, right, back)
        sectors = {
            "front": (-30, 30),
            "left": (60, 120),
            "right": (-120, -60),
            "back": (150, 180)  # and (-180, -150)
        }
        
        for direction, (start_deg, end_deg) in sectors.items():
            start_rad = np.radians(start_deg)
            end_rad = np.radians(end_deg)
            
            # Check if sector is clear
            sector_clear = True
            for idx, dist in valid_ranges:
                angle = angle_min + idx * angle_increment
                
                # Handle back sector wraparound
                if direction == "back":
                    if (angle > np.radians(150) or angle < np.radians(-150)):
                        if dist < 0.5:
                            sector_clear = False
                            break
                else:
                    if start_rad <= angle <= end_rad and dist < 0.5:
                        sector_clear = False
                        break
            
            if sector_clear:
                safe_directions.append(direction)
        
        return safe_directions
    
    def get_latest_scan(self) -> Optional[Dict[str, Any]]:
        """Get the most recent scan data"""
        return self.latest_scan
    
    def unsubscribe(self):
        """Stop subscription"""
        self.subscription_active = False
        self._stop_thread = True
        if self._ws_thread:
            self._ws_thread.join(timeout=2)
        logger.info("Unsubscribed from scan topic")

# Singleton instance
_lidar_sensor = None

def get_lidar_sensor():
    """Get or create LidarSensor instance"""
    global _lidar_sensor
    if _lidar_sensor is None:
        from backend.ros_bridge import get_ros_bridge
        _lidar_sensor = LidarSensor(get_ros_bridge())
    return _lidar_sensor
================================================================================


================================================================================
FILE: dashboard_scan_output.txt
================================================================================

================================================================================


================================================================================
FILE: frontend/templates/dashboard_home.html
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Fighting Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 30px;
            text-align: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 3em;
            font-weight: 300;
            letter-spacing: 3px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: gradient 3s ease infinite;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .subtitle {
            color: #888;
            font-size: 1.2em;
            font-weight: 300;
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 60px 20px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .components-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 40px;
            margin-bottom: 60px;
        }

        .component-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .component-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.05) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .component-card:hover::before {
            opacity: 1;
        }

        .component-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7);
            border-color: #555;
        }

        .component-icon {
            font-size: 4em;
            margin-bottom: 20px;
            display: block;
            text-align: center;
        }

        .motor-icon {
            background: linear-gradient(45deg, #00aaff, #0088cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .lidar-icon {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .camera-icon {
            background: linear-gradient(45deg, #ff6b6b, #ff4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .sensor-icon {
            background: linear-gradient(45deg, #ffd93d, #ffb300);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .component-title {
            font-size: 2em;
            font-weight: 500;
            margin-bottom: 15px;
            text-align: center;
        }

        .component-description {
            color: #aaa;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .component-status {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .component-status.active {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .component-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .component-card.disabled:hover {
            transform: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .info-section {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 30px;
            margin-top: 40px;
            border: 1px solid #333;
        }

        .info-title {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #00aaff;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .info-item {
            padding: 15px;
            background: #252525;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.2em;
            font-weight: 500;
        }

        .header-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .settings-btn {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        .settings-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: #1a1a1a;
            margin: 10% auto;
            padding: 30px;
            border: 1px solid #333;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .modal-title {
            font-size: 1.8em;
            color: #00aaff;
        }

        .close-btn {
            font-size: 2em;
            color: #888;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-btn:hover {
            color: #fff;
        }

        .settings-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-label {
            color: #aaa;
            font-size: 1.1em;
        }

        .form-input {
            padding: 12px;
            background: #252525;
            border: 1px solid #444;
            border-radius: 8px;
            color: #fff;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #00aaff;
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.3);
        }

        .form-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .btn-secondary {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
        }

        .btn-secondary:hover {
            background: #3a3a3a;
        }

        .connection-info {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid #333;
        }

        .connection-info p {
            margin: 5px 0;
            color: #888;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .components-grid {
                grid-template-columns: 1fr;
            }
            
            .component-icon {
                font-size: 3em;
            }
            
            .modal-content {
                margin: 20% auto;
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Fire Fighting Robot</h1>
        <p class="subtitle">Control & Monitoring Dashboard</p>
        <div class="status-bar">
            <div class="header-controls">
                <div class="status-item">
                    <span>ROS Bridge:</span>
                    <div class="status-indicator" id="rosStatus"></div>
                    <span id="rosStatusText">Disconnected</span>
                </div>
                <button class="settings-btn" onclick="openSettings()">⚙️ Connection Settings</button>
            </div>
            <div class="status-item">
                <span>System:</span>
                <div class="status-indicator connected"></div>
                <span>Online</span>
            </div>
        </div>
    </div>

    <!-- Connection Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Connection Settings</h2>
                <span class="close-btn" onclick="closeSettings()">&times;</span>
            </div>
            <form class="settings-form" onsubmit="saveSettings(event)">
                <div class="form-group">
                    <label class="form-label">Robot IP Address</label>
                    <input type="text" 
                           id="robotIP" 
                           class="form-input" 
                           placeholder="192.168.x.x" 
                           pattern="^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
                           required>
                </div>
                <div class="form-group">
                    <label class="form-label">ROS Bridge Port</label>
                    <input type="number" 
                           id="bridgePort" 
                           class="form-input" 
                           placeholder="9090" 
                           min="1" 
                           max="65535"
                           required>
                </div>
                <div class="connection-info">
                    <p>Current Connection: <span id="currentConnection">Not configured</span></p>
                    <p>Last Connected: <span id="lastConnected">Never</span></p>
                </div>
                <div class="form-buttons">
                    <button type="submit" class="btn btn-primary">Connect</button>
                    <button type="button" class="btn btn-secondary" onclick="closeSettings()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <div class="main-container">
        <div class="components-grid">
            <!-- Motor Control -->
            <div class="component-card" onclick="navigateTo('/motors')">
                <span class="component-icon motor-icon">⚙️</span>
                <h2 class="component-title">Motor Control</h2>
                <p class="component-description">
                    Control all 4 motors independently with forward, backward, and brake modes. 
                    Real-time speed adjustment and emergency stop.
                </p>
                <div class="component-status active">
                    <div class="status-indicator connected"></div>
                    <span>2 Motor Channels Ready</span>
                </div>
            </div>

            <!-- Lidar Sensor -->
            <div class="component-card" onclick="navigateTo('/lidar')">
                <span class="component-icon lidar-icon">📡</span>
                <h2 class="component-title">Lidar Sensor</h2>
                <p class="component-description">
                    Real-time 360° environment scanning and obstacle detection. 
                    Visualize surroundings and safe navigation paths.
                </p>
                <div class="component-status" id="lidarStatus">
                    <div class="status-indicator"></div>
                    <span>Click to Activate</span>
                </div>
            </div>

            <!-- Camera (Future) -->
            <div class="component-card disabled">
                <span class="component-icon camera-icon">📷</span>
                <h2 class="component-title">Camera Feed</h2>
                <p class="component-description">
                    Live video streaming and fire detection using computer vision. 
                    Coming soon...
                </p>
                <div class="component-status">
                    <div class="status-indicator"></div>
                    <span>Not Available</span>
                </div>
            </div>

            <!-- Sensors (Future) -->
            <div class="component-card disabled">
                <span class="component-icon sensor-icon">🌡️</span>
                <h2 class="component-title">Sensors</h2>
                <p class="component-description">
                    Temperature, smoke, and flame sensors for fire detection. 
                    Coming soon...
                </p>
                <div class="component-status">
                    <div class="status-indicator"></div>
                    <span>Not Available</span>
                </div>
            </div>
        </div>

        <div class="info-section">
            <h3 class="info-title">System Information</h3>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Robot IP</div>
                    <div class="info-value" id="robotIP">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">ROS Bridge Port</div>
                    <div class="info-value" id="bridgePort">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Active Components</div>
                    <div class="info-value" id="activeComponents">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">System Uptime</div>
                    <div class="info-value" id="uptime">00:00:00</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Navigation function
        function navigateTo(path) {
            window.location.href = path;
        }

        // Connection settings management
        let connectionSettings = {
            robotIP: localStorage.getItem('robotIP') || '192.168.2.1',
            bridgePort: localStorage.getItem('bridgePort') || '9090'
        };

        // Initialize settings on page load
        function initializeSettings() {
            document.getElementById('robotIP').value = connectionSettings.robotIP;
            document.getElementById('bridgePort').value = connectionSettings.bridgePort;
            updateConnectionInfo();
        }

        // Open settings modal
        function openSettings() {
            document.getElementById('settingsModal').style.display = 'block';
            initializeSettings();
        }

        // Close settings modal
        function closeSettings() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        // Save settings and update connection
        async function saveSettings(event) {
            event.preventDefault();
            
            const newIP = document.getElementById('robotIP').value;
            const newPort = document.getElementById('bridgePort').value;
            
            // Save to localStorage
            localStorage.setItem('robotIP', newIP);
            localStorage.setItem('bridgePort', newPort);
            localStorage.setItem('lastConnectAttempt', new Date().toLocaleString());
            
            // Update backend configuration
            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        robot_ip: newIP,
                        rosbridge_port: parseInt(newPort)
                    })
                });
                
                if (response.ok) {
                    connectionSettings.robotIP = newIP;
                    connectionSettings.bridgePort = newPort;
                    
                    // Test the new connection
                    await checkSystemStatus();
                    
                    // Close modal and show success
                    closeSettings();
                    updateConnectionInfo();
                    
                    // Inform user that pages need to be refreshed
                    if (confirm('Connection settings updated. Refresh all open dashboard pages to apply changes?')) {
                        window.location.reload();
                    }
                } else {
                    alert('Failed to update connection settings');
                }
            } catch (error) {
                alert('Error updating settings: ' + error.message);
            }
        }

        // Update connection info display
        function updateConnectionInfo() {
            const currentConn = document.getElementById('currentConnection');
            const lastConn = document.getElementById('lastConnected');
            
            currentConn.textContent = `${connectionSettings.robotIP}:${connectionSettings.bridgePort}`;
            lastConn.textContent = localStorage.getItem('lastConnectAttempt') || 'Never';
        }

        // Check system status with current settings
        async function checkSystemStatus() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                
                // Update ROS connection status
                const rosIndicator = document.getElementById('rosStatus');
                const rosStatusText = document.getElementById('rosStatusText');
                
                if (data.connected) {
                    rosIndicator.classList.add('connected');
                    rosStatusText.textContent = 'Connected';
                    localStorage.setItem('lastSuccessfulConnection', new Date().toLocaleString());
                } else {
                    rosIndicator.classList.remove('connected');
                    rosStatusText.textContent = 'Disconnected';
                }
                
                // Update system info
                if (data.config) {
                    document.getElementById('robotIP').textContent = data.config.robot_ip;
                    document.getElementById('bridgePort').textContent = data.config.rosbridge_port;
                }
                
                // Update component status
                let activeCount = 0;
                if (data.components) {
                    if (data.components.motors) activeCount++;
                    if (data.components.lidar) {
                        activeCount++;
                        const lidarStatus = document.getElementById('lidarStatus');
                        lidarStatus.classList.add('active');
                        lidarStatus.innerHTML = '<div class="status-indicator connected"></div><span>Active</span>';
                    }
                }
                document.getElementById('activeComponents').textContent = activeCount;
                
            } catch (error) {
                console.error('Error checking status:', error);
                // If the backend isn't responding, show disconnected
                const rosIndicator = document.getElementById('rosStatus');
                const rosStatusText = document.getElementById('rosStatusText');
                rosIndicator.classList.remove('connected');
                rosStatusText.textContent = 'Error';
            }
        }

        // Update uptime
        let startTime = Date.now();
        function updateUptime() {
            const elapsed = Date.now() - startTime;
            const hours = Math.floor(elapsed / 3600000);
            const minutes = Math.floor((elapsed % 3600000) / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            
            document.getElementById('uptime').textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('settingsModal');
            if (event.target == modal) {
                closeSettings();
            }
        }

        // Initialize on page load
        window.onload = function() {
            // Check if this is first time or if settings are missing
            if (!localStorage.getItem('robotIP')) {
                openSettings();
            }
            
            checkSystemStatus();
            setInterval(checkSystemStatus, 5000);
            setInterval(updateUptime, 1000);
        }
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/lidar_visualization.html
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lidar Sensor - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-height: calc(100vh - 200px);
        }

        .visualization-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 1.5em;
            color: #00ff88;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #0a0a0a;
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .control-button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .control-button.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }

        .control-button.danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .info-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-item {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.3em;
            font-weight: 500;
            color: #00ff88;
        }

        .movement-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 200px;
            margin: 20px auto;
        }

        .move-btn {
            padding: 15px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-size: 1.5em;
            transition: all 0.2s ease;
        }

        .move-btn:hover {
            background: #3a3a3a;
            transform: scale(1.1);
        }

        .move-btn:active {
            background: #00ff88;
            transform: scale(0.95);
        }

        .move-btn:nth-child(2) { grid-column: 2; }
        .move-btn:nth-child(4) { grid-column: 1; }
        .move-btn:nth-child(5) { grid-column: 2; }
        .move-btn:nth-child(6) { grid-column: 3; }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>Lidar Sensor Visualization</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span>Lidar Status:</span>
            <div class="status-indicator" id="lidarStatus"></div>
            <span id="lidarStatusText">Disconnected</span>
        </div>
        <div class="status-item">
            <span>Data Rate:</span>
            <span id="dataRate">0 Hz</span>
        </div>
        <div class="status-item">
            <span>Points:</span>
            <span id="pointCount">0</span>
        </div>
    </div>

    <div class="main-container">
        <!-- Polar View -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Live Scan - Polar View</h2>
                <span id="polarFPS">0 FPS</span>
            </div>
            <div class="canvas-container">
                <canvas id="polarCanvas"></canvas>
            </div>
        </div>

        <!-- Occupancy Map -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Occupancy Map</h2>
                <span id="mapFPS">0 FPS</span>
            </div>
            <div class="canvas-container">
                <canvas id="mapCanvas"></canvas>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="control-button" id="startBtn" onclick="startLidar()">Start Scan</button>
        <button class="control-button danger" id="stopBtn" onclick="stopLidar()" disabled>Stop Scan</button>
        <button class="control-button" onclick="clearMap()">Clear Map</button>
        <button class="control-button" onclick="saveMap()">Save Map</button>
        <button class="control-button" id="followRobotBtn" onclick="toggleFollowRobot()">Follow Robot</button>
        <button class="control-button" onclick="resetView()">Reset View</button>
    </div>

    <div class="info-panel">
        <h3 style="color: #00ff88; margin-bottom: 15px;">Scan Information</h3>
        <div class="info-grid">
            <div class="info-item">
                <div class="info-label">Min Distance</div>
                <div class="info-value" id="minDistance">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Min Angle</div>
                <div class="info-value" id="minAngle">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Obstacles</div>
                <div class="info-value" id="obstacleCount">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">Safe Directions</div>
                <div class="info-value" id="safeDirections" style="font-size: 1em;">-</div>
            </div>
        </div>
    </div>

    <div class="controls">
        <h3 style="color: #00ff88; margin-bottom: 15px; text-align: center;">Robot Movement (Simulation)</h3>
        <div class="movement-controls">
            <button class="move-btn" onclick="moveRobot('forward')">↑</button>
            <button class="move-btn" onclick="moveRobot('left')">←</button>
            <button class="move-btn" onclick="moveRobot('stop')">●</button>
            <button class="move-btn" onclick="moveRobot('right')">→</button>
            <button class="move-btn" onclick="moveRobot('backward')">↓</button>
        </div>
    </div>

    <script>
        // WebSocket connection
        const socket = io();
        
        // Canvas contexts
        const polarCanvas = document.getElementById('polarCanvas');
        const polarCtx = polarCanvas.getContext('2d');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');
        
        // State
        let scanning = false;
        let followRobot = true;
        let latestScanData = null;
        
        // Map parameters
        const MAP_SIZE = 100;  // 10m x 10m with 10cm resolution
        const MAP_RESOLUTION = 0.1;  // meters per pixel
        const occupancyMap = new Array(MAP_SIZE * MAP_SIZE).fill(0.5);  // Unknown = 0.5
        
        // Robot state
        let robotX = MAP_SIZE / 2;
        let robotY = MAP_SIZE / 2;
        let robotTheta = 0;
        const robotPath = [];
        
        // Performance monitoring
        let polarFPS = 0;
        let mapFPS = 0;
        let lastPolarUpdate = Date.now();
        let lastMapUpdate = Date.now();
        let polarFrameCount = 0;
        let mapFrameCount = 0;
        let dataRate = 0;
        let lastDataTime = Date.now();
        let dataCount = 0;
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
        });
        
        socket.on('lidar_data', (data) => {
            latestScanData = data;
            updateVisualization(data);
            
            // Update data rate
            dataCount++;
            const now = Date.now();
            if (now - lastDataTime > 1000) {
                dataRate = dataCount;
                dataCount = 0;
                lastDataTime = now;
                document.getElementById('dataRate').textContent = `${dataRate} Hz`;
            }
        });
        
        // Resize canvases
        function resizeCanvases() {
            const containers = document.querySelectorAll('.canvas-container');
            containers.forEach((container, index) => {
                const canvas = container.querySelector('canvas');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            });
        }
        
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();
        
        // Start/Stop lidar
        async function startLidar() {
            try {
                const response = await fetch('/api/lidar/subscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    scanning = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('lidarStatus').classList.add('connected');
                    document.getElementById('lidarStatusText').textContent = 'Connected';
                }
            } catch (error) {
                console.error('Failed to start lidar:', error);
            }
        }
        
        async function stopLidar() {
            try {
                const response = await fetch('/api/lidar/unsubscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    scanning = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                    document.getElementById('lidarStatus').classList.remove('connected');
                    document.getElementById('lidarStatusText').textContent = 'Disconnected';
                }
            } catch (error) {
                console.error('Failed to stop lidar:', error);
            }
        }
        
        // Visualization functions
        function updateVisualization(scanData) {
            // Update info panel
            document.getElementById('minDistance').textContent = `${scanData.min_distance.toFixed(2)}m`;
            document.getElementById('minAngle').textContent = `${scanData.min_angle_deg.toFixed(1)}°`;
            document.getElementById('obstacleCount').textContent = scanData.obstacle_count;
            document.getElementById('safeDirections').textContent = scanData.safe_directions.join(', ') || 'None';
            document.getElementById('pointCount').textContent = scanData.point_count;
            
            // Draw polar view
            drawPolarView(scanData);
            
            // Update occupancy map
            updateOccupancyMap(scanData);
            drawMapView();
        }
        
        function drawPolarView(scanData) {
            const width = polarCanvas.width;
            const height = polarCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) / 2 - 20;
            
            // Clear canvas
            polarCtx.fillStyle = '#0a0a0a';
            polarCtx.fillRect(0, 0, width, height);
            
            // Draw grid
            polarCtx.strokeStyle = '#333';
            polarCtx.lineWidth = 1;
            
            // Concentric circles
            for (let r = 1; r <= 4; r++) {
                polarCtx.beginPath();
                polarCtx.arc(centerX, centerY, (r / 4) * maxRadius, 0, 2 * Math.PI);
                polarCtx.stroke();
                
                // Distance labels
                polarCtx.fillStyle = '#666';
                polarCtx.font = '12px Arial';
                polarCtx.fillText(`${r}m`, centerX + 5, centerY - (r / 4) * maxRadius + 5);
            }
            
            // Radial lines
            for (let angle = 0; angle < 360; angle += 30) {
                const rad = angle * Math.PI / 180;
                polarCtx.beginPath();
                polarCtx.moveTo(centerX, centerY);
                polarCtx.lineTo(
                    centerX + maxRadius * Math.cos(rad),
                    centerY - maxRadius * Math.sin(rad)
                );
                polarCtx.stroke();
            }
            
            // Draw scan points
            if (scanData.points) {
                polarCtx.fillStyle = '#00ff88';
                scanData.points.forEach(point => {
                    if (point.r < 4.0) {  // Only show points within 4m
                        const x = centerX + (point.r / 4) * maxRadius * Math.cos(point.theta);
                        const y = centerY - (point.r / 4) * maxRadius * Math.sin(point.theta);
                        
                        polarCtx.beginPath();
                        polarCtx.arc(x, y, 2, 0, 2 * Math.PI);
                        polarCtx.fill();
                    }
                });
            }
            
            // Draw obstacles
            polarCtx.fillStyle = '#ff4444';
            scanData.obstacles.forEach(obstacle => {
                const x = centerX + (obstacle.distance / 4) * maxRadius * Math.cos(obstacle.angle);
                const y = centerY - (obstacle.distance / 4) * maxRadius * Math.sin(obstacle.angle);
                
                polarCtx.beginPath();
                polarCtx.arc(x, y, 4, 0, 2 * Math.PI);
                polarCtx.fill();
            });
            
            // Draw robot center
            polarCtx.fillStyle = '#00aaff';
            polarCtx.beginPath();
            polarCtx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            polarCtx.fill();
            
            // Update FPS
            polarFrameCount++;
            const now = Date.now();
            if (now - lastPolarUpdate > 1000) {
                polarFPS = polarFrameCount;
                polarFrameCount = 0;
                lastPolarUpdate = now;
                document.getElementById('polarFPS').textContent = `${polarFPS} FPS`;
            }
        }
        
        function updateOccupancyMap(scanData) {
            if (!scanData.points) return;
            
            // Update map with new scan data
            scanData.points.forEach(point => {
                if (point.r > 0 && point.r < 10) {
                    // Ray tracing - mark free space
                    const steps = Math.floor(point.r / MAP_RESOLUTION);
                    for (let step = 0; step < steps; step++) {
                        const r = step * MAP_RESOLUTION;
                        const x = Math.floor(robotX + r * Math.cos(point.theta + robotTheta) / MAP_RESOLUTION);
                        const y = Math.floor(robotY + r * Math.sin(point.theta + robotTheta) / MAP_RESOLUTION);
                        
                        if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
                            const idx = y * MAP_SIZE + x;
                            occupancyMap[idx] = Math.max(0.0, occupancyMap[idx] - 0.02);
                        }
                    }
                    
                    // Mark obstacle
                    if (point.r < 4.0) {
                        const obsX = Math.floor(robotX + point.r * Math.cos(point.theta + robotTheta) / MAP_RESOLUTION);
                        const obsY = Math.floor(robotY + point.r * Math.sin(point.theta + robotTheta) / MAP_RESOLUTION);
                        
                        if (obsX >= 0 && obsX < MAP_SIZE && obsY >= 0 && obsY < MAP_SIZE) {
                            const idx = obsY * MAP_SIZE + obsX;
                            occupancyMap[idx] = Math.min(1.0, occupancyMap[idx] + 0.1);
                        }
                    }
                }
            });
        }
        
        function drawMapView() {
            const width = mapCanvas.width;
            const height = mapCanvas.height;
            const scale = Math.min(width, height) / (MAP_SIZE * MAP_RESOLUTION);
            
            // Clear canvas
            mapCtx.fillStyle = '#0a0a0a';
            mapCtx.fillRect(0, 0, width, height);
            
            // Calculate view offset
            let offsetX = 0;
            let offsetY = 0;
            if (followRobot) {
                offsetX = width / 2 - robotX * MAP_RESOLUTION * scale;
                offsetY = height / 2 - robotY * MAP_RESOLUTION * scale;
            }
            
            mapCtx.save();
            mapCtx.translate(offsetX, offsetY);
            
            // Draw occupancy map
            const imageData = mapCtx.createImageData(MAP_SIZE, MAP_SIZE);
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const idx = y * MAP_SIZE + x;
                    const value = occupancyMap[idx];
                    const pixelIdx = (y * MAP_SIZE + x) * 4;
                    
                    if (value < 0.5) {
                        // Free space - green tint
                        imageData.data[pixelIdx] = 0;
                        imageData.data[pixelIdx + 1] = Math.floor(255 * (0.5 - value) * 2);
                        imageData.data[pixelIdx + 2] = 0;
                    } else if (value > 0.5) {
                        // Obstacle - red tint
                        imageData.data[pixelIdx] = Math.floor(255 * (value - 0.5) * 2);
                        imageData.data[pixelIdx + 1] = 0;
                        imageData.data[pixelIdx + 2] = 0;
                    } else {
                        // Unknown - gray
                        imageData.data[pixelIdx] = 64;
                        imageData.data[pixelIdx + 1] = 64;
                        imageData.data[pixelIdx + 2] = 64;
                    }
                    imageData.data[pixelIdx + 3] = 255;
                }
            }
            
            // Scale and draw map
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = MAP_SIZE;
            tempCanvas.height = MAP_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);
            
            mapCtx.imageSmoothingEnabled = false;
            mapCtx.drawImage(tempCanvas, 0, 0, MAP_SIZE * MAP_RESOLUTION * scale, MAP_SIZE * MAP_RESOLUTION * scale);
            
            // Draw robot path
            if (robotPath.length > 1) {
                mapCtx.strokeStyle = '#00ff8866';
                mapCtx.lineWidth = 2;
                mapCtx.beginPath();
                mapCtx.moveTo(robotPath[0].x * MAP_RESOLUTION * scale, robotPath[0].y * MAP_RESOLUTION * scale);
                for (let i = 1; i < robotPath.length; i++) {
                    mapCtx.lineTo(robotPath[i].x * MAP_RESOLUTION * scale, robotPath[i].y * MAP_RESOLUTION * scale);
                }
                mapCtx.stroke();
            }
            
            // Draw robot
            const robotScreenX = robotX * MAP_RESOLUTION * scale;
            const robotScreenY = robotY * MAP_RESOLUTION * scale;
            
            // Robot body
            mapCtx.fillStyle = '#00aaff';
            mapCtx.beginPath();
            mapCtx.arc(robotScreenX, robotScreenY, 8, 0, 2 * Math.PI);
            mapCtx.fill();
            
            // Robot direction
            mapCtx.strokeStyle = '#00aaff';
            mapCtx.lineWidth = 3;
            mapCtx.beginPath();
            mapCtx.moveTo(robotScreenX, robotScreenY);
            mapCtx.lineTo(
                robotScreenX + 20 * Math.cos(robotTheta),
                robotScreenY + 20 * Math.sin(robotTheta)
            );
            mapCtx.stroke();
            
            mapCtx.restore();
            
            // Draw scale
            mapCtx.fillStyle = '#fff';
            mapCtx.font = '12px Arial';
            mapCtx.fillText('1m', 10, height - 10);
            mapCtx.strokeStyle = '#fff';
            mapCtx.lineWidth = 2;
            mapCtx.beginPath();
            mapCtx.moveTo(10, height - 20);
            mapCtx.lineTo(10 + scale, height - 20);
            mapCtx.stroke();
            
            // Update FPS
            mapFrameCount++;
            const now = Date.now();
            if (now - lastMapUpdate > 1000) {
                mapFPS = mapFrameCount;
                mapFrameCount = 0;
                lastMapUpdate = now;
                document.getElementById('mapFPS').textContent = `${mapFPS} FPS`;
            }
        }
        
        // Control functions
        function clearMap() {
            occupancyMap.fill(0.5);
            robotPath.length = 0;
            robotX = MAP_SIZE / 2;
            robotY = MAP_SIZE / 2;
            robotTheta = 0;
        }
        
        function saveMap() {
            // Convert map to image and download
            const link = document.createElement('a');
            link.download = `lidar_map_${new Date().toISOString()}.png`;
            link.href = mapCanvas.toDataURL();
            link.click();
        }
        
        function toggleFollowRobot() {
            followRobot = !followRobot;
            document.getElementById('followRobotBtn').classList.toggle('active', followRobot);
        }
        
        function resetView() {
            followRobot = true;
            document.getElementById('followRobotBtn').classList.add('active');
        }
        
        // Robot movement (simulation)
        function moveRobot(direction) {
            const moveSpeed = 0.2;  // meters
            const turnSpeed = 0.1;  // radians
            
            switch (direction) {
                case 'forward':
                    robotX += moveSpeed * Math.cos(robotTheta) / MAP_RESOLUTION;
                    robotY += moveSpeed * Math.sin(robotTheta) / MAP_RESOLUTION;
                    break;
                case 'backward':
                    robotX -= moveSpeed * Math.cos(robotTheta) / MAP_RESOLUTION;
                    robotY -= moveSpeed * Math.sin(robotTheta) / MAP_RESOLUTION;
                    break;
                case 'left':
                    robotTheta -= turnSpeed;
                    break;
                case 'right':
                    robotTheta += turnSpeed;
                    break;
            }
            
            // Keep robot in bounds
            robotX = Math.max(0, Math.min(MAP_SIZE - 1, robotX));
            robotY = Math.max(0, Math.min(MAP_SIZE - 1, robotY));
            
            // Add to path
            robotPath.push({ x: robotX, y: robotY });
            if (robotPath.length > 1000) {
                robotPath.shift();
            }
            
            // Redraw if we have scan data
            if (latestScanData) {
                updateVisualization(latestScanData);
            }
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    moveRobot('forward');
                    break;
                case 'ArrowDown':
                case 's':
                    moveRobot('backward');
                    break;
                case 'ArrowLeft':
                case 'a':
                    moveRobot('left');
                    break;
                case 'ArrowRight':
                case 'd':
                    moveRobot('right');
                    break;
            }
        });
        
        // Initialize
        toggleFollowRobot();  // Start with follow robot enabled
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/motor_control.html
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motor Control - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 40px 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 30px;
            margin-bottom: 40px;
        }

        .motor-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 350px;
        }

        .motor-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
        }

        .motor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .motor-title {
            font-size: 1.5em;
            font-weight: 500;
            color: #00aaff;
        }

        .motor-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            background: #333;
            color: #888;
            transition: all 0.3s ease;
        }

        .motor-status.active {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .direction-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .direction-btn {
            padding: 12px 8px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .direction-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .direction-btn.active {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .direction-btn.brake.active {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            box-shadow: 0 5px 20px rgba(255, 68, 68, 0.4);
        }

        .speed-control {
            margin-top: auto;
        }

        /* Speed marks container */
        .speed-marks {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            padding: 0 12px;
        }

        .speed-mark {
            font-size: 0.75em;
            color: #666;
            text-align: center;
            position: relative;
        }

        .speed-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: #aaa;
        }

        .speed-value {
            font-size: 2em;
            font-weight: 700;
            color: #00ff88;
            min-width: 80px;
            text-align: right;
        }

        .speed-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            transition: all 0.3s ease;
        }

        /* Add markers for the 5 positions */
        .speed-slider {
            background-image: linear-gradient(to right, 
                #444 0%, #444 1px,
                transparent 1px, transparent 24.5%,
                #444 24.5%, #444 25.5%,
                transparent 25.5%, transparent 49.5%,
                #444 49.5%, #444 50.5%,
                transparent 50.5%, transparent 74.5%,
                #444 74.5%, #444 75.5%,
                transparent 75.5%, transparent 99%,
                #444 99%, #444 100%
            );
            background-size: 100% 100%;
            background-repeat: no-repeat;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .speed-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.7);
        }

        .speed-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .emergency-stop {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff0000, #cc0000);
            border: 3px solid #ff4444;
            color: white;
            font-size: 1.2em;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(255, 0, 0, 0.5);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 1000;
        }

        .emergency-stop:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(255, 0, 0, 0.7);
        }

        .emergency-stop:active {
            transform: scale(0.95);
        }

        .log-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            border: 1px solid #333;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            background: #252525;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #aaa;
            border-left: 3px solid #444;
        }

        .log-entry.error {
            border-left-color: #ff4444;
            color: #ff6666;
        }

        .log-entry.success {
            border-left-color: #00ff88;
            color: #00ff88;
        }

        /* Responsive design */
        @media (max-width: 1600px) {
            .controls-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 900px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .emergency-stop {
                width: 80px;
                height: 80px;
                font-size: 1em;
                bottom: 20px;
                right: 20px;
            }

            .direction-controls {
                grid-template-columns: 1fr;
                gap: 8px;
            }
        }

        /* For ultra-wide displays */
        @media (min-width: 2000px) {
            .main-container {
                max-width: 1900px;
            }
            
            .motor-card {
                padding: 35px;
                min-height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ROS 2 Motor Control Panel</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <span>Connection Status:</span>
        <div class="status-indicator" id="connectionStatus"></div>
        <span id="statusText">Disconnected</span>
    </div>

    <div class="main-container">
        <div class="controls-grid">
            <!-- Left Motors -->
            <div class="motor-card" data-motor="0">
                <div class="motor-header">
                    <h2 class="motor-title">Left Motors</h2>
                    <span class="motor-status">IDLE</span>
                </div>
                <div class="direction-controls">
                    <button class="direction-btn" data-direction="forward">Forward</button>
                    <button class="direction-btn" data-direction="backward">Backward</button>
                    <button class="direction-btn brake" data-direction="brake">Brake</button>
                </div>
                <div class="speed-control">
                    <div class="speed-label">
                        <span>Speed Control</span>
                        <span class="speed-value">0%</span>
                    </div>
                    <input type="range" class="speed-slider" min="0" max="100" value="0" step="25">
                    <div class="speed-marks">
                        <span class="speed-mark">0%</span>
                        <span class="speed-mark">25%</span>
                        <span class="speed-mark">50%</span>
                        <span class="speed-mark">75%</span>
                        <span class="speed-mark">100%</span>
                    </div>
                </div>
            </div>

            <!-- Right Motors -->
            <div class="motor-card" data-motor="1">
                <div class="motor-header">
                    <h2 class="motor-title">Right Motors</h2>
                    <span class="motor-status">IDLE</span>
                </div>
                <div class="direction-controls">
                    <button class="direction-btn" data-direction="forward">Forward</button>
                    <button class="direction-btn" data-direction="backward">Backward</button>
                    <button class="direction-btn brake" data-direction="brake">Brake</button>
                </div>
                <div class="speed-control">
                    <div class="speed-label">
                        <span>Speed Control</span>
                        <span class="speed-value">0%</span>
                    </div>
                    <input type="range" class="speed-slider" min="0" max="100" value="0" step="25">
                    <div class="speed-marks">
                        <span class="speed-mark">0%</span>
                        <span class="speed-mark">25%</span>
                        <span class="speed-mark">50%</span>
                        <span class="speed-mark">75%</span>
                        <span class="speed-mark">100%</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <h3 style="margin-bottom: 10px; color: #888;">Activity Log</h3>
            <div id="logContainer"></div>
        </div>
    </div>

    <button class="emergency-stop" id="emergencyStop">STOP<br>ALL</button>

    <script>
        // Motor control state
        const motorStates = {
            0: { direction: 'brake', speed: 0 },  // Left motors
            1: { direction: 'brake', speed: 0 }   // Right motors
        };

        // Command throttling
        let commandQueue = [];
        let isProcessing = false;
        const COMMAND_DELAY = 100; // 100ms between commands

        // Add log entry
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // Keep only last 10 entries
            while (logContainer.children.length > 10) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Process command queue
        async function processCommandQueue() {
            if (isProcessing || commandQueue.length === 0) return;
            
            isProcessing = true;
            const command = commandQueue.shift();
            
            try {
                const response = await fetch(`/api/motor/${command.motorId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        direction: command.direction,
                        speed: command.speed
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    addLog(`Motor ${command.motorId}: ${command.direction} at ${command.speed}%`, 'success');
                } else {
                    addLog(`Motor ${command.motorId} error: ${data.error}`, 'error');
                }
            } catch (error) {
                addLog(`Motor ${command.motorId} error: ${error.message}`, 'error');
            }
            
            // Wait before processing next command
            setTimeout(() => {
                isProcessing = false;
                processCommandQueue();
            }, COMMAND_DELAY);
        }

        // Queue motor command
        function queueMotorCommand(motorId, direction, speed) {
            // Remove any pending commands for this motor
            commandQueue = commandQueue.filter(cmd => cmd.motorId !== motorId);
            
            // Add new command
            commandQueue.push({ motorId, direction, speed });
            
            // Start processing
            processCommandQueue();
        }

        // Send motor command with direction change protection
        async function sendMotorCommand(motorId, direction, speed) {
            const lastDir = motorStates[motorId].direction;
            
            // If changing from forward to backward or vice versa, insert brake command
            if ((lastDir === 'forward' && direction === 'backward') ||
                (lastDir === 'backward' && direction === 'forward')) {
                // Queue brake first
                queueMotorCommand(motorId, 'brake', 0);
                // Then queue the new direction after a delay
                setTimeout(() => {
                    queueMotorCommand(motorId, direction, speed);
                }, 150);
            } else {
                // Direct command
                queueMotorCommand(motorId, direction, speed);
            }
            
            // Update state
            motorStates[motorId].direction = direction;
            motorStates[motorId].speed = speed;
        }

        // Check connection status
        async function checkConnection() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                const indicator = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                
                if (data.connected) {
                    indicator.classList.add('connected');
                    statusText.textContent = 'Connected';
                } else {
                    indicator.classList.remove('connected');
                    statusText.textContent = 'Disconnected';
                }
            } catch (error) {
                const indicator = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                indicator.classList.remove('connected');
                statusText.textContent = 'Error';
            }
        }

        // Update motor UI
        function updateMotorUI(motorId) {
            const motorCard = document.querySelector(`[data-motor="${motorId}"]`);
            const state = motorStates[motorId];
            
            // Update direction buttons
            const directionBtns = motorCard.querySelectorAll('.direction-btn');
            directionBtns.forEach(btn => {
                if (btn.dataset.direction === state.direction) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Update status
            const status = motorCard.querySelector('.motor-status');
            if (state.direction === 'brake') {
                status.textContent = 'BRAKE';
                status.classList.remove('active');
            } else {
                status.textContent = state.direction.toUpperCase();
                status.classList.add('active');
            }
            
            // Update speed display
            const speedValue = motorCard.querySelector('.speed-value');
            speedValue.textContent = `${state.speed}%`;
            
            // Update slider
            const slider = motorCard.querySelector('.speed-slider');
            slider.value = state.speed;
            
            // Update slider background to show progress
            const percentage = state.speed / 100;
            slider.style.background = `linear-gradient(to right, #00ff88 ${percentage * 100}%, #2a2a2a ${percentage * 100}%)`;
        }

        // Initialize motor controls
        document.querySelectorAll('.motor-card').forEach(motorCard => {
            const motorId = parseInt(motorCard.dataset.motor);
            
            // Direction buttons
            motorCard.querySelectorAll('.direction-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const direction = btn.dataset.direction;
                    motorStates[motorId].direction = direction;
                    
                    // If brake, set speed to 0
                    if (direction === 'brake') {
                        motorStates[motorId].speed = 0;
                    }
                    
                    updateMotorUI(motorId);
                    await sendMotorCommand(motorId, direction, motorStates[motorId].speed);
                });
            });
            
            // Speed slider with throttling
            const slider = motorCard.querySelector('.speed-slider');
            let sliderTimeout;
            
            slider.addEventListener('input', (e) => {
                // IMPORTANT: Invert the slider value
                // Slider shows 0-100 left to right, but we need to send inverted values
                const sliderValue = parseInt(e.target.value);
                motorStates[motorId].speed = sliderValue;
                
                // Update UI immediately
                updateMotorUI(motorId);
                
                // Clear any existing timeout
                clearTimeout(sliderTimeout);
                
                // Only send command on discrete values (0, 25, 50, 75, 100)
                if ([0, 25, 50, 75, 100].includes(sliderValue)) {
                    // Send command immediately for discrete values
                    if (motorStates[motorId].direction !== 'brake') {
                        sendMotorCommand(motorId, motorStates[motorId].direction, sliderValue);
                    }
                }
            });
            
            // Also handle change event for when user releases the slider
            slider.addEventListener('change', (e) => {
                const sliderValue = parseInt(e.target.value);
                if (motorStates[motorId].direction !== 'brake') {
                    sendMotorCommand(motorId, motorStates[motorId].direction, sliderValue);
                }
            });
        });

        // Emergency stop button
        document.getElementById('emergencyStop').addEventListener('click', async () => {
            addLog('EMERGENCY STOP ACTIVATED!', 'error');
            
            // Clear command queue
            commandQueue = [];
            
            try {
                const response = await fetch('/api/motors/stop', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Reset only 2 motors
                    for (let i = 0; i < 2; i++) {
                        motorStates[i] = { direction: 'brake', speed: 0 };
                        updateMotorUI(i);
                    }
                    addLog('All motors stopped', 'success');
                } else {
                    addLog('Emergency stop failed!', 'error');
                }
            } catch (error) {
                addLog(`Emergency stop error: ${error.message}`, 'error');
            }
        });

        // Initial setup
        checkConnection();
        setInterval(checkConnection, 5000); // Check connection every 5 seconds
        
        // Initialize UI
        for (let i = 0; i < 2; i++) {
            updateMotorUI(i);
        }
        
        addLog('Motor control panel initialized', 'success');
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: requirements.txt
================================================================================
Flask==3.0.0
Flask-CORS==4.0.0
Flask-SocketIO==5.3.5
websocket-client==1.7.0
watchdog==3.0.0
numpy==1.26.2
python-socketio==5.10.0
================================================================================


================================================================================
FILE: run.py
================================================================================
#!/usr/bin/env python3
"""
Main entry point for the ROS 2 Motor Control application
Run this file to start the Flask backend server
"""

import sys
from pathlib import Path

# Add the current directory to Python path
sys.path.insert(0, str(Path(__file__).parent))

from backend.host_backend import main

if __name__ == '__main__':
    main()
================================================================================

