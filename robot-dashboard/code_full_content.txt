================================================================================
FULL CODE CONTENT DUMP
Directory: /Users/yang/Library/CloudStorage/OneDrive-Personal/UCL/Year 4 UCL/MECH0073/GitHub_Repositories/Fire-fighting-Robot/robot-dashboard
Time: 2025-06-10 22:44:24
================================================================================

DIRECTORY STRUCTURE:
----------------------------------------
├── backend/
│   ├── motors/
│   │   ├── __init__.py (0.0 B)
│   │   ├── actuator_control.py (7.5 KB)
│   │   ├── motor_controller.py (6.3 KB)
│   │   ├── motor_routes.py (4.1 KB)
│   │   └── servo_control.py (6.7 KB)
│   ├── sensors/
│   │   ├── __init__.py (390.0 B)
│   │   ├── lidar.py (8.0 KB)
│   │   ├── system_monitor.py (7.5 KB)
│   │   └── thermal_camera.py (7.7 KB)
│   ├── __init__.py (285.0 B)
│   ├── automation.py (16.8 KB)
│   ├── config_manager.py (3.3 KB)
│   ├── host_backend.py (21.5 KB)
│   └── ros_bridge.py (16.9 KB)
├── frontend/
│   └── templates/
│       ├── aiming_system.html (41.6 KB)
│       ├── dashboard_home.html (27.7 KB)
│       ├── lidar_visualization.html (26.8 KB)
│       ├── motor_control.html (23.3 KB)
│       └── thermal_camera.html (20.0 KB)
├── ui/
├── code_full_content.txt (254.8 KB)
├── code_scan_summary.txt (1.4 KB)
├── code_scanner.py (12.9 KB)
├── requirements.txt (130.0 B)
└── run.py (341.0 B)

================================================================================
STATISTICS:
----------------------------------------
Total code files: 23
Total size: 503.0 KB
Total lines: 14,914

FILES BY CATEGORY:
----------------------------------------
Documentation: 3 files, 256.4 KB, 7,575 lines
Python: 15 files, 107.2 KB, 3,200 lines
Web: 5 files, 139.4 KB, 4,139 lines

================================================================================
FILE CONTENTS:
================================================================================

================================================================================
FILE: code_full_content.txt
Category: Documentation | Size: 254.8 KB | Lines: 7533
================================================================================

================================================================================


================================================================================
FILE: code_scan_summary.txt
Category: Documentation | Size: 1.4 KB | Lines: 35
================================================================================
Code Scan Summary - 2025-06-10 22:44:24
Directory: /Users/yang/Library/CloudStorage/OneDrive-Personal/UCL/Year 4 UCL/MECH0073/GitHub_Repositories/Fire-fighting-Robot/robot-dashboard
Total files: 23
Total size: 503.0 KB
Total lines: 14,914

Files by category:
  Documentation: 3 files
  Python: 15 files
  Web: 5 files

All code files:
  code_full_content.txt (Documentation, 254.8 KB)
  code_scan_summary.txt (Documentation, 1.4 KB)
  requirements.txt (Documentation, 130.0 B)
  backend/__init__.py (Python, 285.0 B)
  backend/automation.py (Python, 16.8 KB)
  backend/config_manager.py (Python, 3.3 KB)
  backend/host_backend.py (Python, 21.5 KB)
  backend/motors/__init__.py (Python, 0.0 B)
  backend/motors/actuator_control.py (Python, 7.5 KB)
  backend/motors/motor_controller.py (Python, 6.3 KB)
  backend/motors/motor_routes.py (Python, 4.1 KB)
  backend/motors/servo_control.py (Python, 6.7 KB)
  backend/ros_bridge.py (Python, 16.9 KB)
  backend/sensors/__init__.py (Python, 390.0 B)
  backend/sensors/lidar.py (Python, 8.0 KB)
  backend/sensors/system_monitor.py (Python, 7.5 KB)
  backend/sensors/thermal_camera.py (Python, 7.7 KB)
  run.py (Python, 341.0 B)
  frontend/templates/aiming_system.html (Web, 41.6 KB)
  frontend/templates/dashboard_home.html (Web, 27.7 KB)
  frontend/templates/lidar_visualization.html (Web, 26.8 KB)
  frontend/templates/motor_control.html (Web, 23.3 KB)
  frontend/templates/thermal_camera.html (Web, 20.0 KB)

================================================================================


================================================================================
FILE: requirements.txt
Category: Documentation | Size: 130.0 B | Lines: 7
================================================================================
Flask==3.0.0
Flask-CORS==4.0.0
Flask-SocketIO==5.3.5
websocket-client==1.7.0
watchdog==3.0.0
numpy==1.26.2
python-socketio==5.10.0
================================================================================


================================================================================
FILE: backend/__init__.py
Category: Python | Size: 285.0 B | Lines: 14
================================================================================
"""
Backend package for ROS 2 Motor Control
"""

from .ros_bridge import ROSBridgeConnection, MotorController, get_ros_bridge, get_motor_controller

__all__ = [
    'ROSBridgeConnection',
    'MotorController', 
    'get_ros_bridge',
    'get_motor_controller'
]

__version__ = '1.0.0'
================================================================================


================================================================================
FILE: backend/automation.py
Category: Python | Size: 16.8 KB | Lines: 444
================================================================================
#!/usr/bin/env python3
"""
Automation module for robot mapping and pathfinding
Implements wall-following algorithm with differential drive calculations
"""

import logging
import threading
import time
import numpy as np
from typing import Dict, List, Tuple, Optional, Any
from enum import Enum
from collections import deque
import math

logger = logging.getLogger(__name__)

class RobotState(Enum):
    """Robot states for mapping"""
    IDLE = "idle"
    MAPPING = "mapping"
    TURNING = "turning"
    MOVING_FORWARD = "moving_forward"
    OBSTACLE_AVOIDANCE = "obstacle_avoidance"
    EMERGENCY_STOP = "emergency_stop"

class TurnDirection(Enum):
    """Turn direction preference"""
    LEFT = "left"
    RIGHT = "right"

class AutoMapper:
    """Autonomous mapping using wall-following algorithm"""
    
    def __init__(self, motor_controller, lidar_sensor):
        """
        Initialize the auto mapper
        
        Args:
            motor_controller: Motor controller instance
            lidar_sensor: Lidar sensor instance
        """
        self.motor_controller = motor_controller
        self.lidar_sensor = lidar_sensor
        
        # Robot dimensions (in mm)
        self.robot_length = 500  # mm
        self.robot_width = 450   # mm
        self.wheelbase = 400     # Approximate wheelbase (mm)
        
        # Safety parameters
        self.safety_distance = 800  # mm (stop if obstacle closer than this)
        self.wall_follow_distance = 1000  # mm (ideal distance from wall)
        self.wall_follow_tolerance = 200  # mm (acceptable deviation)
        
        # Speed parameters (0-100%)
        self.base_speed = 85  # Normal forward speed
        self.turn_speed = 75  # Speed during turns
        self.slow_speed = 75  # Slow speed for careful movement
        
        # Control parameters
        self.turn_direction = TurnDirection.RIGHT  # Prefer right turns
        self.command_delay = 0.2  # Delay between commands (seconds)
        self.sensor_delay = 0.1   # Account for sensor delay
        
        # State management
        self.state = RobotState.IDLE
        self.mapping_active = False
        self.emergency_stop = False
        self._mapping_thread = None
        self._state_lock = threading.Lock()
        
        # Odometry estimation (simple dead reckoning)
        self.robot_x = 0.0  # mm
        self.robot_y = 0.0  # mm
        self.robot_theta = 0.0  # radians
        self.last_odometry_update = time.time()
        
        # Mapping data
        self.visited_cells = set()  # Grid cells visited
        self.wall_map = {}  # Detected walls
        self.mapping_start_time = None
        
        # PID controller for wall following
        self.kp = 0.5  # Proportional gain
        self.ki = 0.1  # Integral gain
        self.kd = 0.2  # Derivative gain
        self.integral_error = 0.0
        self.last_error = 0.0
        
        logger.info("AutoMapper initialized")
    
    def start_mapping(self) -> bool:
        """Start autonomous mapping"""
        with self._state_lock:
            if self.mapping_active:
                logger.warning("Mapping already active")
                return False
            
            self.mapping_active = True
            self.emergency_stop = False
            self.state = RobotState.IDLE
            self.mapping_start_time = time.time()
            
            # Reset odometry
            self.robot_x = 0.0
            self.robot_y = 0.0
            self.robot_theta = 0.0
            
            # Clear previous mapping data
            self.visited_cells.clear()
            self.wall_map.clear()
            
            # Start mapping thread
            self._mapping_thread = threading.Thread(target=self._mapping_loop)
            self._mapping_thread.daemon = True
            self._mapping_thread.start()
            
            logger.info("Started autonomous mapping")
            return True
    
    def stop_mapping(self) -> bool:
        """Stop autonomous mapping"""
        with self._state_lock:
            if not self.mapping_active:
                return False
            
            self.mapping_active = False
            self.emergency_stop = True
            
        # Stop all motors
        self.motor_controller.stop_all_motors()
        
        # Wait for thread to finish
        if self._mapping_thread:
            self._mapping_thread.join(timeout=5.0)
        
        logger.info("Stopped autonomous mapping")
        return True
    
    def get_status(self) -> Dict[str, Any]:
        """Get current mapping status"""
        with self._state_lock:
            duration = 0
            if self.mapping_start_time:
                duration = time.time() - self.mapping_start_time
            
            return {
                "active": self.mapping_active,
                "state": self.state.value,
                "emergency_stop": self.emergency_stop,
                "robot_position": {
                    "x": round(self.robot_x),
                    "y": round(self.robot_y),
                    "theta": round(math.degrees(self.robot_theta), 1)
                },
                "visited_cells": len(self.visited_cells),
                "walls_detected": len(self.wall_map),
                "duration": round(duration, 1)
            }
    
    def _mapping_loop(self):
        """Main mapping loop"""
        logger.info("Mapping loop started")
        
        while self.mapping_active and not self.emergency_stop:
            try:
                # Get latest lidar scan
                scan_data = self.lidar_sensor.get_latest_scan()
                
                if not scan_data:
                    logger.warning("No lidar data available")
                    time.sleep(0.1)
                    continue
                
                # Process scan and decide action
                self._process_scan(scan_data)
                
                # Execute state-based behavior
                if self.state == RobotState.MOVING_FORWARD:
                    self._move_forward(scan_data)
                elif self.state == RobotState.TURNING:
                    self._execute_turn(scan_data)
                elif self.state == RobotState.OBSTACLE_AVOIDANCE:
                    self._avoid_obstacle(scan_data)
                elif self.state == RobotState.EMERGENCY_STOP:
                    self._emergency_stop()
                    break
                
                # Update odometry
                self._update_odometry()
                
                # Small delay to prevent CPU overload
                time.sleep(0.05)
                
            except Exception as e:
                logger.error(f"Error in mapping loop: {e}")
                self._emergency_stop()
                break
        
        # Ensure motors are stopped
        self.motor_controller.stop_all_motors()
        logger.info("Mapping loop ended")
    
    def _process_scan(self, scan_data: Dict[str, Any]):
        """Process lidar scan and determine robot state"""
        # Check for immediate obstacles
        min_distance = scan_data.get("min_distance", float('inf')) * 1000  # Convert to mm
        
        if min_distance < self.safety_distance:
            # Too close to obstacle
            if min_distance < self.safety_distance * 0.6:  # Very close
                self.state = RobotState.EMERGENCY_STOP
                return
            else:
                self.state = RobotState.OBSTACLE_AVOIDANCE
                return
        
        # Wall following logic
        right_wall_distance = self._get_wall_distance(scan_data, -90)  # Right side
        front_distance = self._get_wall_distance(scan_data, 0)  # Front
        
        # Check if we need to turn
        if front_distance < self.wall_follow_distance * 1.5:
            # Wall or obstacle ahead, need to turn
            self.state = RobotState.TURNING
        elif right_wall_distance is None or right_wall_distance > self.wall_follow_distance * 2:
            # No wall on right, turn right to find wall
            self.state = RobotState.TURNING
        else:
            # Follow wall
            self.state = RobotState.MOVING_FORWARD
    
    def _get_wall_distance(self, scan_data: Dict[str, Any], angle_deg: float) -> Optional[float]:
        """
        Get distance to wall at specific angle
        
        Args:
            scan_data: Lidar scan data
            angle_deg: Angle in degrees (0 = front, -90 = right, 90 = left)
            
        Returns:
            Distance in mm or None if no wall detected
        """
        points = scan_data.get("points", [])
        if not points:
            return None
        
        # Convert angle to radians
        target_angle = math.radians(angle_deg)
        angle_tolerance = math.radians(15)  # 15 degree tolerance
        
        # Find points within angle range
        valid_distances = []
        for point in points:
            angle_diff = abs(point["theta"] - target_angle)
            # Handle angle wrap-around
            if angle_diff > math.pi:
                angle_diff = 2 * math.pi - angle_diff
            
            if angle_diff <= angle_tolerance:
                valid_distances.append(point["r"] * 1000)  # Convert to mm
        
        if valid_distances:
            return np.median(valid_distances)  # Use median for robustness
        return None
    
    def _move_forward(self, scan_data: Dict[str, Any]):
        """Move forward while following wall"""
        # Get distance to right wall
        right_wall_distance = self._get_wall_distance(scan_data, -90)
        
        if right_wall_distance is None:
            # No wall detected, move forward slowly
            self._set_motors("forward", self.slow_speed, "forward", self.slow_speed)
            return
        
        # Calculate error from desired wall distance
        error = right_wall_distance - self.wall_follow_distance
        
        # PID control
        self.integral_error += error * self.command_delay
        derivative = (error - self.last_error) / self.command_delay
        self.last_error = error
        
        # Calculate correction
        correction = (self.kp * error + 
                     self.ki * self.integral_error + 
                     self.kd * derivative)
        
        # Convert correction to differential speed
        # Positive correction = turn left (away from wall)
        # Negative correction = turn right (toward wall)
        speed_diff = max(-20, min(20, correction / 50))  # Limit differential
        
        # Note: Motor sides are reversed as mentioned
        # Left motors in code = Right side of robot
        # Right motors in code = Left side of robot
        left_speed = self.base_speed + speed_diff   # Right side of robot
        right_speed = self.base_speed - speed_diff  # Left side of robot
        
        # Ensure speeds are in valid range
        left_speed = max(self.slow_speed, min(100, left_speed))
        right_speed = max(self.slow_speed, min(100, right_speed))
        
        # Set motor speeds (reversed due to wiring)
        self._set_motors("forward", left_speed, "forward", right_speed)
    
    def _execute_turn(self, scan_data: Dict[str, Any]):
        """Execute a turn (preferably right)"""
        front_distance = self._get_wall_distance(scan_data, 0)
        right_distance = self._get_wall_distance(scan_data, -90)
        left_distance = self._get_wall_distance(scan_data, 90)
        
        # Determine turn direction
        if self.turn_direction == TurnDirection.RIGHT:
            # Check if right turn is possible
            if right_distance and right_distance > self.wall_follow_distance * 1.5:
                # Turn right - note motor reversal
                # Left motors forward, right motors backward for right turn
                self._set_motors("forward", self.turn_speed, "backward", self.turn_speed)
            elif left_distance and left_distance > self.wall_follow_distance * 1.5:
                # Can't turn right, turn left
                self._set_motors("backward", self.turn_speed, "forward", self.turn_speed)
            else:
                # Can't turn either way, back up
                self._set_motors("backward", self.slow_speed, "backward", self.slow_speed)
        
        # Wait a bit for turn to execute
        time.sleep(0.5)
        
        # Check if turn is complete
        new_front = self._get_wall_distance(scan_data, 0)
        if new_front and new_front > self.wall_follow_distance * 1.5:
            self.state = RobotState.MOVING_FORWARD
    
    def _avoid_obstacle(self, scan_data: Dict[str, Any]):
        """Avoid immediate obstacle"""
        # Stop first
        self.motor_controller.stop_all_motors()
        time.sleep(0.2)
        
        # Determine escape direction
        left_clear = self._check_direction_clear(scan_data, 90)
        right_clear = self._check_direction_clear(scan_data, -90)
        
        if right_clear and (not left_clear or self.turn_direction == TurnDirection.RIGHT):
            # Turn right
            self._set_motors("forward", self.turn_speed, "backward", self.turn_speed)
        elif left_clear:
            # Turn left
            self._set_motors("backward", self.turn_speed, "forward", self.turn_speed)
        else:
            # Back up
            self._set_motors("backward", self.slow_speed, "backward", self.slow_speed)
        
        time.sleep(0.5)
        self.state = RobotState.MOVING_FORWARD
    
    def _check_direction_clear(self, scan_data: Dict[str, Any], angle_deg: float) -> bool:
        """Check if direction is clear for movement"""
        distance = self._get_wall_distance(scan_data, angle_deg)
        return distance is None or distance > self.safety_distance
    
    def _set_motors(self, left_dir: str, left_speed: float, 
                    right_dir: str, right_speed: float):
        """
        Set motor speeds accounting for reversal
        Note: Physical left/right are reversed in motor controller
        """
        # Motor 0 in code = Right side of robot
        # Motor 1 in code = Left side of robot
        
        # Set right side of robot (motor 0)
        self.motor_controller.set_motor(0, left_dir, left_speed)
        time.sleep(self.command_delay)
        
        # Set left side of robot (motor 1)
        self.motor_controller.set_motor(1, right_dir, right_speed)
    
    def _update_odometry(self):
        """Update robot position estimate based on motor commands"""
        # Simple dead reckoning - this is approximate
        current_time = time.time()
        dt = current_time - self.last_odometry_update
        self.last_odometry_update = current_time
        
        # Get current motor states
        motor_states = self.motor_controller.get_all_motor_states()
        
        # Calculate wheel velocities (mm/s) - approximate
        left_velocity = 0
        right_velocity = 0
        
        if motor_states[1]["direction"] == "forward":
            left_velocity = motor_states[1]["speed"] * 10  # mm/s at 100% speed
        elif motor_states[1]["direction"] == "backward":
            left_velocity = -motor_states[1]["speed"] * 10
        
        if motor_states[0]["direction"] == "forward":
            right_velocity = motor_states[0]["speed"] * 10
        elif motor_states[0]["direction"] == "backward":
            right_velocity = -motor_states[0]["speed"] * 10
        
        # Calculate robot velocity and angular velocity
        v = (left_velocity + right_velocity) / 2  # Linear velocity
        w = (right_velocity - left_velocity) / self.wheelbase  # Angular velocity
        
        # Update position
        if abs(w) < 0.001:  # Moving straight
            self.robot_x += v * dt * math.cos(self.robot_theta)
            self.robot_y += v * dt * math.sin(self.robot_theta)
        else:  # Turning
            # Use exact motion equations for differential drive
            self.robot_x += (v / w) * (math.sin(self.robot_theta + w * dt) - 
                                       math.sin(self.robot_theta))
            self.robot_y += (v / w) * (-math.cos(self.robot_theta + w * dt) + 
                                       math.cos(self.robot_theta))
            self.robot_theta += w * dt
        
        # Normalize angle
        self.robot_theta = self.robot_theta % (2 * math.pi)
        
        # Update visited cells (10cm grid)
        grid_x = int(self.robot_x / 100)
        grid_y = int(self.robot_y / 100)
        self.visited_cells.add((grid_x, grid_y))
    
    def _emergency_stop(self):
        """Execute emergency stop"""
        logger.warning("Emergency stop activated!")
        self.motor_controller.stop_all_motors()
        self.state = RobotState.EMERGENCY_STOP
        self.emergency_stop = True

# Singleton instance
_auto_mapper = None

def get_auto_mapper(motor_controller=None, lidar_sensor=None):
    """Get or create AutoMapper instance"""
    global _auto_mapper
    if _auto_mapper is None and motor_controller and lidar_sensor:
        _auto_mapper = AutoMapper(motor_controller, lidar_sensor)
    return _auto_mapper
================================================================================


================================================================================
FILE: backend/config_manager.py
Category: Python | Size: 3.3 KB | Lines: 105
================================================================================
#!/usr/bin/env python3
"""
Configuration manager for persistent settings
Saves and loads configuration from a JSON file
"""

import json
import os
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class ConfigManager:
    """Manages persistent configuration settings"""
    
    def __init__(self, config_file: str = None):
        """
        Initialize configuration manager
        
        Args:
            config_file: Path to configuration file (default: ~/.robot_dashboard_config.json)
        """
        if config_file is None:
            # Use home directory for config file
            self.config_file = Path.home() / ".robot_dashboard_config.json"
        else:
            self.config_file = Path(config_file)
        
        # Default configuration
        self.default_config = {
            "PI_IP": "192.168.2.1",
            "ROS_BRIDGE_PORT": 9090,
            "FLASK_PORT": 5001,
            "FLASK_HOST": "0.0.0.0"
        }
        
        # Load configuration
        self.config = self.load_config()
    
    def load_config(self) -> dict:
        """Load configuration from file or return defaults"""
        try:
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    loaded_config = json.load(f)
                    # Merge with defaults (in case new fields are added)
                    config = self.default_config.copy()
                    config.update(loaded_config)
                    logger.info(f"Loaded configuration from {self.config_file}")
                    return config
            else:
                logger.info("No config file found, using defaults")
                return self.default_config.copy()
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            return self.default_config.copy()
    
    def save_config(self):
        """Save current configuration to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
            logger.info(f"Saved configuration to {self.config_file}")
            return True
        except Exception as e:
            logger.error(f"Error saving config: {e}")
            return False
    
    def update_config(self, updates: dict) -> bool:
        """
        Update configuration values
        
        Args:
            updates: Dictionary of configuration updates
            
        Returns:
            bool: True if successful
        """
        try:
            # Update configuration
            self.config.update(updates)
            # Save to file
            return self.save_config()
        except Exception as e:
            logger.error(f"Error updating config: {e}")
            return False
    
    def get(self, key: str, default=None):
        """Get configuration value"""
        return self.config.get(key, default)
    
    def get_all(self) -> dict:
        """Get all configuration values"""
        return self.config.copy()

# Singleton instance
_config_manager = None

def get_config_manager(config_file: str = None) -> ConfigManager:
    """Get or create ConfigManager instance"""
    global _config_manager
    if _config_manager is None:
        _config_manager = ConfigManager(config_file)
    return _config_manager
================================================================================


================================================================================
FILE: backend/host_backend.py
Category: Python | Size: 21.5 KB | Lines: 686
================================================================================
#!/usr/bin/env python3
"""
Flask backend server for ROS 2 robot control
Main application entry point with multi-component support
"""

import os
import sys
from pathlib import Path

# Add parent directory to path for imports
sys.path.append(str(Path(__file__).parent.parent))

from flask import Flask, render_template, jsonify, request
from flask_cors import CORS
from flask_socketio import SocketIO, emit
import logging

# Import configuration manager
from backend.config_manager import get_config_manager

# Import ROS bridge components
from backend.ros_bridge import get_ros_bridge, get_motor_controller
from backend.sensors.lidar import get_lidar_sensor
from backend.sensors.thermal_camera import get_thermal_camera_sensor
from backend.sensors.system_monitor import get_system_monitor
from backend.motors.servo_control import ServoController
from backend.motors.actuator_control import get_actuator_controller

# Create Flask app
app = Flask(__name__, 
            template_folder='../frontend/templates',
            static_folder='../frontend/static')
CORS(app)  # Enable CORS for API requests
socketio = SocketIO(app, cors_allowed_origins="*")  # For real-time data

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Load configuration from persistent storage
config_manager = get_config_manager()
CONFIG = config_manager.get_all()

# Initialize ROS components with saved configuration
ros_bridge = get_ros_bridge(CONFIG["PI_IP"], CONFIG["ROS_BRIDGE_PORT"])
motor_controller = get_motor_controller()
lidar_sensor = get_lidar_sensor()
thermal_camera_sensor = get_thermal_camera_sensor()
system_monitor = get_system_monitor()
servo_controller = ServoController()
actuator_controller = get_actuator_controller()

# Set ROS bridge for servo controller
servo_controller.set_ros_bridge(ros_bridge)
actuator_controller.set_ros_bridge(ros_bridge)

# Data streaming states
lidar_streaming = False
servo_streaming = False
system_streaming = False

# =============================================================================
# MAIN DASHBOARD ROUTES
# =============================================================================

@app.route('/')
def index():
    """Serve the main dashboard home page"""
    return render_template('dashboard_home.html')

@app.route('/motors')
def motors_page():
    """Serve the motor control interface"""
    return render_template('motor_control.html')

@app.route('/lidar')
def lidar_page():
    """Serve the lidar visualization interface"""
    return render_template('lidar_visualization.html')

@app.route('/thermal')
def thermal_page():
    """Serve the thermal camera interface"""
    return render_template('thermal_camera.html')

@app.route('/aiming')
def aiming_system():
    """Serve the aiming system control interface"""
    return render_template('aiming_system.html')

# =============================================================================
# MOTOR CONTROL API ROUTES
# =============================================================================

@app.route('/api/motor/<int:motor_id>', methods=['POST'])
def control_motor(motor_id):
    """Control a specific motor"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        # Use motor controller
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in control_motor: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/motor/<int:motor_id>', methods=['GET'])
def get_motor_status(motor_id):
    """Get current status of a specific motor"""
    state = motor_controller.get_motor_state(motor_id)
    
    if state:
        return jsonify({
            "success": True,
            "motor_id": motor_id,
            "state": state
        })
    else:
        return jsonify({
            "success": False,
            "error": "Invalid motor ID"
        }), 404

@app.route('/api/motors', methods=['GET'])
def get_all_motors_status():
    """Get current status of all motors"""
    states = motor_controller.get_all_motor_states()
    
    return jsonify({
        "success": True,
        "motors": states
    })

@app.route('/api/motors/stop', methods=['POST'])
def stop_all_motors():
    """Emergency stop - brake all motors"""
    result = motor_controller.stop_all_motors()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

# =============================================================================
# SERVO/AIMING SYSTEM API ROUTES
# =============================================================================

@app.route('/api/servo/position', methods=['POST'])
def set_servo_position():
    """Set servo position for pan/tilt"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        pan_angle = data.get('pan_angle', servo_controller.pan_angle)
        tilt_angle = data.get('tilt_angle', servo_controller.tilt_angle)
        
        # Move servos
        result = servo_controller.move_to_position(pan_angle, tilt_angle)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in set_servo_position: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/servo/position', methods=['GET'])
def get_servo_position():
    """Get current servo position"""
    state = servo_controller.get_state()
    
    return jsonify({
        "success": True,
        "state": state
    })

@app.route('/api/servo/center', methods=['POST'])
def center_servos():
    """Move servos to center position"""
    result = servo_controller.center_position()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 400

@app.route('/api/servo/preset/<string:position>', methods=['POST'])
def move_to_preset(position):
    """Move servos to preset position (left, right, up, down)"""
    preset_functions = {
        'left': servo_controller.move_left,
        'right': servo_controller.move_right,
        'up': servo_controller.move_up,
        'down': servo_controller.move_down,
        'center': servo_controller.center_position
    }
    
    if position not in preset_functions:
        return jsonify({
            "success": False,
            "error": f"Invalid preset position: {position}"
        }), 400
    
    result = preset_functions[position]()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 400

# =============================================================================
# ACTUATOR CONTROL API ROUTES
# =============================================================================

@app.route('/api/actuator/control', methods=['POST'])
def control_actuator():
    """Control the actuator for fire extinguisher trigger"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        action = data.get('action', 'stop')
        speed = data.get('speed', 0)
        duration = data.get('duration', 0.0)
        
        result = actuator_controller.control_actuator(action, speed, duration)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in control_actuator: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/actuator/status', methods=['GET'])
def get_actuator_status():
    """Get current actuator status"""
    state = actuator_controller.get_state()
    
    return jsonify({
        "success": True,
        "state": state
    })

@app.route('/api/actuator/test', methods=['GET'])
def test_actuator_connection():
    """Test actuator connection"""
    connected = actuator_controller.test_connection()
    
    return jsonify({
        "success": True,
        "connected": connected,
        "message": "Actuator service is available" if connected else "Actuator service not responding"
    })

@app.route('/api/actuator/stop', methods=['POST'])
def stop_actuator():
    """Emergency stop for actuator"""
    result = actuator_controller.emergency_stop()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 400

# =============================================================================
# LIDAR API ROUTES
# =============================================================================

@app.route('/api/lidar/status', methods=['GET'])
def get_lidar_status():
    """Get lidar sensor status"""
    latest_scan = lidar_sensor.get_latest_scan()
    
    return jsonify({
        "connected": lidar_sensor.subscription_active,
        "has_data": latest_scan is not None,
        "timestamp": latest_scan["timestamp"] if latest_scan else None
    })

@app.route('/api/lidar/latest', methods=['GET'])
def get_latest_lidar_scan():
    """Get the most recent lidar scan data"""
    scan_data = lidar_sensor.get_latest_scan()
    
    if scan_data:
        return jsonify({
            "success": True,
            "data": scan_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "No scan data available"
        }), 404

@app.route('/api/lidar/subscribe', methods=['POST'])
def subscribe_lidar():
    """Start lidar data subscription"""
    global lidar_streaming
    
    def lidar_callback(scan_data):
        """Emit lidar data through WebSocket"""
        if lidar_streaming:
            socketio.emit('lidar_data', scan_data)
    
    success = lidar_sensor.subscribe(callback=lidar_callback, processed_data=True)
    
    if success:
        lidar_streaming = True
        return jsonify({"success": True, "message": "Lidar subscription started"})
    else:
        return jsonify({"success": False, "error": "Failed to subscribe to lidar"}), 500

@app.route('/api/lidar/unsubscribe', methods=['POST'])
def unsubscribe_lidar():
    """Stop lidar data subscription"""
    global lidar_streaming
    
    lidar_streaming = False
    lidar_sensor.unsubscribe()
    
    return jsonify({"success": True, "message": "Lidar subscription stopped"})

# =============================================================================
# THERMAL CAMERA API ROUTES
# =============================================================================

@app.route('/api/thermal/status', methods=['GET'])
def get_thermal_status():
    """Get thermal camera sensor status"""
    latest_frame = thermal_camera_sensor.get_latest_frame()
    
    return jsonify({
        "connected": thermal_camera_sensor.subscription_active,
        "has_data": latest_frame is not None,
        "timestamp": latest_frame["timestamp"] if latest_frame else None
    })

@app.route('/api/thermal/latest', methods=['GET'])
def get_latest_thermal_frame():
    """Get the most recent thermal frame data"""
    frame_data = thermal_camera_sensor.get_latest_frame()
    
    if frame_data:
        return jsonify({
            "success": True,
            "data": frame_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "No thermal data available"
        }), 404

@app.route('/api/thermal/frame', methods=['GET'])
def get_thermal_frame():
    """Get a single thermal frame via service call"""
    frame_data = thermal_camera_sensor.get_thermal_frame_once()
    
    if frame_data:
        return jsonify({
            "success": True,
            "data": frame_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "Failed to capture thermal frame"
        }), 500

@app.route('/api/thermal/subscribe', methods=['POST'])
def subscribe_thermal():
    """Start thermal camera data subscription"""
    def thermal_callback(frame_data):
        """Emit thermal data through WebSocket"""
        socketio.emit('thermal_data', frame_data)
    
    success = thermal_camera_sensor.subscribe(callback=thermal_callback)
    
    if success:
        return jsonify({"success": True, "message": "Thermal camera subscription started"})
    else:
        return jsonify({"success": False, "error": "Failed to subscribe to thermal camera"}), 500

@app.route('/api/thermal/unsubscribe', methods=['POST'])
def unsubscribe_thermal():
    """Stop thermal camera data subscription"""
    thermal_camera_sensor.unsubscribe()
    
    return jsonify({"success": True, "message": "Thermal camera subscription stopped"})

# =============================================================================
# SYSTEM MONITOR API ROUTES
# =============================================================================

@app.route('/api/system/status', methods=['GET'])
def get_system_status_monitor():
    """Get system monitor status"""
    latest_status = system_monitor.get_latest_status()
    
    return jsonify({
        "connected": system_monitor.subscription_active,
        "has_data": latest_status is not None,
        "data": latest_status,
        "timestamp": latest_status["timestamp"] if latest_status else None
    })

@app.route('/api/system/subscribe', methods=['POST'])
def subscribe_system_monitor():
    """Start system monitor subscription"""
    global system_streaming
    
    def system_callback(status_data):
        """Emit system data through WebSocket"""
        if system_streaming:
            socketio.emit('system_status', status_data)
    
    success = system_monitor.subscribe(callback=system_callback)
    
    if success:
        system_streaming = True
        return jsonify({"success": True, "message": "System monitor subscription started"})
    else:
        return jsonify({"success": False, "error": "Failed to subscribe to system monitor"}), 500

@app.route('/api/system/unsubscribe', methods=['POST'])
def unsubscribe_system_monitor():
    """Stop system monitor subscription"""
    global system_streaming
    
    system_streaming = False
    system_monitor.unsubscribe()
    
    return jsonify({"success": True, "message": "System monitor subscription stopped"})

# =============================================================================
# SYSTEM STATUS ROUTES
# =============================================================================

@app.route('/api/status', methods=['GET'])
def get_system_status():
    """Check connection status to ROS bridge and system info"""
    ros_connected = ros_bridge.test_connection()
    
    return jsonify({
        "connected": ros_connected,
        "rosbridge_url": ros_bridge.url,
        "config": {
            "robot_ip": CONFIG["PI_IP"],
            "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"]
        },
        "components": {
            "motors": True,
            "lidar": lidar_sensor.subscription_active,
            "thermal": thermal_camera_sensor.subscription_active,
            "servo": servo_controller.connected,
            "system_monitor": system_monitor.subscription_active,
            "actuator": actuator_controller.connected
        }
    }), 200 if ros_connected else 503

@app.route('/api/config', methods=['GET'])
def get_config():
    """Get current configuration"""
    return jsonify({
        "robot_ip": CONFIG["PI_IP"],
        "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"],
        "flask_port": CONFIG["FLASK_PORT"],
        "flask_host": CONFIG["FLASK_HOST"]
    })

@app.route('/api/config', methods=['POST'])
def update_config():
    """Update configuration with new connection settings"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        # Get new settings
        new_ip = data.get('robot_ip')
        new_port = data.get('rosbridge_port')
        
        if not new_ip or not new_port:
            return jsonify({"error": "Missing robot_ip or rosbridge_port"}), 400
        
        # Update configuration in memory
        CONFIG["PI_IP"] = new_ip
        CONFIG["ROS_BRIDGE_PORT"] = int(new_port)
        
        # Save to persistent storage
        config_updates = {
            "PI_IP": new_ip,
            "ROS_BRIDGE_PORT": int(new_port)
        }
        config_manager.update_config(config_updates)
        
        # Update ROS bridge connection
        global ros_bridge, motor_controller, lidar_sensor, thermal_camera_sensor, servo_controller, actuator_controller
        ros_bridge = get_ros_bridge(CONFIG["PI_IP"], CONFIG["ROS_BRIDGE_PORT"])
        motor_controller = get_motor_controller()
        lidar_sensor = get_lidar_sensor()
        thermal_camera_sensor = get_thermal_camera_sensor()
        
        # Update servo and actuator controllers with new ROS bridge
        servo_controller.set_ros_bridge(ros_bridge)
        actuator_controller.set_ros_bridge(ros_bridge)
        
        logger.info(f"Configuration updated and saved: IP={new_ip}, Port={new_port}")
        
        return jsonify({
            "success": True,
            "message": "Configuration updated successfully",
            "config": {
                "robot_ip": CONFIG["PI_IP"],
                "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"]
            }
        })
        
    except Exception as e:
        logger.error(f"Error updating configuration: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

# =============================================================================
# WEBSOCKET EVENTS
# =============================================================================

@socketio.on('connect')
def handle_connect():
    """Handle WebSocket connection"""
    logger.info("Client connected to WebSocket")
    emit('connected', {'data': 'Connected to robot dashboard'})

@socketio.on('disconnect')
def handle_disconnect():
    """Handle WebSocket disconnection"""
    logger.info("Client disconnected from WebSocket")

# Servo WebSocket events
@socketio.on('servo_command')
def handle_servo_command(data):
    """Handle servo commands via WebSocket"""
    global servo_streaming
    
    try:
        command_type = data.get('type', 'servo_command')
        
        if command_type == 'servo_command':
            result = servo_controller.handle_websocket_command(data)
            
            # Send response
            emit('servo_response', {
                'type': 'command_result',
                'result': result
            })
            
            # Send updated state to all clients
            state = servo_controller.get_state()
            socketio.emit('servo_state', {
                'type': 'servo_state',
                **state
            })
            
    except Exception as e:
        logger.error(f"Error handling servo command: {e}")
        emit('servo_error', {
            'type': 'error',
            'error': str(e)
        })

@socketio.on('request_servo_state')
def handle_servo_state_request():
    """Send current servo state via WebSocket"""
    state = servo_controller.get_state()
    emit('servo_state', {
        'type': 'servo_state',
        **state
    })

# =============================================================================
# ERROR HANDLERS
# =============================================================================

@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Not found"}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Internal server error"}), 500

# Health check endpoint
@app.route('/health', methods=['GET'])
def health_check():
    """Simple health check endpoint"""
    return jsonify({
        "status": "healthy",
        "service": "robot-dashboard-backend"
    })

# =============================================================================
# INITIALIZATION
# =============================================================================

def initialize_system():
    """Initialize all system components"""
    logger.info("Initializing system components...")
    
    # Set WebSocket handler for servo updates
    def servo_websocket_handler(data):
        """Handle servo state updates"""
        socketio.emit('servo_state', data)
    
    servo_controller.set_websocket_handler(servo_websocket_handler)
    
    # Initialize servo to center position
    logger.info("Moving servos to center position...")
    servo_controller.center_position()
    
    logger.info("System initialization complete")

def main():
    """Main entry point"""
    logger.info("=" * 50)
    logger.info("ROS 2 Robot Dashboard Backend")
    logger.info(f"Robot IP: {CONFIG['PI_IP']}")
    logger.info(f"ROS Bridge Port: {CONFIG['ROS_BRIDGE_PORT']}")
    logger.info(f"Flask Server: {CONFIG['FLASK_HOST']}:{CONFIG['FLASK_PORT']}")
    logger.info(f"Config file: {config_manager.config_file}")
    logger.info("=" * 50)
    
    # Initialize system
    initialize_system()
    
    # Run Flask app with SocketIO
    debug_mode = os.environ.get('FLASK_ENV', 'development') == 'development'
    
    socketio.run(
        app,
        debug=debug_mode,
        host=CONFIG['FLASK_HOST'],
        port=CONFIG['FLASK_PORT'],
        use_reloader=False  # Disable auto-reloader to prevent numpy reload issues
    )

if __name__ == '__main__':
    main()
================================================================================


================================================================================
FILE: backend/motors/__init__.py
Category: Python | Size: 0.0 B | Lines: 0
================================================================================

================================================================================


================================================================================
FILE: backend/motors/actuator_control.py
Category: Python | Size: 7.5 KB | Lines: 205
================================================================================
#!/usr/bin/env python3
"""
Actuator Control Module for Fire Extinguisher Trigger
Handles linear actuator control through ROS2 service calls
"""

import logging
from typing import Dict, Any, Optional
from datetime import datetime

logger = logging.getLogger(__name__)

class ActuatorController:
    """Controls the linear actuator for fire extinguisher trigger mechanism"""
    
    def __init__(self, ros_bridge=None):
        """
        Initialize actuator controller
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.connected = False
        self.current_state = "stopped"
        self.current_speed = 0
        self.last_command_time = None
        
        logger.info("Actuator controller initialized")
    
    def set_ros_bridge(self, ros_bridge):
        """Set or update the ROS bridge instance"""
        self.ros_bridge = ros_bridge
        self.connected = True
        logger.info("ROS bridge connected to actuator controller")
    
    def control_actuator(self, action: str, speed: int = 0, duration: float = 0.0) -> Dict[str, Any]:
        """
        Control the actuator
        
        Args:
            action: 'extend', 'retract', or 'stop'
            speed: Speed percentage (0-100)
            duration: Duration in seconds (0 for continuous)
            
        Returns:
            Dict with operation result
        """
        # Validate inputs
        if action not in ['extend', 'retract', 'stop']:
            return {
                "success": False,
                "error": f"Invalid action: {action}. Must be 'extend', 'retract', or 'stop'"
            }
        
        if action != 'stop':
            speed = max(0, min(100, speed))
        else:
            speed = 0
        
        duration = max(0.0, duration)
        
        # Update state
        self.current_state = action
        self.current_speed = speed
        self.last_command_time = datetime.now()
        
        # Send command via ROS bridge if available
        if self.ros_bridge:
            try:
                # Call the set_actuator service with proper type
                service_args = {
                    "action": action,
                    "speed": speed,
                    "duration": duration
                }
                
                logger.info(f"Calling /set_actuator with args: {service_args}")
                
                # Add service type for rosbridge
                success, response = self.ros_bridge.call_service(
                    "/set_actuator",
                    service_args,
                    "set_actuator",
                    service_type="actuator_interfaces/srv/SetActuator"
                )
                
                logger.info(f"Service call response: success={success}, response={response}")
                
                # Check different response formats
                if success:
                    # Extract the actual service response from rosbridge format
                    service_response = response.get("values", {})
                    
                    # Check if the service itself returned success
                    service_success = service_response.get("success", True)
                    service_message = service_response.get("message", "Command sent")
                    
                    if service_success:
                        logger.info(f"Actuator command successful: {service_message}")
                        return {
                            "success": True,
                            "action": action,
                            "speed": speed,
                            "duration": duration,
                            "message": service_message or f"Actuator {action} at {speed}% speed" + (f" for {duration}s" if duration > 0 else " (continuous)"),
                            "response": service_response
                        }
                    else:
                        logger.error(f"Service returned failure: {service_message}")
                        return {
                            "success": False,
                            "error": service_message or "Actuator command failed",
                            "details": service_response
                        }
                else:
                    error_msg = response.get("error", response.get("msg", "Unknown error"))
                    logger.error(f"Failed to call service: {error_msg}")
                    logger.error(f"Full response: {response}")
                    return {
                        "success": False,
                        "error": error_msg,
                        "details": response
                    }
                    
            except Exception as e:
                logger.error(f"Failed to send actuator command: {e}")
                return {
                    "success": False,
                    "error": str(e)
                }
        else:
            # No ROS bridge - just update local state
            return {
                "success": True,
                "action": action,
                "speed": speed,
                "duration": duration,
                "message": "Actuator command simulated (no ROS bridge connected)"
            }
    
    def extend(self, speed: int = 100, duration: float = 0.0) -> Dict[str, Any]:
        """Extend the actuator"""
        return self.control_actuator("extend", speed, duration)
    
    def retract(self, speed: int = 100, duration: float = 0.0) -> Dict[str, Any]:
        """Retract the actuator"""
        return self.control_actuator("retract", speed, duration)
    
    def stop(self) -> Dict[str, Any]:
        """Stop the actuator immediately"""
        return self.control_actuator("stop", 0, 0.0)
    
    def get_state(self) -> Dict[str, Any]:
        """Get current actuator state"""
        return {
            "state": self.current_state,
            "speed": self.current_speed,
            "connected": self.connected,
            "last_command": self.last_command_time.isoformat() if self.last_command_time else None,
            "timestamp": datetime.now().isoformat()
        }
    
    def test_connection(self) -> bool:
        """Test if actuator service is available"""
        if not self.ros_bridge:
            self.connected = False
            return False
            
        try:
            # Try to call service with a test command
            success, response = self.ros_bridge.call_service(
                "/set_actuator",
                {"action": "stop", "speed": 0, "duration": 0.0},
                "test_actuator_connection",
                service_type="actuator_interfaces/srv/SetActuator"
            )
            
            self.connected = success
            return success
            
        except Exception as e:
            logger.error(f"Actuator connection test failed: {e}")
            self.connected = False
            return False
    
    def emergency_stop(self) -> Dict[str, Any]:
        """Emergency stop - immediately stop actuator"""
        logger.warning("Emergency stop activated for actuator")
        return self.stop()


# Singleton instance
_actuator_controller = None

def get_actuator_controller(ros_bridge=None):
    """Get or create actuator controller instance"""
    global _actuator_controller
    
    if _actuator_controller is None:
        _actuator_controller = ActuatorController(ros_bridge)
    elif ros_bridge is not None:
        _actuator_controller.set_ros_bridge(ros_bridge)
    
    return _actuator_controller
================================================================================


================================================================================
FILE: backend/motors/motor_controller.py
Category: Python | Size: 6.3 KB | Lines: 192
================================================================================
"""
Motor Controller Module
Handles motor control logic and ROS communication
"""

import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

class MotorController:
    """Motor controller for 4-motor robot using L298N drivers"""
    
    def __init__(self, ros_bridge=None):
        self.ros_bridge = ros_bridge
        
        # Motor state tracking
        self.motor_states = {
            1: {"direction": "brake", "speed": 0},
            2: {"direction": "brake", "speed": 0},
            3: {"direction": "brake", "speed": 0},
            4: {"direction": "brake", "speed": 0}
        }
        
        # Motor channel mapping (2 motors per L298N channel)
        self.motor_to_channel = {
            1: 'A',  # Front-left
            2: 'A',  # Front-right
            3: 'B',  # Rear-left
            4: 'B'   # Rear-right
        }
        
        logger.info("Motor controller initialized")
    
    def set_ros_bridge(self, ros_bridge):
        """Set or update the ROS bridge instance"""
        self.ros_bridge = ros_bridge
        logger.info("ROS bridge connected to motor controller")
    
    def set_motor(self, motor_id: int, direction: str, speed: int) -> Dict[str, Any]:
        """
        Control a specific motor
        
        Args:
            motor_id: Motor number (1-4)
            direction: 'forward', 'backward', or 'brake'
            speed: Speed value (0-100)
        
        Returns:
            Result dictionary with success status
        """
        # Validate inputs
        if motor_id not in range(1, 5):
            return {
                "success": False,
                "error": f"Invalid motor ID: {motor_id}. Must be 1-4."
            }
        
        if direction not in ['forward', 'backward', 'brake']:
            return {
                "success": False,
                "error": f"Invalid direction: {direction}"
            }
        
        # Clamp speed to valid range
        speed = max(0, min(100, speed))
        
        # Update motor state
        self.motor_states[motor_id] = {
            "direction": direction,
            "speed": speed
        }
        
        # Get channel for this motor
        channel = self.motor_to_channel[motor_id]
        
        # Send command via ROS bridge if available
        if self.ros_bridge:
            try:
                # For motors sharing a channel, we need to consider both motors
                channel_motors = [m for m, ch in self.motor_to_channel.items() if ch == channel]
                
                # If both motors on the channel have the same direction, use that
                # Otherwise, handle mixed directions appropriately
                channel_direction = direction
                channel_speed = speed
                
                # Send motor command
                self.ros_bridge.send_motor_command(channel, channel_direction, channel_speed)
                
                logger.info(f"Motor {motor_id} set to {direction} at speed {speed}")
                
                return {
                    "success": True,
                    "motor_id": motor_id,
                    "direction": direction,
                    "speed": speed,
                    "channel": channel
                }
                
            except Exception as e:
                logger.error(f"Failed to send motor command: {e}")
                return {
                    "success": False,
                    "error": str(e)
                }
        else:
            # No ROS bridge - just update local state
            return {
                "success": True,
                "motor_id": motor_id,
                "direction": direction,
                "speed": speed,
                "message": "Motor state updated (no ROS bridge connected)"
            }
    
    def get_motor_state(self, motor_id: int) -> Optional[Dict[str, Any]]:
        """Get current state of a specific motor"""
        if motor_id in self.motor_states:
            return self.motor_states[motor_id]
        return None
    
    def get_all_motor_states(self) -> Dict[int, Dict[str, Any]]:
        """Get current state of all motors"""
        return self.motor_states.copy()
    
    def stop_all_motors(self) -> Dict[str, Any]:
        """Emergency stop - brake all motors"""
        try:
            for motor_id in range(1, 5):
                self.set_motor(motor_id, "brake", 0)
            
            logger.warning("Emergency stop - all motors braked")
            
            return {
                "success": True,
                "message": "All motors stopped"
            }
            
        except Exception as e:
            logger.error(f"Failed to stop all motors: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def set_channel_motors(self, channel: str, direction: str, speed: int) -> Dict[str, Any]:
        """
        Control all motors on a specific channel
        Used for coordinated movement (e.g., both left motors for turning)
        
        Args:
            channel: 'A' or 'B'
            direction: 'forward', 'backward', or 'brake'
            speed: Speed value (0-100)
        """
        if channel not in ['A', 'B']:
            return {
                "success": False,
                "error": f"Invalid channel: {channel}"
            }
        
        # Find motors on this channel
        channel_motors = [m for m, ch in self.motor_to_channel.items() if ch == channel]
        
        # Set all motors on the channel
        for motor_id in channel_motors:
            result = self.set_motor(motor_id, direction, speed)
            if not result['success']:
                return result
        
        return {
            "success": True,
            "channel": channel,
            "motors": channel_motors,
            "direction": direction,
            "speed": speed
        }

# Singleton instance
_motor_controller_instance = None

def get_motor_controller(ros_bridge=None):
    """Get or create motor controller instance"""
    global _motor_controller_instance
    
    if _motor_controller_instance is None:
        _motor_controller_instance = MotorController(ros_bridge)
    elif ros_bridge is not None:
        _motor_controller_instance.set_ros_bridge(ros_bridge)
    
    return _motor_controller_instance
================================================================================


================================================================================
FILE: backend/motors/motor_routes.py
Category: Python | Size: 4.1 KB | Lines: 127
================================================================================
"""
Motor Control Routes Module
Handles all motor-related API endpoints
Fixed: Left/Right motor reversal issue
"""

from flask import Blueprint, jsonify, request, render_template
import logging

# Create Blueprint
motor_bp = Blueprint('motors', __name__)

# Setup logging
logger = logging.getLogger(__name__)

# =============================================================================
# MOTOR PAGE ROUTE
# =============================================================================

@motor_bp.route('/motors')
def motors_page():
    """Serve the motor control interface"""
    return render_template('motor_control.html')

# =============================================================================
# MOTOR CONTROL API ROUTES
# =============================================================================

@motor_bp.route('/api/motor/<int:motor_id>', methods=['POST'])
def control_motor(motor_id):
    """Control a specific motor"""
    try:
        from backend.motors.motor_controller import get_motor_controller
        motor_controller = get_motor_controller()
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        # Use motor controller
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in control_motor: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@motor_bp.route('/api/motor/<int:motor_id>', methods=['GET'])
def get_motor_status(motor_id):
    """Get current status of a specific motor"""
    from backend.motors.motor_controller import get_motor_controller
    motor_controller = get_motor_controller()
    state = motor_controller.get_motor_state(motor_id)
    
    if state:
        return jsonify({
            "success": True,
            "motor_id": motor_id,
            "state": state
        })
    else:
        return jsonify({
            "success": False,
            "error": "Invalid motor ID"
        }), 404

@motor_bp.route('/api/motors', methods=['GET'])
def get_all_motors_status():
    """Get current status of all motors"""
    from backend.motors.motor_controller import get_motor_controller
    motor_controller = get_motor_controller()
    states = motor_controller.get_all_motor_states()
    
    return jsonify({
        "success": True,
        "motors": states
    })

@motor_bp.route('/api/motors/stop', methods=['POST'])
def stop_all_motors():
    """Emergency stop - brake all motors"""
    from backend.motors.motor_controller import get_motor_controller
    motor_controller = get_motor_controller()
    result = motor_controller.stop_all_motors()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

# Optional: WebSocket support for real-time motor control
def init_motor_websocket(socketio):
    """Initialize WebSocket handlers for motor control"""
    
    @socketio.on('motor_command')
    def handle_motor_command(data):
        """Handle real-time motor commands via WebSocket"""
        from backend.motors.motor_controller import get_motor_controller
        motor_controller = get_motor_controller()
        motor_id = data.get('motor_id')
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        socketio.emit('motor_response', {
            'motor_id': motor_id,
            'result': result
        })
    
    @socketio.on('request_motor_states')
    def handle_motor_states_request():
        """Send current motor states via WebSocket"""
        from backend.motors.motor_controller import get_motor_controller
        motor_controller = get_motor_controller()
        states = motor_controller.get_all_motor_states()
        socketio.emit('motor_states', states)
================================================================================


================================================================================
FILE: backend/motors/servo_control.py
Category: Python | Size: 6.7 KB | Lines: 199
================================================================================
"""
Servo Control Interface for Aiming System
Controls pan and tilt servos through ROS2 topics
"""

import json
import logging
from typing import Dict, Any, Optional, Callable
from datetime import datetime
import asyncio

logger = logging.getLogger(__name__)

class ServoController:
    def __init__(self):
        self.pan_angle = 135.0  # Default center position
        self.tilt_angle = 135.0  # Default center position
        self.pan_moving = False
        self.tilt_moving = False
        self.connected = False
        self.ros_bridge = None
        self.websocket_handler = None
        self.last_command_time = None
        
        # Servo limits
        self.pan_min = 75.0
        self.pan_max = 195.0
        self.tilt_min = 75.0
        self.tilt_max = 195.0
        
        # Movement tracking
        self.target_pan = 135.0
        self.target_tilt = 135.0
        self.movement_speed = 60.0  # degrees per second
        
        logger.info("Servo controller initialized")
    
    def set_ros_bridge(self, ros_bridge):
        """Set the ROS bridge instance for publishing commands"""
        self.ros_bridge = ros_bridge
        self.connected = True
        logger.info("ROS bridge connected to servo controller")
    
    def set_websocket_handler(self, handler: Callable):
        """Set the WebSocket handler for sending updates"""
        self.websocket_handler = handler
    
    def move_to_position(self, pan: float, tilt: float) -> Dict[str, Any]:
        """
        Move servos to specified position (synchronous version)
        
        Args:
            pan: Pan angle (75-195 degrees)
            tilt: Tilt angle (75-195 degrees)
            
        Returns:
            Status dictionary
        """
        # Run async version in sync context
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        result = loop.run_until_complete(self._async_move_to_position(pan, tilt))
        loop.close()
        return result
    
    async def _async_move_to_position(self, pan: float, tilt: float) -> Dict[str, Any]:
        """
        Move servos to specified position (async version)
        
        Args:
            pan: Pan angle (75-195 degrees)
            tilt: Tilt angle (75-195 degrees)
            
        Returns:
            Status dictionary
        """
        # Validate angles
        pan = max(self.pan_min, min(self.pan_max, pan))
        tilt = max(self.tilt_min, min(self.tilt_max, tilt))
        
        self.target_pan = pan
        self.target_tilt = tilt
        self.last_command_time = datetime.now()
        
        # Check if movement needed
        if abs(self.pan_angle - pan) > 0.5:
            self.pan_moving = True
        if abs(self.tilt_angle - tilt) > 0.5:
            self.tilt_moving = True
        
        # Send ROS command if bridge available
        if self.ros_bridge:
            try:
                from backend.ros_bridge import get_servo_publisher
                servo_pub = get_servo_publisher()
                success = servo_pub.publish_position(pan, tilt)
                if success:
                    logger.info(f"Servo command sent: pan={pan}, tilt={tilt}")
                else:
                    logger.error("Failed to publish servo command")
                    return {
                        'success': False,
                        'error': 'Failed to publish servo command'
                    }
            except Exception as e:
                logger.error(f"Failed to send servo command: {e}")
                return {
                    'success': False,
                    'error': str(e)
                }
        
        # Update positions immediately for UI feedback
        self.pan_angle = pan
        self.tilt_angle = tilt
        self.pan_moving = False
        self.tilt_moving = False
        
        return {
            'success': True,
            'pan_angle': pan,
            'tilt_angle': tilt,
            'message': f"Moving to pan={pan}°, tilt={tilt}°"
        }
    
    def get_state(self) -> Dict[str, Any]:
        """Get current servo state"""
        return {
            'pan_angle': round(self.pan_angle, 1),
            'tilt_angle': round(self.tilt_angle, 1),
            'pan_moving': self.pan_moving,
            'tilt_moving': self.tilt_moving,
            'connected': self.connected,
            'target_pan': self.target_pan,
            'target_tilt': self.target_tilt,
            'timestamp': datetime.now().isoformat()
        }
    
    def center_position(self) -> Dict[str, Any]:
        """Move servos to center position (135, 135)"""
        return self.move_to_position(135.0, 135.0)
    
    def move_left(self) -> Dict[str, Any]:
        """Move to left position"""
        return self.move_to_position(75.0, 135.0)
    
    def move_right(self) -> Dict[str, Any]:
        """Move to right position"""
        return self.move_to_position(195.0, 135.0)
    
    def move_up(self) -> Dict[str, Any]:
        """Move to up position"""
        return self.move_to_position(135.0, 195.0)
    
    def move_down(self) -> Dict[str, Any]:
        """Move to down position"""
        return self.move_to_position(135.0, 75.0)
    
    def emergency_stop(self):
        """Stop all servo movement"""
        self.pan_moving = False
        self.tilt_moving = False
        self.target_pan = self.pan_angle
        self.target_tilt = self.tilt_angle
        logger.warning("Emergency stop activated for servos")
    
    def process_ros_feedback(self, data: Dict[str, Any]):
        """Process feedback from ROS about actual servo positions"""
        if 'pan_angle' in data:
            self.pan_angle = data['pan_angle']
        if 'tilt_angle' in data:
            self.tilt_angle = data['tilt_angle']
        
        # Check if reached target
        if abs(self.pan_angle - self.target_pan) < 1.0:
            self.pan_moving = False
        if abs(self.tilt_angle - self.target_tilt) < 1.0:
            self.tilt_moving = False
    
    def handle_websocket_command(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle commands from WebSocket (synchronous)"""
        action = data.get('action')
        
        if action == 'move':
            pan = data.get('pan_angle', self.pan_angle)
            tilt = data.get('tilt_angle', self.tilt_angle)
            return self.move_to_position(pan, tilt)
        
        elif action == 'center':
            return self.center_position()
        
        elif action == 'get_state':
            return self.get_state()
        
        elif action == 'emergency_stop':
            self.emergency_stop()
            return {'success': True, 'message': 'Emergency stop activated'}
        
        else:
            return {'success': False, 'error': f'Unknown action: {action}'}
================================================================================


================================================================================
FILE: backend/ros_bridge.py
Category: Python | Size: 16.9 KB | Lines: 522
================================================================================
#!/usr/bin/env python3
"""
ROS Bridge WebSocket communication module
Handles all ROS 2 communication via rosbridge
"""

import json
import logging
from websocket import create_connection
from typing import Dict, Any, Optional, Tuple

# Setup logging
logger = logging.getLogger(__name__)

class ROSBridgeConnection:
    """Manages WebSocket connection to ROS 2 via rosbridge"""
    
    def __init__(self, host: str = "192.168.2.4", port: int = 9090):
        """
        Initialize ROS Bridge connection parameters
        
        Args:
            host: IP address of the ROS 2 robot
            port: rosbridge websocket port (default: 9090)
        """
        self.host = host
        self.port = port
        self.url = f"ws://{host}:{port}"
        self._connection = None
        
        # Known service types mapping
        self.service_types = {
            "/set_motor": "motor_interfaces/srv/SetMotor",
            "/set_actuator": "actuator_interfaces/srv/SetActuator",
            "/get_thermal_frame": "mlx90640_interfaces/srv/GetThermalFrame",
            "/get_system_status": "system_interfaces/srv/GetSystemStatus"
        }
    
    def connect(self) -> bool:
        """
        Establish connection to rosbridge
        
        Returns:
            bool: True if connection successful, False otherwise
        """
        try:
            self._connection = create_connection(self.url, timeout=5)
            logger.info(f"Connected to rosbridge at {self.url}")
            return True
        except Exception as e:
            logger.error(f"Failed to connect to rosbridge: {e}")
            return False
    
    def disconnect(self):
        """Close the websocket connection"""
        if self._connection:
            self._connection.close()
            self._connection = None
            logger.info("Disconnected from rosbridge")
    
    def is_connected(self) -> bool:
        """Check if connection is active"""
        return self._connection is not None
    
    def call_service(self, service_name: str, args: Dict[str, Any], 
                    service_id: Optional[str] = None,
                    service_type: Optional[str] = None) -> Tuple[bool, Dict[str, Any]]:
        """
        Call a ROS service through rosbridge
        
        Args:
            service_name: Name of the ROS service (e.g., "/set_motor")
            args: Service arguments as dictionary
            service_id: Optional ID for the service call
            service_type: Optional service type (e.g., "actuator_interfaces/srv/SetActuator")
        
        Returns:
            Tuple[bool, Dict]: (success, response_data)
        """
        try:
            # Try to create a new connection for each call to avoid broken pipe
            ws = create_connection(self.url, timeout=10)  # Increased timeout
            
            # Determine service type if not provided
            if not service_type and service_name in self.service_types:
                service_type = self.service_types[service_name]
            
            # Prepare service call message
            request = {
                "op": "call_service",
                "service": service_name,
                "args": args
            }
            
            # Add service type if known
            if service_type:
                request["type"] = service_type
                logger.debug(f"Using service type: {service_type}")
            
            if service_id:
                request["id"] = service_id
            
            logger.debug(f"Service call request: {request}")
            
            # Send request
            ws.send(json.dumps(request))
            
            # Get response with longer timeout
            ws.settimeout(10)
            response = ws.recv()
            response_data = json.loads(response)
            
            # Close connection
            ws.close()
            
            logger.debug(f"Service call response: {response_data}")
            
            # Check if response indicates success
            if "result" in response_data and response_data["result"] is True:
                return True, response_data
            elif "values" in response_data:
                # Service call succeeded, return the values
                return True, response_data
            else:
                # Check for error in response
                error_msg = response_data.get("error", response_data.get("msg", "Unknown error"))
                if error_msg:
                    logger.error(f"Service call error: {error_msg}")
                    return False, {"error": error_msg}
                else:
                    # No error but also no clear success indicator
                    return True, response_data
                    
        except Exception as e:
            logger.error(f"Service call failed: {e}")
            return False, {"error": str(e)}
    
    def publish_topic(self, topic_name: str, msg_type: str, msg_data: Dict[str, Any]) -> bool:
        """
        Publish a message to a ROS topic
        
        Args:
            topic_name: Name of the ROS topic (e.g., "/servo_position_cmd")
            msg_type: ROS message type (e.g., "servo_interfaces/msg/ServoPosition")
            msg_data: Message data as dictionary
        
        Returns:
            bool: True if publish successful, False otherwise
        """
        try:
            # Create a new connection for publishing
            ws = create_connection(self.url, timeout=5)
            
            # First advertise the topic
            advertise_msg = {
                "op": "advertise",
                "topic": topic_name,
                "type": msg_type
            }
            ws.send(json.dumps(advertise_msg))
            
            # Then publish the message
            publish_msg = {
                "op": "publish",
                "topic": topic_name,
                "msg": msg_data
            }
            ws.send(json.dumps(publish_msg))
            
            # Close connection
            ws.close()
            
            logger.debug(f"Published to {topic_name}: {msg_data}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to publish to topic {topic_name}: {e}")
            return False
    
    def subscribe_topic(self, topic_name: str, callback=None) -> bool:
        """
        Subscribe to a ROS topic
        
        Args:
            topic_name: Name of the ROS topic
            callback: Function to call when message received
        
        Returns:
            bool: True if subscription successful
        """
        try:
            if not self._connection:
                self.connect()
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": topic_name
            }
            self._connection.send(json.dumps(subscribe_msg))
            
            logger.info(f"Subscribed to topic: {topic_name}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to topic {topic_name}: {e}")
            return False
    
    def test_connection(self) -> bool:
        """
        Test if rosbridge connection is working
        
        Returns:
            bool: True if connection is working
        """
        try:
            temp_conn = create_connection(self.url, timeout=2)
            temp_conn.close()
            return True
        except Exception:
            return False
    
    def send_motor_command(self, channel: str, direction: str, speed: int):
        """
        Send motor command via service call
        
        Args:
            channel: Motor channel ('A' or 'B')
            direction: Motor direction
            speed: Motor speed (PWM value)
        """
        # Map channel to motor IDs
        if channel == 'A':
            motor_ids = [0, 1]  # Motors on channel A
        else:
            motor_ids = [2, 3]  # Motors on channel B
        
        # Send command to each motor on the channel
        for motor_id in motor_ids:
            self.call_service(
                "/set_motor",
                {
                    "motor_id": motor_id,
                    "direction": direction,
                    "speed": speed
                },
                f"motor_cmd_{motor_id}"
            )

class MotorController:
    """High-level motor control interface using ROSBridge"""
    
    def __init__(self, ros_bridge: ROSBridgeConnection):
        """
        Initialize motor controller
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.motor_states = {
            0: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            1: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            2: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            3: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0}
        }
    
    @staticmethod
    def percent_to_pwm(percent: float) -> int:
        """
        Convert percentage (0-100) to PWM value (0-65535)
        
        For dual-PWM motor drivers, use NORMAL mapping:
        - 0% speed → PWM 0 (motor stopped)
        - 100% speed → PWM 65535 (motor full speed)
        
        Note: The previous INVERTED mapping was for different motor drivers
        """
        # Ensure percent is within bounds
        percent = max(0, min(100, percent))
        
        # NORMAL PWM calculation (not inverted)
        # 0% → 0, 100% → 65535
        pwm = int((percent / 100.0) * 65535)
        
        logger.debug(f"Converting {percent}% to PWM: {pwm}")
        return pwm
    
    @staticmethod
    def pwm_to_percent(pwm: int) -> float:
        """
        Convert PWM value (0-65535) to percentage (0-100)
        
        Using NORMAL mapping:
        - PWM 0 = 0% speed
        - PWM 65535 = 100% speed
        """
        # NORMAL calculation (not inverted)
        return round((pwm / 65535.0) * 100, 1)
    
    def set_motor(self, motor_id: int, direction: str, speed_percent: float) -> Dict[str, Any]:
        """
        Set motor speed and direction
        
        Args:
            motor_id: Motor ID (0-3)
            direction: Direction ("forward", "backward", "brake")
            speed_percent: Speed in percentage (0-100)
        
        Returns:
            Dict containing operation result
        """
        # Validate inputs
        if motor_id < 0 or motor_id > 3:
            return {
                "success": False,
                "error": "Invalid motor ID. Must be 0-3"
            }
        
        if direction not in ["forward", "backward", "brake"]:
            return {
                "success": False,
                "error": "Invalid direction. Must be 'forward', 'backward', or 'brake'"
            }
        
        if not isinstance(speed_percent, (int, float)) or speed_percent < 0 or speed_percent > 100:
            return {
                "success": False,
                "error": "Invalid speed. Must be 0-100"
            }
        
        # Convert to PWM with NORMAL mapping
        if direction == "brake":
            # Brake always uses PWM 0
            speed_pwm = 0
        else:
            # Use normal PWM mapping: 0% = PWM 0, 100% = PWM 65535
            speed_pwm = self.percent_to_pwm(speed_percent)
        
        # Call ROS service (connection is handled in call_service)
        service_args = {
            "motor_id": motor_id,
            "direction": direction,
            "speed": speed_pwm
        }
        
        logger.info(f"Sending to ROS - Motor: {motor_id}, Direction: {direction}, Speed: {speed_percent}% (PWM: {speed_pwm})")
        
        success, response = self.ros_bridge.call_service(
            "/set_motor", 
            service_args,
            f"motor_cmd_{motor_id}"
        )
        
        if success:
            # Update internal state
            self.motor_states[motor_id] = {
                "direction": direction,
                "speed_percent": speed_percent,
                "speed_pwm": speed_pwm
            }
            
            logger.info(f"Motor {motor_id} set to {direction} at {speed_percent}% (PWM: {speed_pwm})")
            
            return {
                "success": True,
                "motor_id": motor_id,
                "direction": direction,
                "speed_percent": speed_percent,
                "speed_pwm": speed_pwm,
                "response": response
            }
        else:
            return {
                "success": False,
                "error": response.get("error", "Unknown error"),
                "motor_id": motor_id
            }
    
    def stop_all_motors(self) -> Dict[str, Any]:
        """
        Emergency stop - brake all motors
        
        Returns:
            Dict containing results for all motors
        """
        results = []
        
        for motor_id in range(4):
            # Brake with speed 0
            result = self.set_motor(motor_id, "brake", 0)
            results.append(result)
        
        all_success = all(r["success"] for r in results)
        
        return {
            "success": all_success,
            "results": results
        }
    
    def get_motor_state(self, motor_id: int) -> Optional[Dict[str, Any]]:
        """
        Get current state of a motor
        
        Args:
            motor_id: Motor ID (0-3)
        
        Returns:
            Dict with motor state or None if invalid ID
        """
        if motor_id in self.motor_states:
            return self.motor_states[motor_id].copy()
        return None
    
    def get_all_motor_states(self) -> Dict[int, Dict[str, Any]]:
        """Get current state of all motors"""
        return self.motor_states.copy()

class ServoPublisher:
    """High-level servo control interface using ROSBridge"""
    
    def __init__(self, ros_bridge: ROSBridgeConnection):
        """
        Initialize servo publisher
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.topic_name = "/servo_position_cmd"
        self.msg_type = "servo_interfaces/msg/ServoPosition"
    
    def publish_position(self, pan_angle: float, tilt_angle: float) -> bool:
        """
        Publish servo position command
        
        Args:
            pan_angle: Pan servo angle (75-195 degrees)
            tilt_angle: Tilt servo angle (75-195 degrees)
        
        Returns:
            bool: True if successful
        """
        # Prepare message
        msg_data = {
            "pan_angle": pan_angle,
            "tilt_angle": tilt_angle
        }
        
        # Publish to topic
        success = self.ros_bridge.publish_topic(
            self.topic_name,
            self.msg_type,
            msg_data
        )
        
        if success:
            logger.info(f"Published servo position: pan={pan_angle}, tilt={tilt_angle}")
        else:
            logger.error(f"Failed to publish servo position")
        
        return success

# Create singleton instances for easy import
_ros_bridge = None
_motor_controller = None
_servo_publisher = None

def get_ros_bridge(host: str = None, port: int = None) -> ROSBridgeConnection:
    """Get or create ROSBridge connection instance"""
    global _ros_bridge
    
    # If host/port provided, update or create new connection
    if host is not None or port is not None:
        if _ros_bridge:
            # Update existing connection
            if host:
                _ros_bridge.host = host
                _ros_bridge.url = f"ws://{host}:{_ros_bridge.port}"
            if port:
                _ros_bridge.port = port
                _ros_bridge.url = f"ws://{_ros_bridge.host}:{port}"
        else:
            # Create new connection with provided settings
            _ros_bridge = ROSBridgeConnection(
                host or "192.168.2.4", 
                port or 9090
            )
    elif _ros_bridge is None:
        # Create with defaults if not exists
        _ros_bridge = ROSBridgeConnection()
    
    return _ros_bridge

def get_motor_controller() -> MotorController:
    """Get or create MotorController instance"""
    global _motor_controller
    if _motor_controller is None:
        _motor_controller = MotorController(get_ros_bridge())
    return _motor_controller

def get_servo_publisher() -> ServoPublisher:
    """Get or create ServoPublisher instance"""
    global _servo_publisher
    if _servo_publisher is None:
        _servo_publisher = ServoPublisher(get_ros_bridge())
    return _servo_publisher

# Convenience function for servo control to match the expected interface
async def publish_servo_position(pan_angle: float, tilt_angle: float) -> bool:
    """
    Publish servo position (async wrapper for compatibility)
    
    Args:
        pan_angle: Pan servo angle
        tilt_angle: Tilt servo angle
    
    Returns:
        bool: Success status
    """
    servo_pub = get_servo_publisher()
    return servo_pub.publish_position(pan_angle, tilt_angle)
================================================================================


================================================================================
FILE: backend/sensors/__init__.py
Category: Python | Size: 390.0 B | Lines: 16
================================================================================
"""
Sensor modules for ROS 2 robot
"""

from .lidar import LidarSensor, get_lidar_sensor
from .thermal_camera import ThermalCameraSensor, get_thermal_camera_sensor
from .system_monitor import SystemMonitor, get_system_monitor

__all__ = [
    'LidarSensor',
    'get_lidar_sensor',
    'ThermalCameraSensor',
    'get_thermal_camera_sensor',
    'SystemMonitor',
    'get_system_monitor',
]
================================================================================


================================================================================
FILE: backend/sensors/lidar.py
Category: Python | Size: 8.0 KB | Lines: 243
================================================================================
#!/usr/bin/env python3
"""
Lidar sensor module for ROS 2
Handles lidar data subscription and processing
"""

import json
import logging
import threading
import time
from typing import Dict, Any, Optional, Callable, List
import numpy as np
from websocket import create_connection

logger = logging.getLogger(__name__)

class LidarSensor:
    """Subscribe to and process lidar scan data via ROSBridge"""
    
    def __init__(self, ros_bridge):
        """
        Initialize lidar sensor
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.scan_callback = None
        self.latest_scan = None
        self.subscription_active = False
        self._ws = None
        self._ws_thread = None
        self._stop_thread = False
        
    def subscribe(self, callback: Optional[Callable] = None, 
                 processed_data: bool = True) -> bool:
        """
        Subscribe to /scan topic
        
        Args:
            callback: Optional callback function for new scan data
            processed_data: If True, return processed data; if False, return raw
        
        Returns:
            bool: Success status
        """
        try:
            # Create a dedicated connection for subscription
            self._ws = create_connection(self.ros_bridge.url, timeout=5)
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": "/scan",
                "type": "sensor_msgs/LaserScan"
            }
            
            self._ws.send(json.dumps(subscribe_msg))
            logger.info("Subscribed to /scan topic")
            
            # Start receiving thread
            self.subscription_active = True
            self._stop_thread = False
            self._ws_thread = threading.Thread(
                target=self._receive_scan_data, 
                args=(callback, processed_data)
            )
            self._ws_thread.daemon = True
            self._ws_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to scan: {e}")
            return False
    
    def _receive_scan_data(self, callback, processed_data):
        """Receive scan data in separate thread"""
        while self.subscription_active and not self._stop_thread:
            try:
                response = self._ws.recv()
                data = json.loads(response)
                
                if data.get("op") == "publish" and data.get("topic") == "/scan":
                    msg = data["msg"]
                    
                    if processed_data:
                        # Process the data for easier use
                        processed = self._process_scan_data(msg)
                        self.latest_scan = processed
                        
                        if callback:
                            callback(processed)
                    else:
                        # Return raw data
                        self.latest_scan = msg
                        
                        if callback:
                            callback(msg)
                            
            except Exception as e:
                if self.subscription_active:
                    logger.error(f"Error receiving scan data: {e}")
                break
        
        if self._ws:
            self._ws.close()
        logger.info("Scan subscription thread ended")
    
    def _process_scan_data(self, scan_msg: Dict) -> Dict[str, Any]:
        """
        Process raw scan data into more useful format
        
        Args:
            scan_msg: Raw LaserScan message
            
        Returns:
            Dict with processed data including points for visualization
        """
        ranges = scan_msg["ranges"]
        angle_min = scan_msg["angle_min"]
        angle_increment = scan_msg["angle_increment"]
        
        # Filter out invalid readings (0.0 or inf)
        valid_ranges = [(i, r) for i, r in enumerate(ranges) 
                       if r > 0.1 and r < 10.0]
        
        if not valid_ranges:
            return {
                "min_distance": float('inf'),
                "min_angle": 0,
                "obstacles": [],
                "safe_directions": ["all"],
                "points": [],
                "timestamp": time.time(),
                "point_count": 0
            }
        
        # Find minimum distance
        min_idx, min_dist = min(valid_ranges, key=lambda x: x[1])
        min_angle = angle_min + min_idx * angle_increment
        
        # Convert to cartesian coordinates for visualization
        points = []
        obstacles = []
        
        for idx, dist in valid_ranges:
            angle = angle_min + idx * angle_increment
            x = dist * np.cos(angle)
            y = dist * np.sin(angle)
            
            points.append({
                "x": float(x),
                "y": float(y),
                "r": float(dist),
                "theta": float(angle),
                "theta_deg": float(np.degrees(angle))
            })
            
            # Detect obstacles (anything closer than 0.5m)
            if dist < 0.5:
                obstacles.append({
                    "angle": float(angle),
                    "angle_deg": float(np.degrees(angle)),
                    "distance": float(dist),
                    "x": float(x),
                    "y": float(y)
                })
        
        # Determine safe directions
        safe_directions = self._calculate_safe_directions(valid_ranges, angle_min, angle_increment)
        
        return {
            "min_distance": float(min_dist),
            "min_angle": float(min_angle),
            "min_angle_deg": float(np.degrees(min_angle)),
            "obstacles": obstacles,
            "safe_directions": safe_directions,
            "obstacle_count": len(obstacles),
            "points": points,
            "point_count": len(points),
            "timestamp": time.time()
        }
    
    def _calculate_safe_directions(self, valid_ranges, angle_min, angle_increment):
        """Calculate safe movement directions based on scan data"""
        safe_directions = []
        
        # Check sectors (front, left, right, back)
        sectors = {
            "front": (-30, 30),
            "left": (60, 120),
            "right": (-120, -60),
            "back": (150, 180)  # and (-180, -150)
        }
        
        for direction, (start_deg, end_deg) in sectors.items():
            start_rad = np.radians(start_deg)
            end_rad = np.radians(end_deg)
            
            # Check if sector is clear
            sector_clear = True
            for idx, dist in valid_ranges:
                angle = angle_min + idx * angle_increment
                
                # Handle back sector wraparound
                if direction == "back":
                    if (angle > np.radians(150) or angle < np.radians(-150)):
                        if dist < 0.5:
                            sector_clear = False
                            break
                else:
                    if start_rad <= angle <= end_rad and dist < 0.5:
                        sector_clear = False
                        break
            
            if sector_clear:
                safe_directions.append(direction)
        
        return safe_directions
    
    def get_latest_scan(self) -> Optional[Dict[str, Any]]:
        """Get the most recent scan data"""
        return self.latest_scan
    
    def unsubscribe(self):
        """Stop subscription"""
        self.subscription_active = False
        self._stop_thread = True
        if self._ws_thread:
            self._ws_thread.join(timeout=2)
        logger.info("Unsubscribed from scan topic")

# Singleton instance
_lidar_sensor = None

def get_lidar_sensor():
    """Get or create LidarSensor instance"""
    global _lidar_sensor
    if _lidar_sensor is None:
        from backend.ros_bridge import get_ros_bridge
        _lidar_sensor = LidarSensor(get_ros_bridge())
    return _lidar_sensor
================================================================================


================================================================================
FILE: backend/sensors/system_monitor.py
Category: Python | Size: 7.5 KB | Lines: 209
================================================================================
#!/usr/bin/env python3
"""
System monitor module for ROS 2
Handles system status subscription and processing
"""

import json
import logging
import threading
import time
from typing import Dict, Any, Optional, Callable
from websocket import create_connection

logger = logging.getLogger(__name__)

class SystemMonitor:
    """Subscribe to and process system monitor data via ROSBridge"""
    
    def __init__(self, ros_bridge):
        """
        Initialize system monitor
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.status_callback = None
        self.latest_status = None
        self.subscription_active = False
        self._ws = None
        self._ws_thread = None
        self._stop_thread = False
        
        # Default values
        self.default_status = {
            "cpu_usage": 0.0,
            "memory_usage": 0.0,
            "disk_usage": 0.0,
            "temperature": 0.0,
            "timestamp": time.time()
        }
        
    def subscribe(self, callback: Optional[Callable] = None) -> bool:
        """
        Subscribe to system status topics
        
        Args:
            callback: Optional callback function for new status data
        
        Returns:
            bool: Success status
        """
        try:
            # Create a dedicated connection for subscription
            self._ws = create_connection(self.ros_bridge.url, timeout=5)
            
            # Subscribe to all system topics
            topics = [
                ("/system/cpu_usage", "std_msgs/Float32"),
                ("/system/memory_usage", "std_msgs/Float32"),
                ("/system/temperature", "sensor_msgs/Temperature"),
                ("/system/status_json", "std_msgs/String")
            ]
            
            for topic, msg_type in topics:
                subscribe_msg = {
                    "op": "subscribe",
                    "topic": topic,
                    "type": msg_type
                }
                self._ws.send(json.dumps(subscribe_msg))
                logger.info(f"Subscribed to {topic}")
            
            # Start receiving thread
            self.subscription_active = True
            self._stop_thread = False
            self._ws_thread = threading.Thread(
                target=self._receive_status_data, 
                args=(callback,)
            )
            self._ws_thread.daemon = True
            self._ws_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to system monitor: {e}")
            return False
    
    def _receive_status_data(self, callback):
        """Receive status data in separate thread"""
        current_status = self.default_status.copy()
        
        while self.subscription_active and not self._stop_thread:
            try:
                response = self._ws.recv()
                data = json.loads(response)
                
                if data.get("op") == "publish":
                    topic = data.get("topic")
                    msg = data.get("msg")
                    
                    # Update status based on topic
                    if topic == "/system/cpu_usage":
                        current_status["cpu_usage"] = msg.get("data", 0.0)
                    elif topic == "/system/memory_usage":
                        current_status["memory_usage"] = msg.get("data", 0.0)
                    elif topic == "/system/temperature":
                        # Temperature message has a different structure
                        current_status["temperature"] = msg.get("temperature", 0.0)
                    elif topic == "/system/status_json":
                        # Parse JSON status if available
                        try:
                            status_data = json.loads(msg.get("data", "{}"))
                            current_status.update(status_data)
                        except:
                            pass
                    
                    # Update timestamp
                    current_status["timestamp"] = time.time()
                    
                    # Process the status data
                    processed = self._process_status_data(current_status)
                    self.latest_status = processed
                    
                    if callback:
                        callback(processed)
                        
            except Exception as e:
                if self.subscription_active:
                    logger.error(f"Error receiving status data: {e}")
                break
        
        if self._ws:
            self._ws.close()
        logger.info("System monitor subscription thread ended")
    
    def _process_status_data(self, status: Dict) -> Dict[str, Any]:
        """
        Process raw status data for easier use
        
        Args:
            status: Raw status data
            
        Returns:
            Dict with processed data
        """
        return {
            "cpu_usage": round(status.get("cpu_usage", 0.0), 1),
            "memory_usage": round(status.get("memory_usage", 0.0), 1),
            "disk_usage": round(status.get("disk_usage", 0.0), 1),
            "temperature": round(status.get("temperature", 0.0), 1),
            "cpu_percent": f"{round(status.get('cpu_usage', 0.0), 1)}%",
            "memory_percent": f"{round(status.get('memory_usage', 0.0), 1)}%",
            "disk_percent": f"{round(status.get('disk_usage', 0.0), 1)}%",
            "temp_celsius": f"{round(status.get('temperature', 0.0), 1)}°C",
            "timestamp": status.get("timestamp", time.time()),
            "healthy": status.get("cpu_usage", 0) < 80 and status.get("temperature", 0) < 70
        }
    
    def get_latest_status(self) -> Optional[Dict[str, Any]]:
        """Get the most recent system status"""
        return self.latest_status
    
    def get_status_once(self) -> Optional[Dict[str, Any]]:
        """Request system status via service calls (if available)"""
        try:
            # Try to get status from service
            success, response = self.ros_bridge.call_service(
                "/get_system_status",
                {},
                "get_system_status"
            )
            
            if success and response.get("values"):
                status_data = response["values"]
                return self._process_status_data({
                    "cpu_usage": status_data.get("cpu_usage", 0.0),
                    "memory_usage": status_data.get("memory_usage", 0.0),
                    "disk_usage": status_data.get("disk_usage", 0.0),
                    "temperature": status_data.get("temperature", 0.0),
                    "timestamp": time.time()
                })
            else:
                logger.error("Failed to get system status via service")
                return None
                
        except Exception as e:
            logger.error(f"Error calling system status service: {e}")
            return None
    
    def unsubscribe(self):
        """Stop subscription"""
        self.subscription_active = False
        self._stop_thread = True
        if self._ws_thread:
            self._ws_thread.join(timeout=2)
        logger.info("Unsubscribed from system monitor")

# Singleton instance
_system_monitor = None

def get_system_monitor():
    """Get or create SystemMonitor instance"""
    global _system_monitor
    if _system_monitor is None:
        from backend.ros_bridge import get_ros_bridge
        _system_monitor = SystemMonitor(get_ros_bridge())
    return _system_monitor
================================================================================


================================================================================
FILE: backend/sensors/thermal_camera.py
Category: Python | Size: 7.7 KB | Lines: 222
================================================================================
#!/usr/bin/env python3
"""
Thermal camera sensor module for MLX90640
Handles thermal data subscription and processing
"""

import json
import logging
import threading
import time
from typing import Dict, Any, Optional, Callable
import numpy as np
from websocket import create_connection

logger = logging.getLogger(__name__)

class ThermalCameraSensor:
    """Subscribe to and process thermal camera data via ROSBridge"""
    
    def __init__(self, ros_bridge):
        """
        Initialize thermal camera sensor
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.thermal_callback = None
        self.latest_frame = None
        self.subscription_active = False
        self._ws = None
        self._ws_thread = None
        self._stop_thread = False
        
    def subscribe(self, callback: Optional[Callable] = None) -> bool:
        """
        Subscribe to /thermal_frame topic
        
        Args:
            callback: Optional callback function for new thermal data
        
        Returns:
            bool: Success status
        """
        try:
            # Create a dedicated connection for subscription
            self._ws = create_connection(self.ros_bridge.url, timeout=5)
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": "/thermal_frame",
                "type": "mlx90640_interfaces/ThermalFrame"
            }
            
            self._ws.send(json.dumps(subscribe_msg))
            logger.info("Subscribed to /thermal_frame topic")
            
            # Start receiving thread
            self.subscription_active = True
            self._stop_thread = False
            self._ws_thread = threading.Thread(
                target=self._receive_thermal_data, 
                args=(callback,)
            )
            self._ws_thread.daemon = True
            self._ws_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to thermal camera: {e}")
            return False
    
    def _receive_thermal_data(self, callback):
        """Receive thermal data in separate thread"""
        while self.subscription_active and not self._stop_thread:
            try:
                response = self._ws.recv()
                data = json.loads(response)
                
                if data.get("op") == "publish" and data.get("topic") == "/thermal_frame":
                    msg = data["msg"]
                    
                    # Process the thermal frame data
                    processed = self._process_thermal_data(msg)
                    self.latest_frame = processed
                    
                    if callback:
                        callback(processed)
                        
            except Exception as e:
                if self.subscription_active:
                    logger.error(f"Error receiving thermal data: {e}")
                break
        
        if self._ws:
            self._ws.close()
        logger.info("Thermal camera subscription thread ended")
    
    def _process_thermal_data(self, frame_msg: Dict) -> Dict[str, Any]:
        """
        Process raw thermal frame data for visualization
        
        Args:
            frame_msg: Raw ThermalFrame message
            
        Returns:
            Dict with processed data including heatmap
        """
        try:
            # Extract frame data
            width = frame_msg.get("width", 32)
            height = frame_msg.get("height", 24)
            data = frame_msg.get("data", [])
            
            # Reshape to 2D array
            thermal_array = np.array(data).reshape((height, width))
            
            # Calculate temperature ranges for better visualization
            min_temp = frame_msg.get("min_temp", 20.0)
            max_temp = frame_msg.get("max_temp", 30.0)
            avg_temp = frame_msg.get("avg_temp", 25.0)
            center_temp = frame_msg.get("center_temp", 25.0)
            
            # Normalize data to 0-255 for color mapping
            if max_temp > min_temp:
                normalized = ((thermal_array - min_temp) / (max_temp - min_temp) * 255).astype(np.uint8)
            else:
                normalized = np.full((height, width), 128, dtype=np.uint8)
            
            # Find hotspots (temperatures above average + threshold)
            threshold = (max_temp - min_temp) * 0.7 + min_temp
            hotspots = []
            for y in range(height):
                for x in range(width):
                    if thermal_array[y, x] > threshold:
                        hotspots.append({
                            "x": x,
                            "y": y,
                            "temp": float(thermal_array[y, x])
                        })
            
            # Convert to list for JSON serialization
            thermal_list = thermal_array.tolist()
            normalized_list = normalized.tolist()
            
            return {
                "width": width,
                "height": height,
                "thermal_data": thermal_list,
                "normalized_data": normalized_list,
                "min_temp": min_temp,
                "max_temp": max_temp,
                "avg_temp": avg_temp,
                "center_temp": center_temp,
                "frame_count": frame_msg.get("frame_count", 0),
                "hotspots": hotspots,
                "hotspot_count": len(hotspots),
                "timestamp": time.time()
            }
            
        except Exception as e:
            logger.error(f"Error processing thermal data: {e}")
            return {
                "width": 32,
                "height": 24,
                "thermal_data": [[20.0] * 32 for _ in range(24)],
                "normalized_data": [[128] * 32 for _ in range(24)],
                "min_temp": 20.0,
                "max_temp": 30.0,
                "avg_temp": 25.0,
                "center_temp": 25.0,
                "frame_count": 0,
                "hotspots": [],
                "hotspot_count": 0,
                "timestamp": time.time()
            }
    
    def get_latest_frame(self) -> Optional[Dict[str, Any]]:
        """Get the most recent thermal frame data"""
        return self.latest_frame
    
    def get_thermal_frame_once(self) -> Optional[Dict[str, Any]]:
        """Request a single thermal frame via service call"""
        try:
            # Call the get_thermal_frame service
            success, response = self.ros_bridge.call_service(
                "/get_thermal_frame",
                {},
                "get_thermal_frame"
            )
            
            if success and response.get("values", {}).get("success"):
                frame_data = response["values"]["frame"]
                return self._process_thermal_data(frame_data)
            else:
                logger.error("Failed to get thermal frame via service")
                return None
                
        except Exception as e:
            logger.error(f"Error calling thermal frame service: {e}")
            return None
    
    def unsubscribe(self):
        """Stop subscription"""
        self.subscription_active = False
        self._stop_thread = True
        if self._ws_thread:
            self._ws_thread.join(timeout=2)
        logger.info("Unsubscribed from thermal camera topic")

# Singleton instance
_thermal_camera_sensor = None

def get_thermal_camera_sensor():
    """Get or create ThermalCameraSensor instance"""
    global _thermal_camera_sensor
    if _thermal_camera_sensor is None:
        from backend.ros_bridge import get_ros_bridge
        _thermal_camera_sensor = ThermalCameraSensor(get_ros_bridge())
    return _thermal_camera_sensor
================================================================================


================================================================================
FILE: run.py
Category: Python | Size: 341.0 B | Lines: 16
================================================================================
#!/usr/bin/env python3
"""
Main entry point for the ROS 2 Motor Control application
Run this file to start the Flask backend server
"""

import sys
from pathlib import Path

# Add the current directory to Python path
sys.path.insert(0, str(Path(__file__).parent))

from backend.host_backend import main

if __name__ == '__main__':
    main()
================================================================================


================================================================================
FILE: frontend/templates/aiming_system.html
Category: Web | Size: 41.6 KB | Lines: 1223
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aiming System - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 40px 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .section-title {
            font-size: 2em;
            font-weight: 500;
            color: #00aaff;
            margin: 40px 0 20px 0;
            text-align: center;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin-bottom: 40px;
        }

        .servo-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 400px;
        }

        .servo-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
        }

        .servo-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .servo-title {
            font-size: 1.5em;
            font-weight: 500;
            color: #00aaff;
        }

        .servo-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            background: #333;
            color: #888;
            transition: all 0.3s ease;
        }

        .servo-status.active {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .angle-control {
            margin-top: auto;
        }

        .angle-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            color: #aaa;
        }

        .angle-value {
            font-size: 2.5em;
            font-weight: 700;
            color: #00ff88;
            min-width: 120px;
            text-align: right;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .angle-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            transition: all 0.3s ease;
        }

        /* Add tick marks for discrete positions */
        .angle-slider {
            background-image: linear-gradient(to right, 
                #444 0%, #444 1px,
                transparent 1px, transparent 20%,
                #444 20%, #444 21%,
                transparent 21%, transparent 40%,
                #444 40%, #444 41%,
                transparent 41%, transparent 60%,
                #444 60%, #444 61%,
                transparent 61%, transparent 80%,
                #444 80%, #444 81%,
                transparent 81%, transparent 99%,
                #444 99%, #444 100%
            );
            background-size: 100% 100%;
            background-repeat: no-repeat;
        }

        .angle-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .angle-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.7);
        }

        .angle-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .angle-marks {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            padding: 0 12px;
        }

        .angle-mark {
            font-size: 0.75em;
            color: #666;
            text-align: center;
            position: relative;
        }

        .preset-panel {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            text-align: center;
        }

        .preset-title {
            font-size: 1.5em;
            font-weight: 500;
            color: #00aaff;
            margin-bottom: 30px;
        }

        .preset-btn {
            padding: 15px 25px;
            margin: 8px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 120px;
        }

        .preset-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .center-btn {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            font-size: 1.2em;
            padding: 20px 40px;
            min-width: 150px;
        }

        .center-btn:hover {
            background: linear-gradient(135deg, #ff5555, #dd1111);
            box-shadow: 0 5px 20px rgba(255, 68, 68, 0.4);
        }

        .visualization-panel {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
        }

        .servo-visual {
            width: 300px;
            height: 300px;
            margin: 0 auto 20px;
            position: relative;
            background: radial-gradient(circle at center, #1a1a1a 0%, #0a0a0a 100%);
            border: 2px solid #333;
            border-radius: 15px;
            overflow: hidden;
        }

        .grid-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .safe-zone {
            position: absolute;
            border: 2px dashed #00ff88;
            border-radius: 10px;
            top: 16.67%;
            left: 16.67%;
            width: 66.66%;
            height: 66.66%;
            opacity: 0.3;
        }

        .crosshair {
            position: absolute;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }

        .crosshair::before {
            width: 100%;
            height: 2px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        .crosshair::after {
            width: 2px;
            height: 100%;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair-center {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #00ff88;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        /* Actuator Control Styles */
        .actuator-section {
            margin-top: 60px;
        }

        .actuator-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            margin-bottom: 30px;
        }

        .actuator-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .actuator-title {
            font-size: 1.8em;
            font-weight: 500;
            color: #ff6b6b;
        }

        .actuator-status {
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 1em;
            background: #333;
            color: #888;
            transition: all 0.3s ease;
        }

        .actuator-status.extending {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .actuator-status.retracting {
            background: rgba(255, 170, 0, 0.2);
            color: #ffaa00;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.3);
        }

        .actuator-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .actuator-btn {
            padding: 20px;
            border: none;
            border-radius: 15px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .actuator-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        }

        .actuator-btn.extend {
            background: linear-gradient(135deg, #00ff88, #00cc66);
        }

        .actuator-btn.extend:hover {
            box-shadow: 0 8px 20px rgba(0, 255, 136, 0.4);
        }

        .actuator-btn.retract {
            background: linear-gradient(135deg, #ffaa00, #ff8800);
        }

        .actuator-btn.retract:hover {
            box-shadow: 0 8px 20px rgba(255, 170, 0, 0.4);
        }

        .actuator-btn.stop {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .actuator-btn.stop:hover {
            box-shadow: 0 8px 20px rgba(255, 68, 68, 0.4);
        }

        .actuator-icon {
            font-size: 2em;
        }

        .speed-duration-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #252525;
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #333;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            color: #aaa;
            font-size: 1.1em;
        }

        .control-value {
            font-size: 1.5em;
            font-weight: 600;
            color: #ff6b6b;
        }

        .speed-slider, .duration-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            transition: all 0.3s ease;
        }

        .speed-slider::-webkit-slider-thumb,
        .duration-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff6b6b, #ff4444);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
            transition: all 0.3s ease;
        }

        .speed-slider::-webkit-slider-thumb:hover,
        .duration-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.7);
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
        }

        .preset-actuator-btn {
            padding: 15px 10px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            font-weight: 500;
            text-align: center;
        }

        .preset-actuator-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .log-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            border: 1px solid #333;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            background: #252525;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #aaa;
            border-left: 3px solid #444;
        }

        .log-entry.success {
            border-left-color: #00ff88;
            color: #00ff88;
        }

        .log-entry.error {
            border-left-color: #ff4444;
            color: #ff6666;
        }

        @media (max-width: 1200px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .actuator-controls {
                grid-template-columns: 1fr;
            }
            
            .speed-duration-controls {
                grid-template-columns: 1fr;
            }
            
            .preset-buttons {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .servo-visual {
                width: 250px;
                height: 250px;
            }
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>Aiming System Control Panel</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span>Servo Connection:</span>
            <div class="status-indicator" id="servoConnectionStatus"></div>
            <span id="servoStatusText">Disconnected</span>
        </div>
        <div class="status-item" style="margin-left: 30px;">
            <span>Actuator Connection:</span>
            <div class="status-indicator" id="actuatorConnectionStatus"></div>
            <span id="actuatorStatusText">Disconnected</span>
        </div>
    </div>

    <div class="main-container">
        <!-- Servo Control Section -->
        <h2 class="section-title">Servo Aiming Control</h2>
        
        <div class="controls-grid">
            <!-- Pan Control -->
            <div class="servo-card">
                <div class="servo-header">
                    <h2 class="servo-title">Pan Control (Horizontal)</h2>
                    <span class="servo-status" id="panStatus">IDLE</span>
                </div>
                <div class="angle-control">
                    <div class="angle-label">
                        <span>Angle Control</span>
                        <span class="angle-value" id="panValue">135°</span>
                    </div>
                    <input type="range" class="angle-slider" id="panSlider" 
                           min="75" max="195" value="135" step="30">
                    <div class="angle-marks">
                        <span class="angle-mark">75°<br>Left</span>
                        <span class="angle-mark">105°</span>
                        <span class="angle-mark">135°<br>Center</span>
                        <span class="angle-mark">165°</span>
                        <span class="angle-mark">195°<br>Right</span>
                    </div>
                </div>
            </div>

            <!-- Tilt Control -->
            <div class="servo-card">
                <div class="servo-header">
                    <h2 class="servo-title">Tilt Control (Vertical)</h2>
                    <span class="servo-status" id="tiltStatus">IDLE</span>
                </div>
                <div class="angle-control">
                    <div class="angle-label">
                        <span>Angle Control</span>
                        <span class="angle-value" id="tiltValue">135°</span>
                    </div>
                    <input type="range" class="angle-slider" id="tiltSlider" 
                           min="75" max="195" value="135" step="30">
                    <div class="angle-marks">
                        <span class="angle-mark">75°<br>Down</span>
                        <span class="angle-mark">105°</span>
                        <span class="angle-mark">135°<br>Center</span>
                        <span class="angle-mark">165°</span>
                        <span class="angle-mark">195°<br>Up</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Preset Controls -->
        <div class="preset-panel">
            <h2 class="preset-title">Quick Position Presets</h2>
            <div style="margin-bottom: 20px;">
                <button class="preset-btn" onclick="moveToPreset(135, 195)">↑ UP</button>
            </div>
            <div style="margin-bottom: 20px;">
                <button class="preset-btn" onclick="moveToPreset(75, 135)">← LEFT</button>
                <button class="preset-btn center-btn" onclick="moveToCenter()">CENTER</button>
                <button class="preset-btn" onclick="moveToPreset(195, 135)">RIGHT →</button>
            </div>
            <div>
                <button class="preset-btn" onclick="moveToPreset(135, 75)">↓ DOWN</button>
            </div>
        </div>

        <!-- Visualization -->
        <div class="visualization-panel" style="margin-top: 30px;">
            <h2 class="servo-title" style="text-align: center; margin-bottom: 20px;">Position Visualization</h2>
            <div class="servo-visual">
                <div class="grid-lines"></div>
                <div class="safe-zone"></div>
                <div class="crosshair" id="crosshair" style="left: 50%; top: 50%;">
                    <div class="crosshair-center"></div>
                </div>
            </div>
        </div>

        <!-- Actuator Control Section -->
        <div class="actuator-section">
            <h2 class="section-title">Fire Extinguisher Trigger Control</h2>
            
            <div class="actuator-card">
                <div class="actuator-header">
                    <h3 class="actuator-title">Linear Actuator Control</h3>
                    <span class="actuator-status" id="actuatorStatus">STOPPED</span>
                </div>

                <!-- Main Control Buttons -->
                <div class="actuator-controls">
                    <button class="actuator-btn extend" onclick="actuatorControl('extend')">
                        <span class="actuator-icon">↑</span>
                        <span>EXTEND</span>
                    </button>
                    <button class="actuator-btn stop" onclick="actuatorControl('stop')">
                        <span class="actuator-icon">■</span>
                        <span>STOP</span>
                    </button>
                    <button class="actuator-btn retract" onclick="actuatorControl('retract')">
                        <span class="actuator-icon">↓</span>
                        <span>RETRACT</span>
                    </button>
                </div>

                <!-- Speed and Duration Controls -->
                <div class="speed-duration-controls">
                    <div class="control-group">
                        <div class="control-label">
                            <span>Speed Control</span>
                            <span class="control-value" id="speedValue">100%</span>
                        </div>
                        <input type="range" class="speed-slider" id="speedSlider" 
                               min="0" max="100" value="100" step="25">
                        <div class="speed-marks">
                            <span style="float: left; color: #666; font-size: 0.8em;">0%</span>
                            <span style="float: right; color: #666; font-size: 0.8em;">100%</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            <span>Duration (0 = Continuous)</span>
                            <span class="control-value" id="durationValue">0s</span>
                        </div>
                        <input type="range" class="duration-slider" id="durationSlider" 
                               min="0" max="10" value="0" step="0.5">
                        <div class="speed-marks">
                            <span style="float: left; color: #666; font-size: 0.8em;">0s</span>
                            <span style="float: right; color: #666; font-size: 0.8em;">10s</span>
                        </div>
                    </div>
                </div>

                <!-- Preset Buttons -->
                <div class="preset-panel" style="margin-top: 20px;">
                    <h3 style="color: #ff6b6b; margin-bottom: 15px;">Quick Presets</h3>
                    <div class="preset-buttons">
                        <button class="preset-actuator-btn" onclick="actuatorPreset('extend', 100, 1)">
                            Extend 1s
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('extend', 100, 3)">
                            Extend 3s
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('retract', 100, 1)">
                            Retract 1s
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('retract', 100, 3)">
                            Retract 3s
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('extend', 50, 0)">
                            Slow Extend
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('retract', 50, 0)">
                            Slow Retract
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('extend', 100, 5)">
                            Full Deploy
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('retract', 100, 5)">
                            Full Retract
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <h3 style="margin-bottom: 10px; color: #888;">Activity Log</h3>
            <div id="logContainer"></div>
        </div>
    </div>

    <script>
        let socket = null;
        let isConnected = false;
        let isUpdatingFromServer = false;
        let currentPanValue = 135;
        let currentTiltValue = 135;
        let actuatorState = 'stopped';

        // Add log entry
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // Keep only last 10 entries
            while (logContainer.children.length > 10) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Initialize Socket.IO connection
        function connectWebSocket() {
            socket = io();

            socket.on('connect', function() {
                console.log('Socket.IO connected');
                isConnected = true;
                
                // Check both connections
                checkActuatorConnection().then(actuatorConnected => {
                    updateConnectionStatus(true, actuatorConnected);
                });
                
                addLog('Connected to servo controller', 'success');
                
                // Request initial servo state
                socket.emit('request_servo_state');
            });

            socket.on('servo_state', function(data) {
                updateServoState(data);
            });

            socket.on('servo_response', function(data) {
                console.log('Servo response:', data);
                if (data.result && !data.result.success) {
                    addLog(`Error: ${data.result.error}`, 'error');
                }
            });

            socket.on('servo_error', function(data) {
                console.error('Servo error:', data);
                addLog(`Error: ${data.error}`, 'error');
            });

            socket.on('disconnect', function() {
                console.log('Socket.IO disconnected');
                isConnected = false;
                updateConnectionStatus(false, false);
                addLog('Connection lost - Reconnecting...', 'error');
            });

            socket.on('connect_error', function(error) {
                console.error('Socket.IO connection error:', error);
                updateConnectionStatus(false, false);
            });
        }

        // Update connection status display
        function updateConnectionStatus(servoConnected, actuatorConnected) {
            const servoIndicator = document.getElementById('servoConnectionStatus');
            const servoText = document.getElementById('servoStatusText');
            const actuatorIndicator = document.getElementById('actuatorConnectionStatus');
            const actuatorText = document.getElementById('actuatorStatusText');
            
            if (servoConnected) {
                servoIndicator.classList.add('connected');
                servoText.textContent = 'Connected';
            } else {
                servoIndicator.classList.remove('connected');
                servoText.textContent = 'Disconnected';
            }
            
            if (actuatorConnected) {
                actuatorIndicator.classList.add('connected');
                actuatorText.textContent = 'Connected';
            } else {
                actuatorIndicator.classList.remove('connected');
                actuatorText.textContent = 'Disconnected';
            }
        }
        
        // Check actuator connection status
        async function checkActuatorConnection() {
            try {
                const response = await fetch('/api/actuator/status');
                const data = await response.json();
                
                if (data.success && data.state) {
                    return data.state.connected;
                }
                return false;
            } catch (error) {
                console.error('Failed to check actuator status:', error);
                return false;
            }
        }

        // Update servo state from WebSocket data
        function updateServoState(data) {
            isUpdatingFromServer = true;
            
            // Store current values
            currentPanValue = Math.round(data.pan_angle);
            currentTiltValue = Math.round(data.tilt_angle);
            
            // Update displays
            document.getElementById('panValue').textContent = `${currentPanValue}°`;
            document.getElementById('tiltValue').textContent = `${currentTiltValue}°`;
            
            // Update status
            const panStatus = document.getElementById('panStatus');
            const tiltStatus = document.getElementById('tiltStatus');
            
            if (data.pan_moving) {
                panStatus.textContent = 'MOVING';
                panStatus.classList.add('active');
            } else {
                panStatus.textContent = 'IDLE';
                panStatus.classList.remove('active');
            }
            
            if (data.tilt_moving) {
                tiltStatus.textContent = 'MOVING';
                tiltStatus.classList.add('active');
            } else {
                tiltStatus.textContent = 'IDLE';
                tiltStatus.classList.remove('active');
            }
            
            // Update sliders only if not being manipulated by user
            const panSlider = document.getElementById('panSlider');
            const tiltSlider = document.getElementById('tiltSlider');
            
            if (!panSlider.matches(':active') && !panSlider.matches(':focus')) {
                panSlider.value = currentPanValue;
                updateSliderBackground('panSlider', currentPanValue);
            }
            
            if (!tiltSlider.matches(':active') && !tiltSlider.matches(':focus')) {
                tiltSlider.value = currentTiltValue;
                updateSliderBackground('tiltSlider', currentTiltValue);
            }
            
            // Update visualization
            updateCrosshair(currentPanValue, currentTiltValue);
            
            isUpdatingFromServer = false;
        }

        // Update slider background
        function updateSliderBackground(sliderId, value) {
            const slider = document.getElementById(sliderId);
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const percentage = ((value - min) / (max - min)) * 100;
            slider.style.background = `linear-gradient(to right, #00ff88 ${percentage}%, #2a2a2a ${percentage}%)`;
        }

        // Update crosshair position
        function updateCrosshair(pan, tilt) {
            const crosshair = document.getElementById('crosshair');
            
            // Map angles to percentages (75-195 degrees to 0-100%)
            const panPercent = ((pan - 75) / 120) * 100;
            const tiltPercent = 100 - ((tilt - 75) / 120) * 100; // Invert for visual
            
            crosshair.style.left = `${panPercent}%`;
            crosshair.style.top = `${tiltPercent}%`;
        }

        // Send servo command
        function sendServoCommand(pan, tilt) {
            if (!isConnected || !socket || isUpdatingFromServer) return;
            
            socket.emit('servo_command', {
                type: 'servo_command',
                action: 'move',
                pan_angle: parseFloat(pan),
                tilt_angle: parseFloat(tilt)
            });
            
            addLog(`Command sent: Pan ${pan}°, Tilt ${tilt}°`, 'success');
        }

        // Preset movements
        function moveToPreset(pan, tilt) {
            document.getElementById('panSlider').value = pan;
            document.getElementById('tiltSlider').value = tilt;
            updateSliderBackground('panSlider', pan);
            updateSliderBackground('tiltSlider', tilt);
            sendServoCommand(pan, tilt);
        }

        function moveToCenter() {
            moveToPreset(135, 135);
        }

        // Actuator Control Functions
        async function actuatorControl(action) {
            const speed = parseInt(document.getElementById('speedSlider').value);
            const duration = parseFloat(document.getElementById('durationSlider').value);
            
            try {
                const response = await fetch('/api/actuator/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: action,
                        speed: speed,
                        duration: duration
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    updateActuatorStatus(action);
                    addLog(data.message, 'success');
                    
                    // Check actuator connection after command
                    checkActuatorConnection().then(connected => {
                        const servoConnected = isConnected;
                        updateConnectionStatus(servoConnected, connected);
                    });
                } else {
                    addLog(`Actuator error: ${data.error}`, 'error');
                    // Update connection status on error
                    updateConnectionStatus(isConnected, false);
                }
            } catch (error) {
                addLog(`Failed to control actuator: ${error.message}`, 'error');
            }
        }

        async function actuatorPreset(action, speed, duration) {
            // Update sliders
            document.getElementById('speedSlider').value = speed;
            document.getElementById('durationSlider').value = duration;
            updateSpeedDisplay();
            updateDurationDisplay();
            
            // Send command
            try {
                const response = await fetch('/api/actuator/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: action,
                        speed: speed,
                        duration: duration
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    updateActuatorStatus(action);
                    addLog(data.message, 'success');
                } else {
                    addLog(`Actuator error: ${data.error}`, 'error');
                }
            } catch (error) {
                addLog(`Failed to control actuator: ${error.message}`, 'error');
            }
        }

        function updateActuatorStatus(action) {
            const status = document.getElementById('actuatorStatus');
            actuatorState = action;
            
            // Remove all status classes
            status.classList.remove('extending', 'retracting');
            
            switch(action) {
                case 'extend':
                    status.textContent = 'EXTENDING';
                    status.classList.add('extending');
                    break;
                case 'retract':
                    status.textContent = 'RETRACTING';
                    status.classList.add('retracting');
                    break;
                case 'stop':
                default:
                    status.textContent = 'STOPPED';
                    break;
            }
        }

        function updateSpeedDisplay() {
            const value = document.getElementById('speedSlider').value;
            document.getElementById('speedValue').textContent = `${value}%`;
            
            // Update slider background
            const slider = document.getElementById('speedSlider');
            const percentage = value / 100;
            slider.style.background = `linear-gradient(to right, #ff6b6b ${percentage * 100}%, #2a2a2a ${percentage * 100}%)`;
        }

        function updateDurationDisplay() {
            const value = document.getElementById('durationSlider').value;
            document.getElementById('durationValue').textContent = value == 0 ? 'Continuous' : `${value}s`;
            
            // Update slider background
            const slider = document.getElementById('durationSlider');
            const percentage = value / 10;
            slider.style.background = `linear-gradient(to right, #ff6b6b ${percentage * 100}%, #2a2a2a ${percentage * 100}%)`;
        }

        // Slider event handlers - keep track of values independently
        document.getElementById('panSlider').addEventListener('input', function(e) {
            if (isUpdatingFromServer) return;
            const value = parseInt(e.target.value);
            document.getElementById('panValue').textContent = `${value}°`;
            updateSliderBackground('panSlider', value);
        });

        document.getElementById('panSlider').addEventListener('change', function(e) {
            if (isUpdatingFromServer) return;
            const panValue = parseInt(e.target.value);
            // Use the current tilt value from state, not from the slider
            sendServoCommand(panValue, currentTiltValue);
        });

        document.getElementById('tiltSlider').addEventListener('input', function(e) {
            if (isUpdatingFromServer) return;
            const value = parseInt(e.target.value);
            document.getElementById('tiltValue').textContent = `${value}°`;
            updateSliderBackground('tiltSlider', value);
        });

        document.getElementById('tiltSlider').addEventListener('change', function(e) {
            if (isUpdatingFromServer) return;
            const tiltValue = parseInt(e.target.value);
            // Use the current pan value from state, not from the slider
            sendServoCommand(currentPanValue, tiltValue);
        });

        // Actuator slider handlers
        document.getElementById('speedSlider').addEventListener('input', updateSpeedDisplay);
        document.getElementById('durationSlider').addEventListener('input', updateDurationDisplay);

        // Initialize on page load
        window.addEventListener('load', function() {
            connectWebSocket();
            updateSliderBackground('panSlider', 135);
            updateSliderBackground('tiltSlider', 135);
            updateSpeedDisplay();
            updateDurationDisplay();
            addLog('Aiming system initialized', 'success');
            
            // Request initial state after a short delay
            setTimeout(() => {
                if (socket && isConnected) {
                    socket.emit('request_servo_state');
                }
                
                // Check actuator connection
                checkActuatorConnection().then(actuatorConnected => {
                    updateConnectionStatus(isConnected, actuatorConnected);
                    if (!actuatorConnected) {
                        addLog('Actuator service not available - Check if actuator_controller is running', 'error');
                    }
                });
            }, 500);
            
            // Periodically check actuator connection
            setInterval(() => {
                checkActuatorConnection().then(actuatorConnected => {
                    updateConnectionStatus(isConnected, actuatorConnected);
                });
            }, 5000);
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (socket) {
                socket.disconnect();
            }
        });
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/dashboard_home.html
Category: Web | Size: 27.7 KB | Lines: 827
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Fighting Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 30px;
            text-align: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 3em;
            font-weight: 300;
            letter-spacing: 3px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: gradient 3s ease infinite;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .subtitle {
            color: #888;
            font-size: 1.2em;
            font-weight: 300;
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 60px 20px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .components-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 40px;
            margin-bottom: 60px;
        }

        .component-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .component-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.05) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .component-card:hover::before {
            opacity: 1;
        }

        .component-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7);
            border-color: #555;
        }

        .component-icon {
            font-size: 4em;
            margin-bottom: 20px;
            display: block;
            text-align: center;
        }

        .motor-icon {
            background: linear-gradient(45deg, #00aaff, #0088cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .lidar-icon {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .camera-icon {
            background: linear-gradient(45deg, #ff6b6b, #ff4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .aiming-icon {
            background: linear-gradient(45deg, #ff00ff, #aa00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .sensor-icon {
            background: linear-gradient(45deg, #ffd93d, #ffb300);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .component-title {
            font-size: 2em;
            font-weight: 500;
            margin-bottom: 15px;
            text-align: center;
        }

        .component-description {
            color: #aaa;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .component-status {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .component-status.active {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .component-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .component-card.disabled:hover {
            transform: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .info-section {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 30px;
            margin-top: 40px;
            border: 1px solid #333;
        }

        .info-title {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #00aaff;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .info-item {
            padding: 15px;
            background: #252525;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.2em;
            font-weight: 500;
        }

        .header-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .settings-btn {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        .settings-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: #1a1a1a;
            margin: 10% auto;
            padding: 30px;
            border: 1px solid #333;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .modal-title {
            font-size: 1.8em;
            color: #00aaff;
        }

        .close-btn {
            font-size: 2em;
            color: #888;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-btn:hover {
            color: #fff;
        }

        .settings-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-label {
            color: #aaa;
            font-size: 1.1em;
        }

        .form-input {
            padding: 12px;
            background: #252525;
            border: 1px solid #444;
            border-radius: 8px;
            color: #fff;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #00aaff;
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.3);
        }

        .form-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .btn-secondary {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
        }

        .btn-secondary:hover {
            background: #3a3a3a;
        }

        .connection-info {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid #333;
        }

        .connection-info p {
            margin: 5px 0;
            color: #888;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .components-grid {
                grid-template-columns: 1fr;
            }
            
            .component-icon {
                font-size: 3em;
            }
            
            .modal-content {
                margin: 20% auto;
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Fire Fighting Robot</h1>
        <p class="subtitle">Control & Monitoring Dashboard</p>
        <div class="status-bar">
            <div class="header-controls">
                <div class="status-item">
                    <span>ROS Bridge:</span>
                    <div class="status-indicator" id="rosStatus"></div>
                    <span id="rosStatusText">Disconnected</span>
                </div>
                <button class="settings-btn" onclick="openSettings()">⚙️ Connection Settings</button>
            </div>
            <div class="status-item">
                <span>System:</span>
                <div class="status-indicator connected"></div>
                <span>Online</span>
            </div>
        </div>
    </div>

    <!-- Connection Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Connection Settings</h2>
                <span class="close-btn" onclick="closeSettings()">&times;</span>
            </div>
            <form class="settings-form" onsubmit="saveSettings(event)">
                <div class="form-group">
                    <label class="form-label">Robot IP Address</label>
                    <input type="text" 
                           id="robotIP" 
                           class="form-input" 
                           placeholder="192.168.x.x" 
                           pattern="^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
                           required>
                </div>
                <div class="form-group">
                    <label class="form-label">ROS Bridge Port</label>
                    <input type="number" 
                           id="bridgePort" 
                           class="form-input" 
                           placeholder="9090" 
                           min="1" 
                           max="65535"
                           required>
                </div>
                <div class="connection-info">
                    <p>Current Connection: <span id="currentConnection">Not configured</span></p>
                    <p>Last Connected: <span id="lastConnected">Never</span></p>
                </div>
                <div class="form-buttons">
                    <button type="submit" class="btn btn-primary">Connect</button>
                    <button type="button" class="btn btn-secondary" onclick="closeSettings()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <div class="main-container">
        <div class="components-grid">
            <!-- Motor Control -->
            <div class="component-card" onclick="navigateTo('/motors')">
                <span class="component-icon motor-icon">⚙️</span>
                <h2 class="component-title">Motor Control</h2>
                <p class="component-description">
                    Control all 4 motors independently with forward, backward, and brake modes. 
                    Real-time speed adjustment and emergency stop.
                </p>
                <div class="component-status active">
                    <div class="status-indicator connected"></div>
                    <span>2 Motor Channels Ready</span>
                </div>
            </div>

            <!-- Aiming System -->
            <div class="component-card" onclick="navigateTo('/aiming')">
                <span class="component-icon aiming-icon">🎯</span>
                <h2 class="component-title">Aiming System</h2>
                <p class="component-description">
                    Precision pan/tilt control for targeting system. 
                    Real-time servo positioning with visual feedback.
                </p>
                <div class="component-status" id="aimingStatus">
                    <div class="status-indicator"></div>
                    <span>Click to Activate</span>
                </div>
            </div>

            <!-- Lidar Sensor -->
            <div class="component-card" onclick="navigateTo('/lidar')">
                <span class="component-icon lidar-icon">📡</span>
                <h2 class="component-title">Lidar Sensor</h2>
                <p class="component-description">
                    Real-time 360° environment scanning and obstacle detection. 
                    Visualize surroundings and safe navigation paths.
                </p>
                <div class="component-status" id="lidarStatus">
                    <div class="status-indicator"></div>
                    <span>Click to Activate</span>
                </div>
            </div>

            <!-- Thermal Camera -->
            <div class="component-card" onclick="navigateTo('/thermal')">
                <span class="component-icon camera-icon">🌡️</span>
                <h2 class="component-title">Thermal Camera</h2>
                <p class="component-description">
                    MLX90640 thermal imaging with real-time heatmap visualization. 
                    Monitor temperatures and detect heat signatures.
                </p>
                <div class="component-status" id="thermalStatus">
                    <div class="status-indicator"></div>
                    <span>Click to Activate</span>
                </div>
            </div>

            <!-- Sensors (Future) -->
            <div class="component-card disabled">
                <span class="component-icon sensor-icon">🔥</span>
                <h2 class="component-title">Fire Sensors</h2>
                <p class="component-description">
                    Smoke, flame, and gas sensors for comprehensive fire detection. 
                    Coming soon...
                </p>
                <div class="component-status">
                    <div class="status-indicator"></div>
                    <span>Not Available</span>
                </div>
            </div>
        </div>

        <div class="info-section">
            <h3 class="info-title">System Information</h3>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Robot IP</div>
                    <div class="info-value" id="robotIPInfo">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">ROS Bridge Port</div>
                    <div class="info-value" id="bridgePortInfo">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Active Components</div>
                    <div class="info-value" id="activeComponents">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">System Uptime</div>
                    <div class="info-value" id="uptime">00:00:00</div>
                </div>
                <div class="info-item">
                    <div class="info-label">CPU Usage</div>
                    <div class="info-value" id="cpuUsage">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Memory Usage</div>
                    <div class="info-value" id="memoryUsage">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">CPU Temperature</div>
                    <div class="info-value" id="cpuTemp">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Disk Usage</div>
                    <div class="info-value" id="diskUsage">-</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Navigation function
        function navigateTo(path) {
            window.location.href = path;
        }

        // Connection settings management
        let connectionSettings = {
            robotIP: localStorage.getItem('robotIP') || '192.168.2.1',
            bridgePort: localStorage.getItem('bridgePort') || '9090'
        };

        // Initialize settings on page load
        function initializeSettings() {
            document.getElementById('robotIP').value = connectionSettings.robotIP;
            document.getElementById('bridgePort').value = connectionSettings.bridgePort;
            updateConnectionInfo();
        }

        // Open settings modal
        function openSettings() {
            document.getElementById('settingsModal').style.display = 'block';
            initializeSettings();
        }

        // Close settings modal
        function closeSettings() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        // Save settings and update connection
        async function saveSettings(event) {
            event.preventDefault();
            
            const newIP = document.getElementById('robotIP').value;
            const newPort = document.getElementById('bridgePort').value;
            
            // Save to localStorage
            localStorage.setItem('robotIP', newIP);
            localStorage.setItem('bridgePort', newPort);
            localStorage.setItem('lastConnectAttempt', new Date().toLocaleString());
            
            // Update backend configuration
            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        robot_ip: newIP,
                        rosbridge_port: parseInt(newPort)
                    })
                });
                
                if (response.ok) {
                    connectionSettings.robotIP = newIP;
                    connectionSettings.bridgePort = newPort;
                    
                    // Test the new connection
                    await checkSystemStatus();
                    
                    // Close modal and show success
                    closeSettings();
                    updateConnectionInfo();
                    
                    // Inform user that pages need to be refreshed
                    if (confirm('Connection settings updated. Refresh all open dashboard pages to apply changes?')) {
                        window.location.reload();
                    }
                } else {
                    alert('Failed to update connection settings');
                }
            } catch (error) {
                alert('Error updating settings: ' + error.message);
            }
        }

        // Update connection info display
        function updateConnectionInfo() {
            const currentConn = document.getElementById('currentConnection');
            const lastConn = document.getElementById('lastConnected');
            
            currentConn.textContent = `${connectionSettings.robotIP}:${connectionSettings.bridgePort}`;
            lastConn.textContent = localStorage.getItem('lastConnectAttempt') || 'Never';
        }

        // Check system status with current settings
        async function checkSystemStatus() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                
                // Update ROS connection status
                const rosIndicator = document.getElementById('rosStatus');
                const rosStatusText = document.getElementById('rosStatusText');
                
                if (data.connected) {
                    rosIndicator.classList.add('connected');
                    rosStatusText.textContent = 'Connected';
                    localStorage.setItem('lastSuccessfulConnection', new Date().toLocaleString());
                } else {
                    rosIndicator.classList.remove('connected');
                    rosStatusText.textContent = 'Disconnected';
                }
                
                // Update system info
                if (data.config) {
                    document.getElementById('robotIPInfo').textContent = data.config.robot_ip;
                    document.getElementById('bridgePortInfo').textContent = data.config.rosbridge_port;
                }
                
                // Update component status
                let activeCount = 0;
                if (data.components) {
                    if (data.components.motors) activeCount++;
                    
                    if (data.components.servo) {
                        activeCount++;
                        const aimingStatus = document.getElementById('aimingStatus');
                        aimingStatus.classList.add('active');
                        aimingStatus.innerHTML = '<div class="status-indicator connected"></div><span>Active</span>';
                    }
                    
                    if (data.components.lidar) {
                        activeCount++;
                        const lidarStatus = document.getElementById('lidarStatus');
                        lidarStatus.classList.add('active');
                        lidarStatus.innerHTML = '<div class="status-indicator connected"></div><span>Active</span>';
                    }
                    
                    if (data.components.thermal) {
                        activeCount++;
                        const thermalStatus = document.getElementById('thermalStatus');
                        thermalStatus.classList.add('active');
                        thermalStatus.innerHTML = '<div class="status-indicator connected"></div><span>Active</span>';
                    }
                }
                document.getElementById('activeComponents').textContent = activeCount;
                
            } catch (error) {
                console.error('Error checking status:', error);
                // If the backend isn't responding, show disconnected
                const rosIndicator = document.getElementById('rosStatus');
                const rosStatusText = document.getElementById('rosStatusText');
                rosIndicator.classList.remove('connected');
                rosStatusText.textContent = 'Error';
            }
        }

        // Subscribe to system monitor on load
        async function subscribeSystemMonitor() {
            try {
                const response = await fetch('/api/system/subscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    console.log('System monitor subscription started');
                    // Get initial status
                    updateSystemInfo();
                }
            } catch (error) {
                console.error('Failed to subscribe to system monitor:', error);
            }
        }

        // Update system info from monitor
        async function updateSystemInfo() {
            try {
                const response = await fetch('/api/system/status');
                const data = await response.json();
                
                if (data.data) {
                    document.getElementById('cpuUsage').textContent = data.data.cpu_percent || '-';
                    document.getElementById('memoryUsage').textContent = data.data.memory_percent || '-';
                    document.getElementById('cpuTemp').textContent = data.data.temp_celsius || '-';
                    document.getElementById('diskUsage').textContent = data.data.disk_percent || '-';
                }
            } catch (error) {
                console.error('Error fetching system info:', error);
            }
        }

        // Update uptime
        let startTime = Date.now();
        function updateUptime() {
            const elapsed = Date.now() - startTime;
            const hours = Math.floor(elapsed / 3600000);
            const minutes = Math.floor((elapsed % 3600000) / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            
            document.getElementById('uptime').textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('settingsModal');
            if (event.target == modal) {
                closeSettings();
            }
        }

        // Initialize on page load
        window.onload = function() {
            // Check if this is first time or if settings are missing
            if (!localStorage.getItem('robotIP')) {
                openSettings();
            }
            
            checkSystemStatus();
            subscribeSystemMonitor();
            setInterval(checkSystemStatus, 5000);
            setInterval(updateSystemInfo, 2000); // Update system info every 2 seconds
            setInterval(updateUptime, 1000);
        }
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/lidar_visualization.html
Category: Web | Size: 26.8 KB | Lines: 777
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lidar Sensor - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-height: calc(100vh - 200px);
        }

        .visualization-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 1.5em;
            color: #00ff88;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #0a0a0a;
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .control-button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .control-button.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }

        .control-button.danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .info-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-item {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.3em;
            font-weight: 500;
            color: #00ff88;
        }

        .movement-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 200px;
            margin: 20px auto;
        }

        .move-btn {
            padding: 15px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-size: 1.5em;
            transition: all 0.2s ease;
        }

        .move-btn:hover {
            background: #3a3a3a;
            transform: scale(1.1);
        }

        .move-btn:active {
            background: #00ff88;
            transform: scale(0.95);
        }

        .move-btn:nth-child(2) { grid-column: 2; }
        .move-btn:nth-child(4) { grid-column: 1; }
        .move-btn:nth-child(5) { grid-column: 2; }
        .move-btn:nth-child(6) { grid-column: 3; }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>Lidar Sensor Visualization</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span>Lidar Status:</span>
            <div class="status-indicator" id="lidarStatus"></div>
            <span id="lidarStatusText">Disconnected</span>
        </div>
        <div class="status-item">
            <span>Data Rate:</span>
            <span id="dataRate">0 Hz</span>
        </div>
        <div class="status-item">
            <span>Points:</span>
            <span id="pointCount">0</span>
        </div>
    </div>

    <div class="main-container">
        <!-- Polar View -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Live Scan - Polar View</h2>
                <span id="polarFPS">0 FPS</span>
            </div>
            <div class="canvas-container">
                <canvas id="polarCanvas"></canvas>
            </div>
        </div>

        <!-- Occupancy Map -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Occupancy Map</h2>
                <span id="mapFPS">0 FPS</span>
            </div>
            <div class="canvas-container">
                <canvas id="mapCanvas"></canvas>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="control-button" id="startBtn" onclick="startLidar()">Start Scan</button>
        <button class="control-button danger" id="stopBtn" onclick="stopLidar()" disabled>Stop Scan</button>
        <button class="control-button" onclick="clearMap()">Clear Map</button>
        <button class="control-button" onclick="saveMap()">Save Map</button>
        <button class="control-button" id="followRobotBtn" onclick="toggleFollowRobot()">Follow Robot</button>
        <button class="control-button" onclick="resetView()">Reset View</button>
    </div>

    <div class="info-panel">
        <h3 style="color: #00ff88; margin-bottom: 15px;">Scan Information</h3>
        <div class="info-grid">
            <div class="info-item">
                <div class="info-label">Min Distance</div>
                <div class="info-value" id="minDistance">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Min Angle</div>
                <div class="info-value" id="minAngle">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Obstacles</div>
                <div class="info-value" id="obstacleCount">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">Safe Directions</div>
                <div class="info-value" id="safeDirections" style="font-size: 1em;">-</div>
            </div>
        </div>
    </div>

    <div class="controls">
        <h3 style="color: #00ff88; margin-bottom: 15px; text-align: center;">Robot Movement (Simulation)</h3>
        <div class="movement-controls">
            <button class="move-btn" onclick="moveRobot('forward')">↑</button>
            <button class="move-btn" onclick="moveRobot('left')">←</button>
            <button class="move-btn" onclick="moveRobot('stop')">●</button>
            <button class="move-btn" onclick="moveRobot('right')">→</button>
            <button class="move-btn" onclick="moveRobot('backward')">↓</button>
        </div>
    </div>

    <script>
        // WebSocket connection
        const socket = io();
        
        // Canvas contexts
        const polarCanvas = document.getElementById('polarCanvas');
        const polarCtx = polarCanvas.getContext('2d');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');
        
        // State
        let scanning = false;
        let followRobot = true;
        let latestScanData = null;
        
        // Map parameters
        const MAP_SIZE = 100;  // 10m x 10m with 10cm resolution
        const MAP_RESOLUTION = 0.1;  // meters per pixel
        const occupancyMap = new Array(MAP_SIZE * MAP_SIZE).fill(0.5);  // Unknown = 0.5
        
        // Robot state
        let robotX = MAP_SIZE / 2;
        let robotY = MAP_SIZE / 2;
        let robotTheta = 0;
        const robotPath = [];
        
        // Performance monitoring
        let polarFPS = 0;
        let mapFPS = 0;
        let lastPolarUpdate = Date.now();
        let lastMapUpdate = Date.now();
        let polarFrameCount = 0;
        let mapFrameCount = 0;
        let dataRate = 0;
        let lastDataTime = Date.now();
        let dataCount = 0;
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
        });
        
        socket.on('lidar_data', (data) => {
            latestScanData = data;
            updateVisualization(data);
            
            // Update data rate
            dataCount++;
            const now = Date.now();
            if (now - lastDataTime > 1000) {
                dataRate = dataCount;
                dataCount = 0;
                lastDataTime = now;
                document.getElementById('dataRate').textContent = `${dataRate} Hz`;
            }
        });
        
        // Resize canvases
        function resizeCanvases() {
            const containers = document.querySelectorAll('.canvas-container');
            containers.forEach((container, index) => {
                const canvas = container.querySelector('canvas');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            });
        }
        
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();
        
        // Start/Stop lidar
        async function startLidar() {
            try {
                const response = await fetch('/api/lidar/subscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    scanning = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('lidarStatus').classList.add('connected');
                    document.getElementById('lidarStatusText').textContent = 'Connected';
                }
            } catch (error) {
                console.error('Failed to start lidar:', error);
            }
        }
        
        async function stopLidar() {
            try {
                const response = await fetch('/api/lidar/unsubscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    scanning = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                    document.getElementById('lidarStatus').classList.remove('connected');
                    document.getElementById('lidarStatusText').textContent = 'Disconnected';
                }
            } catch (error) {
                console.error('Failed to stop lidar:', error);
            }
        }
        
        // Visualization functions
        function updateVisualization(scanData) {
            // Update info panel
            document.getElementById('minDistance').textContent = `${scanData.min_distance.toFixed(2)}m`;
            document.getElementById('minAngle').textContent = `${scanData.min_angle_deg.toFixed(1)}°`;
            document.getElementById('obstacleCount').textContent = scanData.obstacle_count;
            document.getElementById('safeDirections').textContent = scanData.safe_directions.join(', ') || 'None';
            document.getElementById('pointCount').textContent = scanData.point_count;
            
            // Draw polar view
            drawPolarView(scanData);
            
            // Update occupancy map
            updateOccupancyMap(scanData);
            drawMapView();
        }
        
        function drawPolarView(scanData) {
            const width = polarCanvas.width;
            const height = polarCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) / 2 - 20;
            
            // Clear canvas
            polarCtx.fillStyle = '#0a0a0a';
            polarCtx.fillRect(0, 0, width, height);
            
            // Draw grid
            polarCtx.strokeStyle = '#333';
            polarCtx.lineWidth = 1;
            
            // Concentric circles
            for (let r = 1; r <= 4; r++) {
                polarCtx.beginPath();
                polarCtx.arc(centerX, centerY, (r / 4) * maxRadius, 0, 2 * Math.PI);
                polarCtx.stroke();
                
                // Distance labels
                polarCtx.fillStyle = '#666';
                polarCtx.font = '12px Arial';
                polarCtx.fillText(`${r}m`, centerX + 5, centerY - (r / 4) * maxRadius + 5);
            }
            
            // Radial lines
            for (let angle = 0; angle < 360; angle += 30) {
                const rad = angle * Math.PI / 180;
                polarCtx.beginPath();
                polarCtx.moveTo(centerX, centerY);
                polarCtx.lineTo(
                    centerX + maxRadius * Math.cos(rad),
                    centerY - maxRadius * Math.sin(rad)
                );
                polarCtx.stroke();
            }
            
            // Draw scan points
            if (scanData.points) {
                polarCtx.fillStyle = '#00ff88';
                scanData.points.forEach(point => {
                    if (point.r < 4.0) {  // Only show points within 4m
                        const x = centerX + (point.r / 4) * maxRadius * Math.cos(point.theta);
                        const y = centerY - (point.r / 4) * maxRadius * Math.sin(point.theta);
                        
                        polarCtx.beginPath();
                        polarCtx.arc(x, y, 2, 0, 2 * Math.PI);
                        polarCtx.fill();
                    }
                });
            }
            
            // Draw obstacles
            polarCtx.fillStyle = '#ff4444';
            scanData.obstacles.forEach(obstacle => {
                const x = centerX + (obstacle.distance / 4) * maxRadius * Math.cos(obstacle.angle);
                const y = centerY - (obstacle.distance / 4) * maxRadius * Math.sin(obstacle.angle);
                
                polarCtx.beginPath();
                polarCtx.arc(x, y, 4, 0, 2 * Math.PI);
                polarCtx.fill();
            });
            
            // Draw robot center
            polarCtx.fillStyle = '#00aaff';
            polarCtx.beginPath();
            polarCtx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            polarCtx.fill();
            
            // Update FPS
            polarFrameCount++;
            const now = Date.now();
            if (now - lastPolarUpdate > 1000) {
                polarFPS = polarFrameCount;
                polarFrameCount = 0;
                lastPolarUpdate = now;
                document.getElementById('polarFPS').textContent = `${polarFPS} FPS`;
            }
        }
        
        function updateOccupancyMap(scanData) {
            if (!scanData.points) return;
            
            // Update map with new scan data
            scanData.points.forEach(point => {
                if (point.r > 0 && point.r < 10) {
                    // Ray tracing - mark free space
                    const steps = Math.floor(point.r / MAP_RESOLUTION);
                    for (let step = 0; step < steps; step++) {
                        const r = step * MAP_RESOLUTION;
                        const x = Math.floor(robotX + r * Math.cos(point.theta + robotTheta) / MAP_RESOLUTION);
                        const y = Math.floor(robotY + r * Math.sin(point.theta + robotTheta) / MAP_RESOLUTION);
                        
                        if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
                            const idx = y * MAP_SIZE + x;
                            occupancyMap[idx] = Math.max(0.0, occupancyMap[idx] - 0.02);
                        }
                    }
                    
                    // Mark obstacle
                    if (point.r < 4.0) {
                        const obsX = Math.floor(robotX + point.r * Math.cos(point.theta + robotTheta) / MAP_RESOLUTION);
                        const obsY = Math.floor(robotY + point.r * Math.sin(point.theta + robotTheta) / MAP_RESOLUTION);
                        
                        if (obsX >= 0 && obsX < MAP_SIZE && obsY >= 0 && obsY < MAP_SIZE) {
                            const idx = obsY * MAP_SIZE + obsX;
                            occupancyMap[idx] = Math.min(1.0, occupancyMap[idx] + 0.1);
                        }
                    }
                }
            });
        }
        
        function drawMapView() {
            const width = mapCanvas.width;
            const height = mapCanvas.height;
            const scale = Math.min(width, height) / (MAP_SIZE * MAP_RESOLUTION);
            
            // Clear canvas
            mapCtx.fillStyle = '#0a0a0a';
            mapCtx.fillRect(0, 0, width, height);
            
            // Calculate view offset
            let offsetX = 0;
            let offsetY = 0;
            if (followRobot) {
                offsetX = width / 2 - robotX * MAP_RESOLUTION * scale;
                offsetY = height / 2 - robotY * MAP_RESOLUTION * scale;
            }
            
            mapCtx.save();
            mapCtx.translate(offsetX, offsetY);
            
            // Draw occupancy map
            const imageData = mapCtx.createImageData(MAP_SIZE, MAP_SIZE);
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const idx = y * MAP_SIZE + x;
                    const value = occupancyMap[idx];
                    const pixelIdx = (y * MAP_SIZE + x) * 4;
                    
                    if (value < 0.5) {
                        // Free space - green tint
                        imageData.data[pixelIdx] = 0;
                        imageData.data[pixelIdx + 1] = Math.floor(255 * (0.5 - value) * 2);
                        imageData.data[pixelIdx + 2] = 0;
                    } else if (value > 0.5) {
                        // Obstacle - red tint
                        imageData.data[pixelIdx] = Math.floor(255 * (value - 0.5) * 2);
                        imageData.data[pixelIdx + 1] = 0;
                        imageData.data[pixelIdx + 2] = 0;
                    } else {
                        // Unknown - gray
                        imageData.data[pixelIdx] = 64;
                        imageData.data[pixelIdx + 1] = 64;
                        imageData.data[pixelIdx + 2] = 64;
                    }
                    imageData.data[pixelIdx + 3] = 255;
                }
            }
            
            // Scale and draw map
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = MAP_SIZE;
            tempCanvas.height = MAP_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);
            
            mapCtx.imageSmoothingEnabled = false;
            mapCtx.drawImage(tempCanvas, 0, 0, MAP_SIZE * MAP_RESOLUTION * scale, MAP_SIZE * MAP_RESOLUTION * scale);
            
            // Draw robot path
            if (robotPath.length > 1) {
                mapCtx.strokeStyle = '#00ff8866';
                mapCtx.lineWidth = 2;
                mapCtx.beginPath();
                mapCtx.moveTo(robotPath[0].x * MAP_RESOLUTION * scale, robotPath[0].y * MAP_RESOLUTION * scale);
                for (let i = 1; i < robotPath.length; i++) {
                    mapCtx.lineTo(robotPath[i].x * MAP_RESOLUTION * scale, robotPath[i].y * MAP_RESOLUTION * scale);
                }
                mapCtx.stroke();
            }
            
            // Draw robot
            const robotScreenX = robotX * MAP_RESOLUTION * scale;
            const robotScreenY = robotY * MAP_RESOLUTION * scale;
            
            // Robot body
            mapCtx.fillStyle = '#00aaff';
            mapCtx.beginPath();
            mapCtx.arc(robotScreenX, robotScreenY, 8, 0, 2 * Math.PI);
            mapCtx.fill();
            
            // Robot direction
            mapCtx.strokeStyle = '#00aaff';
            mapCtx.lineWidth = 3;
            mapCtx.beginPath();
            mapCtx.moveTo(robotScreenX, robotScreenY);
            mapCtx.lineTo(
                robotScreenX + 20 * Math.cos(robotTheta),
                robotScreenY + 20 * Math.sin(robotTheta)
            );
            mapCtx.stroke();
            
            mapCtx.restore();
            
            // Draw scale
            mapCtx.fillStyle = '#fff';
            mapCtx.font = '12px Arial';
            mapCtx.fillText('1m', 10, height - 10);
            mapCtx.strokeStyle = '#fff';
            mapCtx.lineWidth = 2;
            mapCtx.beginPath();
            mapCtx.moveTo(10, height - 20);
            mapCtx.lineTo(10 + scale, height - 20);
            mapCtx.stroke();
            
            // Update FPS
            mapFrameCount++;
            const now = Date.now();
            if (now - lastMapUpdate > 1000) {
                mapFPS = mapFrameCount;
                mapFrameCount = 0;
                lastMapUpdate = now;
                document.getElementById('mapFPS').textContent = `${mapFPS} FPS`;
            }
        }
        
        // Control functions
        function clearMap() {
            occupancyMap.fill(0.5);
            robotPath.length = 0;
            robotX = MAP_SIZE / 2;
            robotY = MAP_SIZE / 2;
            robotTheta = 0;
        }
        
        function saveMap() {
            // Convert map to image and download
            const link = document.createElement('a');
            link.download = `lidar_map_${new Date().toISOString()}.png`;
            link.href = mapCanvas.toDataURL();
            link.click();
        }
        
        function toggleFollowRobot() {
            followRobot = !followRobot;
            document.getElementById('followRobotBtn').classList.toggle('active', followRobot);
        }
        
        function resetView() {
            followRobot = true;
            document.getElementById('followRobotBtn').classList.add('active');
        }
        
        // Robot movement (simulation)
        function moveRobot(direction) {
            const moveSpeed = 0.2;  // meters
            const turnSpeed = 0.1;  // radians
            
            switch (direction) {
                case 'forward':
                    robotX += moveSpeed * Math.cos(robotTheta) / MAP_RESOLUTION;
                    robotY += moveSpeed * Math.sin(robotTheta) / MAP_RESOLUTION;
                    break;
                case 'backward':
                    robotX -= moveSpeed * Math.cos(robotTheta) / MAP_RESOLUTION;
                    robotY -= moveSpeed * Math.sin(robotTheta) / MAP_RESOLUTION;
                    break;
                case 'left':
                    robotTheta -= turnSpeed;
                    break;
                case 'right':
                    robotTheta += turnSpeed;
                    break;
            }
            
            // Keep robot in bounds
            robotX = Math.max(0, Math.min(MAP_SIZE - 1, robotX));
            robotY = Math.max(0, Math.min(MAP_SIZE - 1, robotY));
            
            // Add to path
            robotPath.push({ x: robotX, y: robotY });
            if (robotPath.length > 1000) {
                robotPath.shift();
            }
            
            // Redraw if we have scan data
            if (latestScanData) {
                updateVisualization(latestScanData);
            }
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    moveRobot('forward');
                    break;
                case 'ArrowDown':
                case 's':
                    moveRobot('backward');
                    break;
                case 'ArrowLeft':
                case 'a':
                    moveRobot('left');
                    break;
                case 'ArrowRight':
                case 'd':
                    moveRobot('right');
                    break;
            }
        });
        
        // Initialize
        toggleFollowRobot();  // Start with follow robot enabled
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/motor_control.html
Category: Web | Size: 23.3 KB | Lines: 706
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motor Control - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 40px 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 30px;
            margin-bottom: 40px;
        }

        .motor-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 350px;
        }

        .motor-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
        }

        .motor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .motor-title {
            font-size: 1.5em;
            font-weight: 500;
            color: #00aaff;
        }

        .motor-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            background: #333;
            color: #888;
            transition: all 0.3s ease;
        }

        .motor-status.active {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .direction-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .direction-btn {
            padding: 12px 8px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .direction-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .direction-btn.active {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .direction-btn.brake.active {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            box-shadow: 0 5px 20px rgba(255, 68, 68, 0.4);
        }

        .speed-control {
            margin-top: auto;
        }

        /* Speed marks container */
        .speed-marks {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            padding: 0 12px;
        }

        .speed-mark {
            font-size: 0.75em;
            color: #666;
            text-align: center;
            position: relative;
        }

        .speed-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: #aaa;
        }

        .speed-value {
            font-size: 2em;
            font-weight: 700;
            color: #00ff88;
            min-width: 80px;
            text-align: right;
        }

        .speed-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            transition: all 0.3s ease;
        }

        /* Add markers for the 5 positions */
        .speed-slider {
            background-image: linear-gradient(to right, 
                #444 0%, #444 1px,
                transparent 1px, transparent 24.5%,
                #444 24.5%, #444 25.5%,
                transparent 25.5%, transparent 49.5%,
                #444 49.5%, #444 50.5%,
                transparent 50.5%, transparent 74.5%,
                #444 74.5%, #444 75.5%,
                transparent 75.5%, transparent 99%,
                #444 99%, #444 100%
            );
            background-size: 100% 100%;
            background-repeat: no-repeat;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .speed-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.7);
        }

        .speed-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .emergency-stop {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff0000, #cc0000);
            border: 3px solid #ff4444;
            color: white;
            font-size: 1.2em;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(255, 0, 0, 0.5);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 1000;
        }

        .emergency-stop:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(255, 0, 0, 0.7);
        }

        .emergency-stop:active {
            transform: scale(0.95);
        }

        .log-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            border: 1px solid #333;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            background: #252525;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #aaa;
            border-left: 3px solid #444;
        }

        .log-entry.error {
            border-left-color: #ff4444;
            color: #ff6666;
        }

        .log-entry.success {
            border-left-color: #00ff88;
            color: #00ff88;
        }

        /* Responsive design */
        @media (max-width: 1600px) {
            .controls-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 900px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .emergency-stop {
                width: 80px;
                height: 80px;
                font-size: 1em;
                bottom: 20px;
                right: 20px;
            }

            .direction-controls {
                grid-template-columns: 1fr;
                gap: 8px;
            }
        }

        /* For ultra-wide displays */
        @media (min-width: 2000px) {
            .main-container {
                max-width: 1900px;
            }
            
            .motor-card {
                padding: 35px;
                min-height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ROS 2 Motor Control Panel</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <span>Connection Status:</span>
        <div class="status-indicator" id="connectionStatus"></div>
        <span id="statusText">Disconnected</span>
    </div>

    <div class="main-container">
        <div class="controls-grid">
            <!-- Left Motors -->
            <div class="motor-card" data-motor="0">
                <div class="motor-header">
                    <h2 class="motor-title">Left Motors</h2>
                    <span class="motor-status">IDLE</span>
                </div>
                <div class="direction-controls">
                    <button class="direction-btn" data-direction="forward">Forward</button>
                    <button class="direction-btn" data-direction="backward">Backward</button>
                    <button class="direction-btn brake" data-direction="brake">Brake</button>
                </div>
                <div class="speed-control">
                    <div class="speed-label">
                        <span>Speed Control</span>
                        <span class="speed-value">0%</span>
                    </div>
                    <input type="range" class="speed-slider" min="0" max="100" value="0" step="25">
                    <div class="speed-marks">
                        <span class="speed-mark">0%</span>
                        <span class="speed-mark">25%</span>
                        <span class="speed-mark">50%</span>
                        <span class="speed-mark">75%</span>
                        <span class="speed-mark">100%</span>
                    </div>
                </div>
            </div>

            <!-- Right Motors -->
            <div class="motor-card" data-motor="1">
                <div class="motor-header">
                    <h2 class="motor-title">Right Motors</h2>
                    <span class="motor-status">IDLE</span>
                </div>
                <div class="direction-controls">
                    <button class="direction-btn" data-direction="forward">Forward</button>
                    <button class="direction-btn" data-direction="backward">Backward</button>
                    <button class="direction-btn brake" data-direction="brake">Brake</button>
                </div>
                <div class="speed-control">
                    <div class="speed-label">
                        <span>Speed Control</span>
                        <span class="speed-value">0%</span>
                    </div>
                    <input type="range" class="speed-slider" min="0" max="100" value="0" step="25">
                    <div class="speed-marks">
                        <span class="speed-mark">0%</span>
                        <span class="speed-mark">25%</span>
                        <span class="speed-mark">50%</span>
                        <span class="speed-mark">75%</span>
                        <span class="speed-mark">100%</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <h3 style="margin-bottom: 10px; color: #888;">Activity Log</h3>
            <div id="logContainer"></div>
        </div>
    </div>

    <button class="emergency-stop" id="emergencyStop">STOP<br>ALL</button>

    <script>
        // Motor control state
        const motorStates = {
            0: { direction: 'brake', speed: 0 },  // Left motors
            1: { direction: 'brake', speed: 0 }   // Right motors
        };

        // Command throttling
        let commandQueue = [];
        let isProcessing = false;
        const COMMAND_DELAY = 100; // 100ms between commands

        // Add log entry
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // Keep only last 10 entries
            while (logContainer.children.length > 10) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Process command queue
        async function processCommandQueue() {
            if (isProcessing || commandQueue.length === 0) return;
            
            isProcessing = true;
            const command = commandQueue.shift();
            
            try {
                const response = await fetch(`/api/motor/${command.motorId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        direction: command.direction,
                        speed: command.speed
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    addLog(`Motor ${command.motorId}: ${command.direction} at ${command.speed}%`, 'success');
                } else {
                    addLog(`Motor ${command.motorId} error: ${data.error}`, 'error');
                }
            } catch (error) {
                addLog(`Motor ${command.motorId} error: ${error.message}`, 'error');
            }
            
            // Wait before processing next command
            setTimeout(() => {
                isProcessing = false;
                processCommandQueue();
            }, COMMAND_DELAY);
        }

        // Queue motor command
        function queueMotorCommand(motorId, direction, speed) {
            // Remove any pending commands for this motor
            commandQueue = commandQueue.filter(cmd => cmd.motorId !== motorId);
            
            // Add new command
            commandQueue.push({ motorId, direction, speed });
            
            // Start processing
            processCommandQueue();
        }

        // Send motor command with direction change protection
        async function sendMotorCommand(motorId, direction, speed) {
            const lastDir = motorStates[motorId].direction;
            
            // If changing from forward to backward or vice versa, insert brake command
            if ((lastDir === 'forward' && direction === 'backward') ||
                (lastDir === 'backward' && direction === 'forward')) {
                // Queue brake first
                queueMotorCommand(motorId, 'brake', 0);
                // Then queue the new direction after a delay
                setTimeout(() => {
                    queueMotorCommand(motorId, direction, speed);
                }, 150);
            } else {
                // Direct command
                queueMotorCommand(motorId, direction, speed);
            }
            
            // Update state
            motorStates[motorId].direction = direction;
            motorStates[motorId].speed = speed;
        }

        // Check connection status
        async function checkConnection() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                const indicator = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                
                if (data.connected) {
                    indicator.classList.add('connected');
                    statusText.textContent = 'Connected';
                } else {
                    indicator.classList.remove('connected');
                    statusText.textContent = 'Disconnected';
                }
            } catch (error) {
                const indicator = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                indicator.classList.remove('connected');
                statusText.textContent = 'Error';
            }
        }

        // Update motor UI
        function updateMotorUI(motorId) {
            const motorCard = document.querySelector(`[data-motor="${motorId}"]`);
            const state = motorStates[motorId];
            
            // Update direction buttons
            const directionBtns = motorCard.querySelectorAll('.direction-btn');
            directionBtns.forEach(btn => {
                if (btn.dataset.direction === state.direction) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Update status
            const status = motorCard.querySelector('.motor-status');
            if (state.direction === 'brake') {
                status.textContent = 'BRAKE';
                status.classList.remove('active');
            } else {
                status.textContent = state.direction.toUpperCase();
                status.classList.add('active');
            }
            
            // Update speed display
            const speedValue = motorCard.querySelector('.speed-value');
            speedValue.textContent = `${state.speed}%`;
            
            // Update slider
            const slider = motorCard.querySelector('.speed-slider');
            slider.value = state.speed;
            
            // Update slider background to show progress
            const percentage = state.speed / 100;
            slider.style.background = `linear-gradient(to right, #00ff88 ${percentage * 100}%, #2a2a2a ${percentage * 100}%)`;
        }

        // Initialize motor controls
        document.querySelectorAll('.motor-card').forEach(motorCard => {
            const motorId = parseInt(motorCard.dataset.motor);
            
            // Direction buttons
            motorCard.querySelectorAll('.direction-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const direction = btn.dataset.direction;
                    motorStates[motorId].direction = direction;
                    
                    // If brake, set speed to 0
                    if (direction === 'brake') {
                        motorStates[motorId].speed = 0;
                    }
                    
                    updateMotorUI(motorId);
                    await sendMotorCommand(motorId, direction, motorStates[motorId].speed);
                });
            });
            
            // Speed slider with throttling
            const slider = motorCard.querySelector('.speed-slider');
            let sliderTimeout;
            
            slider.addEventListener('input', (e) => {
                // IMPORTANT: Invert the slider value
                // Slider shows 0-100 left to right, but we need to send inverted values
                const sliderValue = parseInt(e.target.value);
                motorStates[motorId].speed = sliderValue;
                
                // Update UI immediately
                updateMotorUI(motorId);
                
                // Clear any existing timeout
                clearTimeout(sliderTimeout);
                
                // Only send command on discrete values (0, 25, 50, 75, 100)
                if ([0, 25, 50, 75, 100].includes(sliderValue)) {
                    // Send command immediately for discrete values
                    if (motorStates[motorId].direction !== 'brake') {
                        sendMotorCommand(motorId, motorStates[motorId].direction, sliderValue);
                    }
                }
            });
            
            // Also handle change event for when user releases the slider
            slider.addEventListener('change', (e) => {
                const sliderValue = parseInt(e.target.value);
                if (motorStates[motorId].direction !== 'brake') {
                    sendMotorCommand(motorId, motorStates[motorId].direction, sliderValue);
                }
            });
        });

        // Emergency stop button
        document.getElementById('emergencyStop').addEventListener('click', async () => {
            addLog('EMERGENCY STOP ACTIVATED!', 'error');
            
            // Clear command queue
            commandQueue = [];
            
            try {
                const response = await fetch('/api/motors/stop', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Reset only 2 motors
                    for (let i = 0; i < 2; i++) {
                        motorStates[i] = { direction: 'brake', speed: 0 };
                        updateMotorUI(i);
                    }
                    addLog('All motors stopped', 'success');
                } else {
                    addLog('Emergency stop failed!', 'error');
                }
            } catch (error) {
                addLog(`Emergency stop error: ${error.message}`, 'error');
            }
        });

        // Initial setup
        checkConnection();
        setInterval(checkConnection, 5000); // Check connection every 5 seconds
        
        // Initialize UI
        for (let i = 0; i < 2; i++) {
            updateMotorUI(i);
        }
        
        addLog('Motor control panel initialized', 'success');
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/thermal_camera.html
Category: Web | Size: 20.0 KB | Lines: 606
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thermal Camera - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-height: calc(100vh - 200px);
        }

        .visualization-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 1.5em;
            color: #ff6b6b;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #0a0a0a;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
            image-rendering: pixelated;
        }

        .controls {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .control-button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .control-button.active {
            background: linear-gradient(135deg, #ff6b6b, #ff4444);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
        }

        .info-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #333;
            margin-top: 20px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-item {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.3em;
            font-weight: 500;
            color: #ff6b6b;
        }

        .temperature-scale {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            background: #252525;
            border-radius: 10px;
        }

        .scale-gradient {
            flex: 1;
            height: 20px;
            border-radius: 5px;
            background: linear-gradient(to right, 
                #000080, #0000ff, #00ffff, #00ff00, 
                #ffff00, #ff8800, #ff0000, #ffffff);
        }

        .scale-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.8em;
            color: #888;
        }

        .hotspot-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .hotspot-item {
            background: #252525;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #ff6b6b;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>Thermal Camera Visualization</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span>Camera Status:</span>
            <div class="status-indicator" id="thermalStatus"></div>
            <span id="thermalStatusText">Disconnected</span>
        </div>
        <div class="status-item">
            <span>Frame Rate:</span>
            <span id="frameRate">0 FPS</span>
        </div>
        <div class="status-item">
            <span>Frame Count:</span>
            <span id="frameCount">0</span>
        </div>
    </div>

    <div class="main-container">
        <!-- Thermal Heatmap -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Thermal Heatmap</h2>
                <span id="heatmapSize">32x24</span>
            </div>
            <div class="canvas-container">
                <canvas id="thermalCanvas"></canvas>
            </div>
            <div class="temperature-scale">
                <span id="minTempLabel">20°C</span>
                <div class="scale-gradient"></div>
                <span id="maxTempLabel">30°C</span>
            </div>
        </div>

        <!-- Analysis Panel -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Thermal Analysis</h2>
            </div>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Min Temperature</div>
                    <div class="info-value" id="minTemp">-°C</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Max Temperature</div>
                    <div class="info-value" id="maxTemp">-°C</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Average</div>
                    <div class="info-value" id="avgTemp">-°C</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Center</div>
                    <div class="info-value" id="centerTemp">-°C</div>
                </div>
            </div>
            
            <div style="margin-top: 20px;">
                <h3 style="color: #ff6b6b; margin-bottom: 10px;">Hotspot Detection</h3>
                <div class="info-item">
                    <div class="info-label">Hotspots Detected</div>
                    <div class="info-value" id="hotspotCount">0</div>
                </div>
                <div class="hotspot-list" id="hotspotList"></div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="control-button" id="startBtn" onclick="startThermal()">Start Stream</button>
        <button class="control-button" id="stopBtn" onclick="stopThermal()" disabled>Stop Stream</button>
        <button class="control-button" onclick="captureFrame()">Capture Frame</button>
        <button class="control-button" onclick="saveImage()">Save Image</button>
        <button class="control-button" id="autoScaleBtn" onclick="toggleAutoScale()">Auto Scale: ON</button>
        <button class="control-button" onclick="resetView()">Reset View</button>
    </div>

    <script>
        // WebSocket connection
        const socket = io();
        
        // Canvas and context
        const canvas = document.getElementById('thermalCanvas');
        const ctx = canvas.getContext('2d');
        
        // State
        let streaming = false;
        let autoScale = true;
        let latestFrameData = null;
        
        // Performance monitoring
        let frameCount = 0;
        let lastFPSUpdate = Date.now();
        let fps = 0;
        
        // Temperature range for manual scaling
        let manualMinTemp = 20;
        let manualMaxTemp = 35;
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
        });
        
        socket.on('thermal_data', (data) => {
            latestFrameData = data;
            updateVisualization(data);
            
            // Update frame count and FPS
            frameCount++;
            const now = Date.now();
            if (now - lastFPSUpdate > 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFPSUpdate = now;
                document.getElementById('frameRate').textContent = `${fps} FPS`;
            }
        });
        
        // Color mapping function
        function temperatureToColor(temp, minTemp, maxTemp) {
            // Normalize temperature to 0-1 range
            const normalized = (temp - minTemp) / (maxTemp - minTemp);
            const clamped = Math.max(0, Math.min(1, normalized));
            
            // Color gradient: cold (blue) -> warm (red/white)
            let r, g, b;
            
            if (clamped < 0.25) {
                // Blue to cyan
                const t = clamped * 4;
                r = 0;
                g = Math.floor(t * 255);
                b = 255;
            } else if (clamped < 0.5) {
                // Cyan to green
                const t = (clamped - 0.25) * 4;
                r = 0;
                g = 255;
                b = Math.floor((1 - t) * 255);
            } else if (clamped < 0.75) {
                // Green to yellow
                const t = (clamped - 0.5) * 4;
                r = Math.floor(t * 255);
                g = 255;
                b = 0;
            } else {
                // Yellow to red to white
                const t = (clamped - 0.75) * 4;
                if (t < 0.5) {
                    r = 255;
                    g = Math.floor((1 - t * 2) * 255);
                    b = 0;
                } else {
                    r = 255;
                    g = Math.floor((t - 0.5) * 2 * 255);
                    b = Math.floor((t - 0.5) * 2 * 255);
                }
            }
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // Update visualization
        function updateVisualization(data) {
            if (!data || !data.thermal_data) return;
            
            // Update info panel
            document.getElementById('minTemp').textContent = `${data.min_temp.toFixed(1)}°C`;
            document.getElementById('maxTemp').textContent = `${data.max_temp.toFixed(1)}°C`;
            document.getElementById('avgTemp').textContent = `${data.avg_temp.toFixed(1)}°C`;
            document.getElementById('centerTemp').textContent = `${data.center_temp.toFixed(1)}°C`;
            document.getElementById('frameCount').textContent = data.frame_count || 0;
            document.getElementById('hotspotCount').textContent = data.hotspot_count || 0;
            
            // Update temperature scale
            const minTemp = autoScale ? data.min_temp : manualMinTemp;
            const maxTemp = autoScale ? data.max_temp : manualMaxTemp;
            document.getElementById('minTempLabel').textContent = `${minTemp.toFixed(1)}°C`;
            document.getElementById('maxTempLabel').textContent = `${maxTemp.toFixed(1)}°C`;
            
            // Draw heatmap
            drawHeatmap(data.thermal_data, data.width, data.height, minTemp, maxTemp);
            
            // Update hotspot list
            updateHotspotList(data.hotspots || []);
        }
        
        // Draw thermal heatmap
        function drawHeatmap(thermalData, width, height, minTemp, maxTemp) {
            // Set canvas size with scaling
            const scale = 20; // Each pixel becomes 10x10
            canvas.width = width * scale;
            canvas.height = height * scale;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw each temperature pixel
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const temp = thermalData[y][x];
                    const color = temperatureToColor(temp, minTemp, maxTemp);
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x * scale, y * scale, scale, scale);
                }
            }
            
            // Draw grid lines (optional)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= width; x++) {
                ctx.beginPath();
                ctx.moveTo(x * scale, 0);
                ctx.lineTo(x * scale, height * scale);
                ctx.stroke();
            }
            for (let y = 0; y <= height; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * scale);
                ctx.lineTo(width * scale, y * scale);
                ctx.stroke();
            }
            
            // Draw center crosshair
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            const centerX = width * scale / 2;
            const centerY = height * scale / 2;
            
            ctx.beginPath();
            ctx.moveTo(centerX - 20, centerY);
            ctx.lineTo(centerX + 20, centerY);
            ctx.moveTo(centerX, centerY - 20);
            ctx.lineTo(centerX, centerY + 20);
            ctx.stroke();
        }
        
        // Update hotspot list
        function updateHotspotList(hotspots) {
            const listContainer = document.getElementById('hotspotList');
            listContainer.innerHTML = '';
            
            hotspots.slice(0, 10).forEach((hotspot, index) => {
                const item = document.createElement('div');
                item.className = 'hotspot-item';
                item.innerHTML = `
                    <span>Hotspot ${index + 1} (${hotspot.x}, ${hotspot.y})</span>
                    <span>${hotspot.temp.toFixed(1)}°C</span>
                `;
                listContainer.appendChild(item);
            });
        }
        
        // Control functions
        async function startThermal() {
            try {
                const response = await fetch('/api/thermal/subscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    streaming = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('thermalStatus').classList.add('connected');
                    document.getElementById('thermalStatusText').textContent = 'Connected';
                }
            } catch (error) {
                console.error('Failed to start thermal camera:', error);
            }
        }
        
        async function stopThermal() {
            try {
                const response = await fetch('/api/thermal/unsubscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    streaming = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                    document.getElementById('thermalStatus').classList.remove('connected');
                    document.getElementById('thermalStatusText').textContent = 'Disconnected';
                }
            } catch (error) {
                console.error('Failed to stop thermal camera:', error);
            }
        }
        
        async function captureFrame() {
            try {
                const response = await fetch('/api/thermal/frame');
                const result = await response.json();
                
                if (result.success) {
                    updateVisualization(result.data);
                }
            } catch (error) {
                console.error('Failed to capture frame:', error);
            }
        }
        
        function saveImage() {
            const link = document.createElement('a');
            link.download = `thermal_${new Date().toISOString()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }
        
        function toggleAutoScale() {
            autoScale = !autoScale;
            document.getElementById('autoScaleBtn').textContent = `Auto Scale: ${autoScale ? 'ON' : 'OFF'}`;
            if (latestFrameData) {
                updateVisualization(latestFrameData);
            }
        }
        
        function resetView() {
            manualMinTemp = 20;
            manualMaxTemp = 35;
            if (!autoScale && latestFrameData) {
                updateVisualization(latestFrameData);
            }
        }
        
        // Add mouse hover to show temperature
        canvas.addEventListener('mousemove', (e) => {
            if (!latestFrameData || !latestFrameData.thermal_data) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = Math.floor((e.clientX - rect.left) * scaleX / 10);
            const y = Math.floor((e.clientY - rect.top) * scaleY / 10);
            
            if (x >= 0 && x < latestFrameData.width && y >= 0 && y < latestFrameData.height) {
                const temp = latestFrameData.thermal_data[y][x];
                canvas.title = `Temperature: ${temp.toFixed(1)}°C at (${x}, ${y})`;
            }
        });
    </script>
</body>
</html>
================================================================================

