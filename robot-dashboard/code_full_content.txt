================================================================================
FULL CODE CONTENT DUMP
Directory: /Users/yang/Library/CloudStorage/OneDrive-Personal/UCL/Year 4 UCL/MECH0073/GitHub_Repositories/Fire-fighting-Robot/robot-dashboard
Time: 2025-06-11 03:11:45
================================================================================

DIRECTORY STRUCTURE:
----------------------------------------
├── backend/
│   ├── motors/
│   │   ├── __init__.py (0.0 B)
│   │   ├── actuator_control.py (7.5 KB)
│   │   ├── motor_controller.py (6.3 KB)
│   │   ├── motor_routes.py (4.1 KB)
│   │   └── servo_control.py (6.7 KB)
│   ├── sensors/
│   │   ├── __init__.py (390.0 B)
│   │   ├── lidar.py (8.0 KB)
│   │   ├── system_monitor.py (7.5 KB)
│   │   └── thermal_camera.py (7.7 KB)
│   ├── __init__.py (285.0 B)
│   ├── automation.py (30.3 KB)
│   ├── automation_aiming.py (15.5 KB)
│   ├── automation_v2.py (34.6 KB)
│   ├── config_manager.py (3.3 KB)
│   ├── host_backend.py (30.5 KB)
│   └── ros_bridge.py (16.9 KB)
├── frontend/
│   ├── static/
│   │   └── css/
│   └── templates/
│       ├── aiming_system.html (56.6 KB)
│       ├── dashboard_home.html (27.7 KB)
│       ├── lidar_visualization.html (47.8 KB)
│       ├── motor_control.html (23.4 KB)
│       └── thermal_camera.html (20.0 KB)
├── ui/
├── code_full_content.txt (357.0 KB)
├── code_scan_summary.txt (1.5 KB)
├── code_scanner.py (12.9 KB)
├── quick_test_automation.py (23.1 KB)
├── requirements.txt (130.0 B)
└── run.py (341.0 B)

================================================================================
STATISTICS:
----------------------------------------
Total code files: 26
Total size: 736.9 KB
Total lines: 20,957

FILES BY CATEGORY:
----------------------------------------
Documentation: 3 files, 358.6 KB, 10,186 lines
Python: 18 files, 202.8 KB, 5,667 lines
Web: 5 files, 175.4 KB, 5,104 lines

================================================================================
FILE CONTENTS:
================================================================================

================================================================================
FILE: code_full_content.txt
Category: Documentation | Size: 357.0 KB | Lines: 10142
================================================================================

================================================================================


================================================================================
FILE: code_scan_summary.txt
Category: Documentation | Size: 1.5 KB | Lines: 37
================================================================================
Code Scan Summary - 2025-06-11 03:11:45
Directory: /Users/yang/Library/CloudStorage/OneDrive-Personal/UCL/Year 4 UCL/MECH0073/GitHub_Repositories/Fire-fighting-Robot/robot-dashboard
Total files: 26
Total size: 736.9 KB
Total lines: 20,957

Files by category:
  Documentation: 3 files
  Python: 18 files
  Web: 5 files

All code files:
  code_full_content.txt (Documentation, 357.0 KB)
  code_scan_summary.txt (Documentation, 1.5 KB)
  requirements.txt (Documentation, 130.0 B)
  backend/__init__.py (Python, 285.0 B)
  backend/automation.py (Python, 30.3 KB)
  backend/automation_aiming.py (Python, 15.5 KB)
  backend/automation_v2.py (Python, 34.6 KB)
  backend/config_manager.py (Python, 3.3 KB)
  backend/host_backend.py (Python, 30.5 KB)
  backend/motors/__init__.py (Python, 0.0 B)
  backend/motors/actuator_control.py (Python, 7.5 KB)
  backend/motors/motor_controller.py (Python, 6.3 KB)
  backend/motors/motor_routes.py (Python, 4.1 KB)
  backend/motors/servo_control.py (Python, 6.7 KB)
  backend/ros_bridge.py (Python, 16.9 KB)
  backend/sensors/__init__.py (Python, 390.0 B)
  backend/sensors/lidar.py (Python, 8.0 KB)
  backend/sensors/system_monitor.py (Python, 7.5 KB)
  backend/sensors/thermal_camera.py (Python, 7.7 KB)
  quick_test_automation.py (Python, 23.1 KB)
  run.py (Python, 341.0 B)
  frontend/templates/aiming_system.html (Web, 56.6 KB)
  frontend/templates/dashboard_home.html (Web, 27.7 KB)
  frontend/templates/lidar_visualization.html (Web, 47.8 KB)
  frontend/templates/motor_control.html (Web, 23.4 KB)
  frontend/templates/thermal_camera.html (Web, 20.0 KB)

================================================================================


================================================================================
FILE: requirements.txt
Category: Documentation | Size: 130.0 B | Lines: 7
================================================================================
Flask==3.0.0
Flask-CORS==4.0.0
Flask-SocketIO==5.3.5
websocket-client==1.7.0
watchdog==3.0.0
numpy==1.26.2
python-socketio==5.10.0
================================================================================


================================================================================
FILE: backend/__init__.py
Category: Python | Size: 285.0 B | Lines: 14
================================================================================
"""
Backend package for ROS 2 Motor Control
"""

from .ros_bridge import ROSBridgeConnection, MotorController, get_ros_bridge, get_motor_controller

__all__ = [
    'ROSBridgeConnection',
    'MotorController', 
    'get_ros_bridge',
    'get_motor_controller'
]

__version__ = '1.0.0'
================================================================================


================================================================================
FILE: backend/automation.py
Category: Python | Size: 30.3 KB | Lines: 725
================================================================================
#!/usr/bin/env python3
"""
Automation module for robot mapping and pathfinding
Implements wall-following algorithm with differential drive calculations
"""

import logging
import threading
import time
import numpy as np
from typing import Dict, List, Tuple, Optional, Any
from enum import Enum
from collections import deque
import math

logger = logging.getLogger(__name__)

class RobotState(Enum):
    """Robot states for mapping"""
    IDLE = "idle"
    MAPPING = "mapping"
    TURNING = "turning"
    MOVING_FORWARD = "moving_forward"
    OBSTACLE_AVOIDANCE = "obstacle_avoidance"
    EMERGENCY_STOP = "emergency_stop"

class TurnDirection(Enum):
    """Turn direction preference"""
    LEFT = "left"
    RIGHT = "right"

class AutoMapper:
    """Autonomous mapping using wall-following algorithm"""
    
    def __init__(self, motor_controller, lidar_sensor):
        """
        Initialize the auto mapper
        
        Args:
            motor_controller: Motor controller instance
            lidar_sensor: Lidar sensor instance
        """
        self.motor_controller = motor_controller
        self.lidar_sensor = lidar_sensor
        
        # Robot dimensions (in mm)
        self.robot_length = 500  # mm
        self.robot_width = 450   # mm
        self.wheelbase = 400     # Approximate wheelbase (mm)
        
        # Sensor offset - lidar is at front center
        self.lidar_offset_front = self.robot_length / 2  # 250mm from center to front
        self.lidar_offset_rear = self.robot_length / 2   # 250mm from center to rear
        self.lidar_offset_side = self.robot_width / 2    # 225mm from center to side
        
        # Safety parameters (distances from robot body, not sensor)
        self.safety_distance = 300  # mm (stop if obstacle closer than this from body)
        self.wall_follow_distance = 500  # mm (ideal distance from wall to body)
        self.wall_follow_tolerance = 150  # mm (acceptable deviation)
        self.critical_distance = 200  # mm (emergency stop distance from body)
        
        # Speed parameters (0-100%)
        self.base_speed = 85  # Normal forward speed
        self.turn_speed = 75  # Speed during turns
        self.slow_speed = 75  # Slow speed for careful movement
        
        # Control parameters
        self.turn_direction = TurnDirection.RIGHT  # Prefer right turns
        self.command_delay = 0.2  # Delay between commands (seconds)
        self.sensor_delay = 0.1   # Account for sensor delay
        
        # State management
        self.state = RobotState.IDLE
        self.mapping_active = False
        self.emergency_stop = False
        self._mapping_thread = None
        self._state_lock = threading.Lock()
        self.idle_timeout = 5.0  # Seconds before forcing movement in IDLE state
        self.last_state_change = time.time()
        
        # Odometry estimation (simple dead reckoning)
        self.robot_x = 0.0  # mm
        self.robot_y = 0.0  # mm
        self.robot_theta = 0.0  # radians
        self.last_odometry_update = time.time()
        
        # Mapping data
        self.visited_cells = set()  # Grid cells visited
        self.wall_map = {}  # Detected walls
        self.mapping_start_time = None
        
        # Lidar background removal
        self.static_scan_buffer = []
        self.static_scan_samples = 10
        self.static_obstacles = {}  # Store static obstacles like robot components
        self.background_removal_enabled = True
        
        # PID controller for wall following
        self.kp = 0.5  # Proportional gain
        self.ki = 0.1  # Integral gain
        self.kd = 0.2  # Derivative gain
        self.integral_error = 0.0
        self.last_error = 0.0
        
        # Bug2 algorithm parameters
        self.m_line = None  # Line from start to goal
        self.hit_points = []  # Points where robot hit obstacles
        self.leave_points = []  # Points where robot left obstacles
        
        logger.info("AutoMapper initialized")
    
    def _set_motors(self, left_dir: str, left_speed: float, 
                    right_dir: str, right_speed: float):
        """
        Set motor speeds accounting for reversal
        Note: Physical left/right are reversed in motor controller
        """
        # Motor 0 in code = Right side of robot
        # Motor 1 in code = Left side of robot
        
        # Set right side of robot (motor 0)
        self.motor_controller.set_motor(0, left_dir, left_speed)
        time.sleep(self.command_delay)
        
        # Set left side of robot (motor 1)
        self.motor_controller.set_motor(1, right_dir, right_speed)
    
    def start_mapping(self) -> bool:
        """Start autonomous mapping"""
        with self._state_lock:
            if self.mapping_active:
                logger.warning("Mapping already active")
                return False
            
            # Calibrate background first
            if not self.calibrate_background():
                logger.warning("Background calibration failed, continuing without it")
            
            self.mapping_active = True
            self.emergency_stop = False
            self.state = RobotState.IDLE
            self.mapping_start_time = time.time()
            
            # Reset odometry
            self.robot_x = 0.0
            self.robot_y = 0.0
            self.robot_theta = 0.0
            
            # Clear previous mapping data
            self.visited_cells.clear()
            self.wall_map.clear()
            self.hit_points.clear()
            self.leave_points.clear()
            
            # Start mapping thread
            self._mapping_thread = threading.Thread(target=self._mapping_loop)
            self._mapping_thread.daemon = True
            self._mapping_thread.start()
            
            logger.info("Started autonomous mapping")
            return True
    
    def stop_mapping(self) -> bool:
        """Stop autonomous mapping"""
        with self._state_lock:
            if not self.mapping_active:
                return False
            
            self.mapping_active = False
            self.emergency_stop = True
            
        # Stop all motors
        self.motor_controller.stop_all_motors()
        
        # Wait for thread to finish
        if self._mapping_thread:
            self._mapping_thread.join(timeout=5.0)
        
        logger.info("Stopped autonomous mapping")
        return True
    
    def get_status(self) -> Dict[str, Any]:
        """Get current mapping status"""
        with self._state_lock:
            duration = 0
            if self.mapping_start_time:
                duration = time.time() - self.mapping_start_time
            
            return {
                "active": self.mapping_active,
                "state": self.state.value,
                "emergency_stop": self.emergency_stop,
                "robot_position": {
                    "x": round(self.robot_x),
                    "y": round(self.robot_y),
                    "theta": round(math.degrees(self.robot_theta), 1)
                },
                "visited_cells": len(self.visited_cells),
                "walls_detected": len(self.wall_map),
                "duration": round(duration, 1)
            }
    
    def _mapping_loop(self):
        """Main mapping loop"""
        logger.info("Mapping loop started")
        
        # Initial delay to ensure sensors are ready
        logger.info("Waiting for sensors to stabilize...")
        time.sleep(2.0)
        
        # Start in IDLE state and wait for good data
        startup_attempts = 0
        while self.mapping_active and not self.emergency_stop and startup_attempts < 10:
            scan_data = self.lidar_sensor.get_latest_scan()
            if scan_data and scan_data.get("point_count", 0) > 10:
                logger.info(f"Good lidar data received, starting mapping. Points: {scan_data.get('point_count')}")
                # Start by moving forward to find walls
                self.state = RobotState.MOVING_FORWARD
                break
            startup_attempts += 1
            time.sleep(0.5)
        
        # If still no data, start moving forward anyway to explore
        if self.state == RobotState.IDLE:
            logger.info("No initial walls detected, starting exploration by moving forward")
            self.state = RobotState.MOVING_FORWARD
        
        while self.mapping_active and not self.emergency_stop:
            try:
                # Get latest lidar scan
                scan_data = self.lidar_sensor.get_latest_scan()
                
                if not scan_data:
                    logger.warning("No lidar data available")
                    time.sleep(0.1)
                    continue
                
                # Filter out static obstacles (robot components)
                filtered_scan = self.filter_static_obstacles(scan_data)
                
                # Process scan and decide action
                self._process_scan(filtered_scan)
                
                # Execute state-based behavior
                current_time = time.time()
                
                # Check for idle timeout
                if self.state == RobotState.IDLE:
                    if current_time - self.last_state_change > self.idle_timeout:
                        logger.warning("IDLE timeout - forcing movement to explore")
                        self.state = RobotState.MOVING_FORWARD
                        self.last_state_change = current_time
                
                # Track state changes
                old_state = self.state
                
                if self.state == RobotState.MOVING_FORWARD:
                    self._move_forward(scan_data)
                elif self.state == RobotState.TURNING:
                    self._execute_turn(scan_data)
                elif self.state == RobotState.OBSTACLE_AVOIDANCE:
                    self._avoid_obstacle(scan_data)
                elif self.state == RobotState.EMERGENCY_STOP:
                    self._emergency_stop()
                    if self.emergency_stop:  # If still in emergency
                        break
                
                # Update state change time
                if old_state != self.state:
                    self.last_state_change = current_time
                
                # Update odometry
                self._update_odometry()
                
                # Small delay to prevent CPU overload
                time.sleep(0.05)
                
            except Exception as e:
                logger.error(f"Error in mapping loop: {e}")
                self._emergency_stop()
                break
        
        # Ensure motors are stopped
        self.motor_controller.stop_all_motors()
        logger.info("Mapping loop ended")
    
    def update_safety_parameters(self, critical: float, safety: float, wall_follow: float) -> bool:
        """Update safety parameters dynamically
        
        Args:
            critical: Critical distance in mm
            safety: Safety distance in mm
            wall_follow: Wall following distance in mm
            
        Returns:
            bool: True if successful
        """
        try:
            self.critical_distance = max(100, min(500, critical))
            self.safety_distance = max(200, min(800, safety))
            self.wall_follow_distance = max(300, min(1000, wall_follow))
            logger.info(f"Updated safety parameters - Critical: {self.critical_distance}mm, Safety: {self.safety_distance}mm, Wall follow: {self.wall_follow_distance}mm")
            return True
        except Exception as e:
            logger.error(f"Failed to update safety parameters: {e}")
            return False
    
    def _process_scan(self, scan_data: Dict[str, Any]):
        """Process lidar scan and determine robot state"""
        # Check for immediate obstacles
        min_distance = scan_data.get("min_distance", float('inf')) * 1000  # Convert to mm
        
        # Since lidar is at front center, adjust for robot body
        # For front obstacles, the actual clearance is min_distance
        # For side obstacles, we need to check specific angles
        front_clearance = min_distance  # Direct measurement from front sensor
        
        # Log for debugging
        logger.info(f"Front clearance: {front_clearance}mm, Critical+offset: {self.critical_distance}mm")
        
        if front_clearance < self.critical_distance:
            # Too close to obstacle - emergency stop
            logger.warning(f"CRITICAL: Obstacle at {front_clearance}mm from body - Emergency stop!")
            self.state = RobotState.EMERGENCY_STOP
            return
        elif front_clearance < self.safety_distance:
            # Close to obstacle but not critical
            logger.info(f"Obstacle detected at {front_clearance}mm from body - Avoiding")
            self.state = RobotState.OBSTACLE_AVOIDANCE
            return
        
        # Wall following logic - measure to robot body, not sensor
        right_wall_distance = self._get_wall_distance(scan_data, -90)  # Right side
        front_distance = self._get_wall_distance(scan_data, 0)  # Front
        
        # Adjust side distance for robot width (sensor is at center)
        if right_wall_distance is not None:
            right_wall_distance = max(0, right_wall_distance - self.lidar_offset_side)
        
        logger.debug(f"Wall distances from body - Right: {right_wall_distance}mm, Front: {front_distance}mm")
        
        # Check if we need to turn
        if front_distance and front_distance < self.wall_follow_distance:
            # Wall or obstacle ahead, need to turn
            logger.info(f"Wall ahead at {front_distance}mm from body - Turning")
            self.state = RobotState.TURNING
        elif right_wall_distance is None or right_wall_distance > self.wall_follow_distance * 2:
            # No wall on right, but keep moving forward to find one
            logger.info(f"No right wall detected - Continue moving forward to explore")
            self.state = RobotState.MOVING_FORWARD
        else:
            # Follow wall
            self.state = RobotState.MOVING_FORWARD
    
    def reset_emergency_stop(self) -> bool:
        """Reset emergency stop state"""
        with self._state_lock:
            if self.emergency_stop:
                self.emergency_stop = False
                self.state = RobotState.IDLE
                logger.info("Emergency stop reset")
                return True
            return False
    
    def _get_wall_distance(self, scan_data: Dict[str, Any], angle_deg: float) -> Optional[float]:
        """
        Get distance to wall at specific angle
        
        Args:
            scan_data: Lidar scan data
            angle_deg: Angle in degrees (0 = front, -90 = right, 90 = left)
            
        Returns:
            Distance in mm or None if no wall detected
        """
        points = scan_data.get("points", [])
        if not points:
            return None
        
        # Convert angle to radians
        target_angle = math.radians(angle_deg)
        angle_tolerance = math.radians(15)  # 15 degree tolerance
        
        # Find points within angle range
        valid_distances = []
        for point in points:
            # Handle both 'theta' and 'angle' keys
            point_angle = point.get("theta", point.get("angle", 0))
            angle_diff = abs(point_angle - target_angle)
            # Handle angle wrap-around
            if angle_diff > math.pi:
                angle_diff = 2 * math.pi - angle_diff
            
            if angle_diff <= angle_tolerance:
                # Handle both 'r' and 'distance' keys
                distance = point.get("r", point.get("distance", 0))
                if distance > 0.1 and distance < 10.0:  # Valid range 0.1m to 10m
                    valid_distances.append(distance * 1000)  # Convert to mm
        
        if valid_distances:
            return np.median(valid_distances)  # Use median for robustness
        return None
    
    def _move_forward(self, scan_data: Dict[str, Any]):
        """Move forward while following wall or exploring"""
        # Get distance to right wall
        right_wall_distance = self._get_wall_distance(scan_data, -90)
        
        if right_wall_distance is None:
            # No wall detected, move forward to explore
            logger.info("No wall detected - Exploring forward")
            self._set_motors("forward", self.base_speed, "forward", self.base_speed)
            return
        
        # Adjust for sensor position - sensor is at center, we want distance from body
        actual_wall_distance = right_wall_distance - self.lidar_offset_side
        
        # If wall is too far, just move forward
        if actual_wall_distance > self.wall_follow_distance * 2:
            logger.info(f"Wall too far ({actual_wall_distance}mm) - Moving forward to explore")
            self._set_motors("forward", self.base_speed, "forward", self.base_speed)
            return
        
        # Wall following mode - use PID control
        # Calculate error from desired wall distance
        error = actual_wall_distance - self.wall_follow_distance
        
        # PID control
        self.integral_error += error * self.command_delay
        derivative = (error - self.last_error) / self.command_delay
        self.last_error = error
        
        # Calculate correction
        correction = (self.kp * error + 
                     self.ki * self.integral_error + 
                     self.kd * derivative)
        
        # Convert correction to differential speed
        # Positive correction = turn left (away from wall)
        # Negative correction = turn right (toward wall)
        speed_diff = max(-20, min(20, correction / 50))  # Limit differential
        
        # Note: Motor sides are reversed as mentioned
        # Left motors in code = Right side of robot
        # Right motors in code = Left side of robot
        left_speed = self.base_speed + speed_diff   # Right side of robot
        right_speed = self.base_speed - speed_diff  # Left side of robot
        
        # Ensure speeds are in valid range
        left_speed = max(self.slow_speed, min(100, left_speed))
        right_speed = max(self.slow_speed, min(100, right_speed))
        
        logger.debug(f"Wall following - Distance: {actual_wall_distance}mm, Error: {error}mm, Speeds: L={left_speed}, R={right_speed}")
        
        # Set motor speeds (reversed due to wiring)
        self._set_motors("forward", left_speed, "forward", right_speed)
    
    def _execute_turn(self, scan_data: Dict[str, Any]):
        """Execute a turn using smooth single-wheel turning"""
        front_distance = self._get_wall_distance(scan_data, 0)
        right_distance = self._get_wall_distance(scan_data, -90)
        left_distance = self._get_wall_distance(scan_data, 90)
        
        # Determine turn direction
        if self.turn_direction == TurnDirection.RIGHT:
            # Check if right turn is possible
            if right_distance and right_distance > self.wall_follow_distance * 1.5:
                # Turn right using smooth turn
                logger.info("Executing smooth right turn")
                self._set_motors_smooth("forward", self.turn_speed, "backward", self.turn_speed)
            elif left_distance and left_distance > self.wall_follow_distance * 1.5:
                # Can't turn right, turn left
                logger.info("Right blocked, executing smooth left turn")
                self._set_motors_smooth("backward", self.turn_speed, "forward", self.turn_speed)
            else:
                # Can't turn either way, rotate in place
                logger.warning("Both sides blocked, rotating in place")
                self._set_motors("forward", self.turn_speed, "backward", self.turn_speed)
        
        # Wait a bit for turn to execute
        time.sleep(0.5)
        
        # Check if turn is complete
        new_front = self._get_wall_distance(scan_data, 0)
        if new_front and new_front > self.wall_follow_distance * 1.5:
            self.state = RobotState.MOVING_FORWARD
    
    def _avoid_obstacle(self, scan_data: Dict[str, Any]):
        """Avoid immediate obstacle using smooth turning"""
        # Stop first
        self.motor_controller.stop_all_motors()
        time.sleep(0.2)
        
        # Since we can only see forward 180°, we can't safely back up
        # Determine escape direction based on what we can see
        left_clear = self._check_direction_clear(scan_data, 90)
        right_clear = self._check_direction_clear(scan_data, -90)
        
        if right_clear and (not left_clear or self.turn_direction == TurnDirection.RIGHT):
            # Turn right smoothly
            logger.info("Obstacle avoidance - Smooth right turn")
            self._set_motors_smooth("forward", self.turn_speed, "backward", self.turn_speed)
        elif left_clear:
            # Turn left smoothly
            logger.info("Obstacle avoidance - Smooth left turn")
            self._set_motors_smooth("backward", self.turn_speed, "forward", self.turn_speed)
        else:
            # Both sides blocked, turn in place to find opening
            logger.warning("Both sides blocked - Rotating in place")
            # Use full differential for tight spot
            self._set_motors("forward", self.turn_speed, "backward", self.turn_speed)
        
        time.sleep(0.5)
        self.state = RobotState.MOVING_FORWARD
    
    def _check_direction_clear(self, scan_data: Dict[str, Any], angle_deg: float) -> bool:
        """Check if direction is clear for movement"""
        distance = self._get_wall_distance(scan_data, angle_deg)
        return distance is None or distance > self.safety_distance
    
    def calibrate_background(self) -> bool:
        """Calibrate static background/robot components to remove from scans"""
        logger.info("Calibrating lidar background...")
        
        # Collect multiple scans while stationary
        scan_samples = []
        for i in range(self.static_scan_samples):
            scan_data = self.lidar_sensor.get_latest_scan()
            if scan_data and scan_data.get("points"):
                scan_samples.append(scan_data["points"])
                time.sleep(0.1)
        
        if len(scan_samples) < 5:
            logger.warning("Not enough samples for background calibration")
            return False
        
        # Find persistent obstacles (robot components)
        # These appear in the same location across all scans
        angle_bins = {}  # Group by angle
        
        for scan in scan_samples:
            for point in scan:
                angle = point.get("theta", point.get("angle", 0))
                angle_deg = int(math.degrees(angle))
                if angle_deg not in angle_bins:
                    angle_bins[angle_deg] = []
                distance = point.get("r", point.get("distance", 0))
                angle_bins[angle_deg].append(distance)
        
        # Find static obstacles
        self.static_obstacles = {}
        for angle_deg, distances in angle_bins.items():
            if len(distances) >= self.static_scan_samples * 0.8:  # Present in 80% of scans
                # Calculate variance
                mean_dist = np.mean(distances)
                variance = np.var(distances)
                
                # Low variance means static obstacle
                if variance < 0.01:  # 1cm variance threshold
                    self.static_obstacles[angle_deg] = {
                        "distance": mean_dist,
                        "variance": variance
                    }
                    logger.debug(f"Static obstacle at {angle_deg}°: {mean_dist:.2f}m")
        
        logger.info(f"Background calibration complete. Found {len(self.static_obstacles)} static points")
        return True
    
    def filter_static_obstacles(self, scan_data: Dict[str, Any]) -> Dict[str, Any]:
        """Remove static obstacles from scan data"""
        if not self.background_removal_enabled or not self.static_obstacles:
            return scan_data
        
        filtered_points = []
        removed_count = 0
        
        for point in scan_data.get("points", []):
            angle = point.get("theta", point.get("angle", 0))
            angle_deg = int(math.degrees(angle))
            distance = point.get("r", point.get("distance", 0))
            
            # Check if this matches a static obstacle
            is_static = False
            for static_angle in range(angle_deg - 2, angle_deg + 3):  # ±2 degree tolerance
                if static_angle in self.static_obstacles:
                    static_dist = self.static_obstacles[static_angle]["distance"]
                    if abs(distance - static_dist) < 0.05:  # 5cm tolerance
                        is_static = True
                        removed_count += 1
                        break
            
            if not is_static:
                filtered_points.append(point)
        
        # Update scan data
        filtered_data = scan_data.copy()
        filtered_data["points"] = filtered_points
        filtered_data["point_count"] = len(filtered_points)
        
        if removed_count > 0:
            logger.debug(f"Removed {removed_count} static points from scan")
        
        # Recalculate min distance
        if filtered_points:
            min_dist = min(p.get("r", p.get("distance", float('inf'))) for p in filtered_points)
            filtered_data["min_distance"] = min_dist
        
        return filtered_data
    
    def _set_motors_smooth(self, left_dir: str, left_speed: float, 
                          right_dir: str, right_speed: float):
        """
        Set motor speeds with smoother turning (avoid reverse direction)
        Note: Physical left/right are reversed in motor controller
        """
        # For turning, use one wheel stopped instead of reverse
        if left_dir == "forward" and right_dir == "backward":
            # Right turn - stop right wheel instead of reverse
            logger.debug("Right turn - stopping right wheel")
            self._set_motors("forward", left_speed, "brake", 0)
        elif left_dir == "backward" and right_dir == "forward":
            # Left turn - stop left wheel instead of reverse
            logger.debug("Left turn - stopping left wheel")
            self._set_motors("brake", 0, "forward", right_speed)
        else:
            # Normal operation
            self._set_motors(left_dir, left_speed, right_dir, right_speed)
    
    def _update_odometry(self):
        """Update robot position estimate based on motor commands"""
        # Simple dead reckoning - this is approximate
        current_time = time.time()
        dt = current_time - self.last_odometry_update
        self.last_odometry_update = current_time
        
        # Get current motor states
        motor_states = self.motor_controller.get_all_motor_states()
        
        # Calculate wheel velocities (mm/s) - approximate
        left_velocity = 0
        right_velocity = 0
        
        if motor_states[1]["direction"] == "forward":
            left_velocity = motor_states[1]["speed"] * 10  # mm/s at 100% speed
        elif motor_states[1]["direction"] == "backward":
            left_velocity = -motor_states[1]["speed"] * 10
        
        if motor_states[0]["direction"] == "forward":
            right_velocity = motor_states[0]["speed"] * 10
        elif motor_states[0]["direction"] == "backward":
            right_velocity = -motor_states[0]["speed"] * 10
        
        # Calculate robot velocity and angular velocity
        v = (left_velocity + right_velocity) / 2  # Linear velocity
        w = (right_velocity - left_velocity) / self.wheelbase  # Angular velocity
        
        # Update position
        if abs(w) < 0.001:  # Moving straight
            self.robot_x += v * dt * math.cos(self.robot_theta)
            self.robot_y += v * dt * math.sin(self.robot_theta)
        else:  # Turning
            # Use exact motion equations for differential drive
            self.robot_x += (v / w) * (math.sin(self.robot_theta + w * dt) - 
                                       math.sin(self.robot_theta))
            self.robot_y += (v / w) * (-math.cos(self.robot_theta + w * dt) + 
                                       math.cos(self.robot_theta))
            self.robot_theta += w * dt
        
        # Normalize angle
        self.robot_theta = self.robot_theta % (2 * math.pi)
        
        # Update visited cells (10cm grid)
        grid_x = int(self.robot_x / 100)
        grid_y = int(self.robot_y / 100)
        self.visited_cells.add((grid_x, grid_y))
    
    def _emergency_stop(self):
        """Execute emergency stop with smooth recovery"""
        logger.warning("Emergency stop activated!")
        self.motor_controller.stop_all_motors()
        self.state = RobotState.EMERGENCY_STOP
        
        # Don't back up blindly - we can't see behind
        time.sleep(1.0)
        
        # Try to turn in place to find a clear path
        logger.info("Attempting recovery - smooth rotation to find clear path")
        
        # Use smooth turn first
        self._set_motors_smooth("forward", self.turn_speed, "backward", self.turn_speed)
        time.sleep(1.5)  # Turn about 90 degrees
        self.motor_controller.stop_all_motors()
        
        # Check if we have a clear path now
        scan_data = self.lidar_sensor.get_latest_scan()
        if scan_data:
            filtered_scan = self.filter_static_obstacles(scan_data)
            min_distance = filtered_scan.get("min_distance", 0) * 1000
            if min_distance > self.safety_distance:
                # Path is clear, resume
                if self.mapping_active:
                    self.state = RobotState.MOVING_FORWARD
                    self.emergency_stop = False
                    logger.info("Recovery complete, clear path found")
            else:
                # Still blocked, try full differential turn
                logger.warning("Still blocked, trying full rotation")
                self._set_motors("forward", self.turn_speed, "backward", self.turn_speed)
                time.sleep(1.5)
                self.motor_controller.stop_all_motors()
                
                # Try one more time
                if self.mapping_active:
                    self.state = RobotState.IDLE
                    self.emergency_stop = False

# Singleton instance
_auto_mapper = None

def get_auto_mapper(motor_controller=None, lidar_sensor=None):
    """Get or create AutoMapper instance"""
    global _auto_mapper
    if _auto_mapper is None and motor_controller and lidar_sensor:
        _auto_mapper = AutoMapper(motor_controller, lidar_sensor)
    return _auto_mapper
================================================================================


================================================================================
FILE: backend/automation_aiming.py
Category: Python | Size: 15.5 KB | Lines: 418
================================================================================
#!/usr/bin/env python3
"""
Automated Aiming System
Uses thermal camera to detect hot spots and controls servos to aim at targets
"""

import logging
import threading
import time
import math
from typing import Dict, Any, Optional, Tuple, List
from datetime import datetime

logger = logging.getLogger(__name__)

class AutoAiming:
    """Automated aiming system for targeting heat sources"""
    
    def __init__(self, servo_controller, thermal_camera_sensor):
        """
        Initialize auto aiming system
        
        Args:
            servo_controller: ServoController instance
            thermal_camera_sensor: ThermalCameraSensor instance
        """
        self.servo_controller = servo_controller
        self.thermal_camera = thermal_camera_sensor
        
        # State management
        self.enabled = False
        self.tracking_active = False
        self._tracking_thread = None
        self._stop_thread = False
        
        # Target parameters
        self.target_threshold = 100.0  # Celsius
        self.current_target = None
        self.last_target_time = None
        
        # Servo limits (±60 degrees from center)
        self.pan_center = 135.0
        self.tilt_center = 135.0
        self.max_deviation = 60.0  # Maximum degrees from center
        
        # Servo range mapping
        # Servo range: 75-195 degrees (120 degree range)
        # We limit to ±60 degrees from center (135)
        self.pan_min = max(75.0, self.pan_center - self.max_deviation)    # 75
        self.pan_max = min(195.0, self.pan_center + self.max_deviation)   # 195
        self.tilt_min = max(75.0, self.tilt_center - self.max_deviation)  # 75
        self.tilt_max = min(195.0, self.tilt_center + self.max_deviation) # 195
        
        # Thermal camera FOV (approximate)
        self.thermal_fov_horizontal = 55.0  # degrees
        self.thermal_fov_vertical = 35.0    # degrees
        
        # Control parameters
        self.update_rate = 10  # Hz for checking targets
        self.movement_threshold = 5.0  # Minimum angle change to trigger movement (degrees)
        self.smoothing_factor = 0.3  # For exponential smoothing
        
        # Rate limiting for servo commands
        self.min_command_interval = 2.0  # Minimum seconds between servo commands
        self.last_command_time = 0  # Time of last servo command
        self.command_cooldown = False  # Whether we're in cooldown period
        
        # Dead zone to prevent jitter
        self.dead_zone = 3.0  # Degrees - don't move if within this range
        
        # Tracking state
        self.last_pan = self.pan_center
        self.last_tilt = self.tilt_center
        self.target_pan = self.pan_center
        self.target_tilt = self.tilt_center
        
        # Target stability
        self.target_stable_count = 0
        self.target_stability_threshold = 3  # Number of consistent detections before moving
        self.last_stable_target = None
        
        logger.info("Auto aiming system initialized with rate limiting")
    
    def enable(self) -> Dict[str, Any]:
        """Enable auto aiming"""
        if self.enabled:
            return {
                "success": False,
                "error": "Auto aiming already enabled"
            }
        
        # Subscribe to thermal camera if not already
        if not self.thermal_camera.subscription_active:
            success = self.thermal_camera.subscribe()
            if not success:
                return {
                    "success": False,
                    "error": "Failed to subscribe to thermal camera"
                }
        
        self.enabled = True
        self.tracking_active = True
        self._stop_thread = False
        
        # Reset rate limiting
        self.last_command_time = 0
        self.command_cooldown = False
        
        # Start tracking thread
        self._tracking_thread = threading.Thread(target=self._tracking_loop)
        self._tracking_thread.daemon = True
        self._tracking_thread.start()
        
        logger.info("Auto aiming enabled")
        return {
            "success": True,
            "message": "Auto aiming enabled"
        }
    
    def disable(self) -> Dict[str, Any]:
        """Disable auto aiming"""
        if not self.enabled:
            return {
                "success": False,
                "error": "Auto aiming not enabled"
            }
        
        self.enabled = False
        self.tracking_active = False
        self._stop_thread = True
        
        # Wait for thread to stop
        if self._tracking_thread:
            self._tracking_thread.join(timeout=2.0)
        
        # Return servos to center
        self.servo_controller.center_position()
        
        logger.info("Auto aiming disabled")
        return {
            "success": True,
            "message": "Auto aiming disabled"
        }
    
    def _tracking_loop(self):
        """Main tracking loop with rate limiting"""
        logger.info("Auto aiming tracking loop started")
        
        while self.tracking_active and not self._stop_thread:
            try:
                # Get latest thermal frame
                frame_data = self.thermal_camera.get_latest_frame()
                
                if frame_data:
                    # Find targets
                    targets = self._find_targets(frame_data)
                    
                    if targets:
                        # Select leftmost target if multiple
                        target = self._select_target(targets)
                        
                        # Check target stability
                        if self._is_target_stable(target):
                            self.current_target = target
                            self.last_target_time = datetime.now()
                            
                            # Calculate servo angles
                            pan_angle, tilt_angle = self._calculate_servo_angles(
                                target, frame_data['width'], frame_data['height']
                            )
                            
                            # Apply smoothing
                            pan_angle = self._smooth_angle(pan_angle, self.target_pan)
                            tilt_angle = self._smooth_angle(tilt_angle, self.target_tilt)
                            
                            # Update target angles
                            self.target_pan = pan_angle
                            self.target_tilt = tilt_angle
                            
                            # Check if we should move servos
                            if self._should_move_servos(pan_angle, tilt_angle):
                                # Send servo command with rate limiting
                                self._send_servo_command(pan_angle, tilt_angle)
                    else:
                        self.current_target = None
                        self.target_stable_count = 0
                        self.last_stable_target = None
                
                # Sleep for update rate
                time.sleep(1.0 / self.update_rate)
                
            except Exception as e:
                logger.error(f"Error in tracking loop: {e}")
                time.sleep(0.1)
        
        logger.info("Auto aiming tracking loop ended")
    
    def _is_target_stable(self, target: Dict[str, Any]) -> bool:
        """Check if target is stable enough to track"""
        if self.last_stable_target is None:
            self.last_stable_target = target
            self.target_stable_count = 1
            return False
        
        # Check if target is similar to last one
        distance = math.sqrt(
            (target['x'] - self.last_stable_target['x'])**2 + 
            (target['y'] - self.last_stable_target['y'])**2
        )
        
        if distance < 2:  # Within 2 pixels
            self.target_stable_count += 1
            if self.target_stable_count >= self.target_stability_threshold:
                return True
        else:
            # Target moved, reset stability
            self.last_stable_target = target
            self.target_stable_count = 1
        
        return False
    
    def _should_move_servos(self, pan_angle: float, tilt_angle: float) -> bool:
        """Determine if servos should be moved based on dead zone and movement threshold"""
        # Calculate angle differences
        pan_diff = abs(pan_angle - self.last_pan)
        tilt_diff = abs(tilt_angle - self.last_tilt)
        
        # Check dead zone
        if pan_diff < self.dead_zone and tilt_diff < self.dead_zone:
            return False
        
        # Check movement threshold
        if pan_diff < self.movement_threshold and tilt_diff < self.movement_threshold:
            return False
        
        # Check rate limiting
        current_time = time.time()
        time_since_last = current_time - self.last_command_time
        
        if time_since_last < self.min_command_interval:
            # Still in cooldown period
            if not self.command_cooldown:
                self.command_cooldown = True
                logger.debug(f"Rate limiting: waiting {self.min_command_interval - time_since_last:.1f}s before next command")
            return False
        
        # Ready to send command
        self.command_cooldown = False
        return True
    
    def _send_servo_command(self, pan_angle: float, tilt_angle: float):
        """Send servo command with rate limiting"""
        current_time = time.time()
        
        # Double-check rate limiting
        if current_time - self.last_command_time < self.min_command_interval:
            logger.warning("Rate limit check failed, skipping command")
            return
        
        # Send command
        result = self.servo_controller.move_to_position(pan_angle, tilt_angle)
        
        if result['success']:
            self.last_pan = pan_angle
            self.last_tilt = tilt_angle
            self.last_command_time = current_time
            
            logger.info(f"Servo command sent: Pan={pan_angle:.1f}°, Tilt={tilt_angle:.1f}° "
                       f"(Target at {self.current_target['x']}, {self.current_target['y']} "
                       f"@ {self.current_target['temp']:.1f}°C)")
        else:
            logger.error(f"Failed to send servo command: {result.get('error', 'Unknown error')}")
    
    def _find_targets(self, frame_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Find all heat targets above threshold"""
        targets = []
        
        if not frame_data or 'thermal_data' not in frame_data:
            return targets
        
        thermal_data = frame_data['thermal_data']
        width = frame_data['width']
        height = frame_data['height']
        
        # Scan thermal data for hot spots
        for y in range(height):
            for x in range(width):
                temp = thermal_data[y][x]
                
                if temp >= self.target_threshold:
                    targets.append({
                        'x': x,
                        'y': y,
                        'temp': temp,
                        'grid_x': x,
                        'grid_y': y
                    })
        
        # Sort by temperature (highest first)
        targets.sort(key=lambda t: t['temp'], reverse=True)
        
        return targets
    
    def _select_target(self, targets: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Select target - leftmost if multiple"""
        if not targets:
            return None
        
        # If only one target, return it
        if len(targets) == 1:
            return targets[0]
        
        # Find leftmost target (minimum x coordinate)
        leftmost = min(targets, key=lambda t: t['x'])
        return leftmost
    
    def _calculate_servo_angles(self, target: Dict[str, Any], 
                               frame_width: int, frame_height: int) -> Tuple[float, float]:
        """Calculate servo angles to aim at target"""
        # Get target position as fraction of frame (0-1)
        target_x_norm = target['x'] / (frame_width - 1)
        target_y_norm = target['y'] / (frame_height - 1)
        
        # Convert to angle offset from center (-0.5 to 0.5)
        # Note: X is inverted because left in image = right in real world
        x_offset = 0.5 - target_x_norm
        y_offset = target_y_norm - 0.5
        
        # Convert to degrees based on FOV
        pan_offset = x_offset * self.thermal_fov_horizontal
        tilt_offset = y_offset * self.thermal_fov_vertical
        
        # Calculate target servo angles
        target_pan = self.pan_center + pan_offset
        target_tilt = self.tilt_center + tilt_offset
        
        # Apply limits (±60 degrees from center)
        target_pan = max(self.pan_min, min(self.pan_max, target_pan))
        target_tilt = max(self.tilt_min, min(self.tilt_max, target_tilt))
        
        return target_pan, target_tilt
    
    def _smooth_angle(self, new_angle: float, last_angle: float) -> float:
        """Apply exponential smoothing to angle"""
        return last_angle + self.smoothing_factor * (new_angle - last_angle)
    
    def get_status(self) -> Dict[str, Any]:
        """Get auto aiming status"""
        status = {
            "enabled": self.enabled,
            "tracking_active": self.tracking_active,
            "target_threshold": self.target_threshold,
            "current_target": None,
            "last_target_time": None,
            "servo_position": {
                "pan": self.last_pan,
                "tilt": self.last_tilt
            },
            "rate_limit_status": {
                "min_interval": self.min_command_interval,
                "in_cooldown": self.command_cooldown,
                "time_since_last": time.time() - self.last_command_time if self.last_command_time > 0 else None
            }
        }
        
        if self.current_target:
            status["current_target"] = {
                "x": self.current_target['x'],
                "y": self.current_target['y'],
                "temperature": self.current_target['temp']
            }
        
        if self.last_target_time:
            status["last_target_time"] = self.last_target_time.isoformat()
        
        return status
    
    def set_threshold(self, threshold: float) -> Dict[str, Any]:
        """Set temperature threshold for targeting"""
        if threshold < 30.0 or threshold > 300.0:
            return {
                "success": False,
                "error": "Threshold must be between 30°C and 300°C"
            }
        
        self.target_threshold = threshold
        logger.info(f"Target threshold set to {threshold}°C")
        
        return {
            "success": True,
            "threshold": threshold
        }
    
    def set_rate_limit(self, interval: float) -> Dict[str, Any]:
        """Set minimum interval between servo commands"""
        if interval < 0.5 or interval > 10.0:
            return {
                "success": False,
                "error": "Interval must be between 0.5 and 10 seconds"
            }
        
        self.min_command_interval = interval
        logger.info(f"Rate limit set to {interval} seconds")
        
        return {
            "success": True,
            "interval": interval
        }

# Singleton instance
_auto_aiming = None

def get_auto_aiming(servo_controller=None, thermal_camera_sensor=None):
    """Get or create AutoAiming instance"""
    global _auto_aiming
    if _auto_aiming is None and servo_controller and thermal_camera_sensor:
        _auto_aiming = AutoAiming(servo_controller, thermal_camera_sensor)
    return _auto_aiming
================================================================================


================================================================================
FILE: backend/automation_v2.py
Category: Python | Size: 34.6 KB | Lines: 885
================================================================================
#!/usr/bin/env python3
"""
Automation module v2 for robot mapping and pathfinding
Implements improved algorithms inspired by PythonRobotics
- Bug2 algorithm for navigation
- Probabilistic occupancy grid mapping
- Improved wall following with proper turning
"""

import logging
import threading
import time
import numpy as np
from typing import Dict, List, Tuple, Optional, Any
from enum import Enum
from collections import deque
import math
from dataclasses import dataclass
from scipy.ndimage import binary_dilation

logger = logging.getLogger(__name__)

class RobotState(Enum):
    """Robot states for mapping"""
    IDLE = "idle"
    MOVING_TO_GOAL = "moving_to_goal"
    WALL_FOLLOWING = "wall_following"
    OBSTACLE_AVOIDANCE = "obstacle_avoidance"
    ROTATING = "rotating"
    EMERGENCY_STOP = "emergency_stop"
    EXPLORING = "exploring"

class WallFollowSide(Enum):
    """Which side to follow the wall"""
    LEFT = "left"
    RIGHT = "right"

@dataclass
class Point:
    """2D point"""
    x: float
    y: float
    
    def distance_to(self, other: 'Point') -> float:
        return math.sqrt((self.x - other.x)**2 + (self.y - other.y)**2)
    
    def angle_to(self, other: 'Point') -> float:
        return math.atan2(other.y - self.y, other.x - self.x)

@dataclass
class Goal:
    """Goal position for navigation"""
    position: Point
    tolerance: float = 100.0  # mm

class OccupancyGrid:
    """Probabilistic occupancy grid map"""
    
    def __init__(self, width: int, height: int, resolution: float):
        """
        Args:
            width: Grid width in cells
            height: Grid height in cells
            resolution: Cell size in meters
        """
        self.width = width
        self.height = height
        self.resolution = resolution
        self.grid = np.ones((height, width)) * 0.5  # Initialize as unknown (0.5)
        
        # Log-odds parameters
        self.l_occupied = 0.4  # Log-odds for occupied
        self.l_free = -0.4    # Log-odds for free
        self.l_min = -2.0     # Min log-odds (cap)
        self.l_max = 2.0      # Max log-odds (cap)
        
        # Convert to log-odds
        self.log_odds = np.log(self.grid / (1 - self.grid))
    
    def world_to_grid(self, x: float, y: float) -> Tuple[int, int]:
        """Convert world coordinates (mm) to grid indices"""
        grid_x = int((x / 1000.0 + self.width * self.resolution / 2) / self.resolution)
        grid_y = int((y / 1000.0 + self.height * self.resolution / 2) / self.resolution)
        return grid_x, grid_y
    
    def grid_to_world(self, grid_x: int, grid_y: int) -> Tuple[float, float]:
        """Convert grid indices to world coordinates (mm)"""
        x = (grid_x * self.resolution - self.width * self.resolution / 2) * 1000
        y = (grid_y * self.resolution - self.height * self.resolution / 2) * 1000
        return x, y
    
    def is_valid_cell(self, grid_x: int, grid_y: int) -> bool:
        """Check if grid cell is within bounds"""
        return 0 <= grid_x < self.width and 0 <= grid_y < self.height
    
    def update_cell(self, grid_x: int, grid_y: int, occupied: bool):
        """Update cell probability using log-odds"""
        if not self.is_valid_cell(grid_x, grid_y):
            return
        
        # Update log-odds
        if occupied:
            self.log_odds[grid_y, grid_x] += self.l_occupied
        else:
            self.log_odds[grid_y, grid_x] += self.l_free
        
        # Clamp log-odds
        self.log_odds[grid_y, grid_x] = np.clip(
            self.log_odds[grid_y, grid_x], self.l_min, self.l_max
        )
    
    def get_probability(self, grid_x: int, grid_y: int) -> float:
        """Get occupancy probability for a cell"""
        if not self.is_valid_cell(grid_x, grid_y):
            return 0.5  # Unknown
        
        # Convert log-odds back to probability
        return 1.0 - 1.0 / (1.0 + np.exp(self.log_odds[grid_y, grid_x]))
    
    def ray_cast(self, start_x: float, start_y: float, end_x: float, end_y: float):
        """Update cells along a ray (Bresenham's line algorithm)"""
        # Convert to grid coordinates
        x0, y0 = self.world_to_grid(start_x, start_y)
        x1, y1 = self.world_to_grid(end_x, end_y)
        
        # Bresenham's line algorithm
        cells = []
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        sx = 1 if x0 < x1 else -1
        sy = 1 if y0 < y1 else -1
        err = dx - dy
        
        x, y = x0, y0
        while True:
            if self.is_valid_cell(x, y):
                cells.append((x, y))
            
            if x == x1 and y == y1:
                break
            
            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                x += sx
            if e2 < dx:
                err += dx
                y += sy
        
        # Mark cells as free except the last one (obstacle)
        for i, (cx, cy) in enumerate(cells[:-1]):
            self.update_cell(cx, cy, occupied=False)
        
        # Mark last cell as occupied if within range
        if cells and len(cells) > 1:
            self.update_cell(cells[-1][0], cells[-1][1], occupied=True)

class AutoMapperV2:
    """Autonomous mapping using improved algorithms"""
    
    def __init__(self, motor_controller, lidar_sensor):
        """
        Initialize the auto mapper v2
        
        Args:
            motor_controller: Motor controller instance
            lidar_sensor: Lidar sensor instance
        """
        self.motor_controller = motor_controller
        self.lidar_sensor = lidar_sensor
        
        # Robot dimensions (in mm)
        self.robot_length = 500  # mm
        self.robot_width = 450   # mm
        self.wheelbase = 400     # mm
        
        # Sensor configuration
        self.lidar_offset_x = 0  # Lidar at center
        self.lidar_offset_y = self.robot_length / 2  # At front
        
        # Safety parameters (mm)
        self.safety_distance = 400      # Safety buffer from obstacles
        self.critical_distance = 250    # Emergency stop distance
        self.wall_follow_distance = 600 # Ideal wall following distance
        self.wall_follow_tolerance = 100
        
        # Speed parameters (0-100%)
        self.base_speed = 80      # Normal forward speed
        self.turn_speed = 70      # Speed during turns
        self.slow_speed = 60      # Slow speed for careful movement
        self.explore_speed = 85   # Speed for exploration
        
        # Control parameters
        self.command_delay = 0.1  # Delay between commands
        self.rotation_time_per_degree = 0.015  # Time to rotate 1 degree
        
        # State management
        self.state = RobotState.IDLE
        self.wall_follow_side = WallFollowSide.RIGHT
        self.mapping_active = False
        self.emergency_stop = False
        self._mapping_thread = None
        self._state_lock = threading.Lock()
        
        # Navigation
        self.current_goal = None
        self.exploration_goals = []
        self.visited_goals = set()
        
        # Odometry (simple dead reckoning)
        self.robot_pose = Point(0.0, 0.0)
        self.robot_theta = 0.0  # radians
        self.last_odometry_update = time.time()
        
        # Mapping
        self.occupancy_grid = OccupancyGrid(200, 200, 0.05)  # 10m x 10m, 5cm resolution
        self.path_history = deque(maxlen=5000)
        
        # Static obstacle removal
        self.static_scan_buffer = deque(maxlen=20)
        self.static_obstacles = {}  # Persistent obstacles to filter
        self.calibration_complete = False
        
        # Wall following state
        self.wall_lost_count = 0
        self.wall_lost_threshold = 10
        self.last_wall_distance = None
        
        # Bug2 algorithm state
        self.m_line_start = None
        self.m_line_goal = None
        self.hit_points = []
        self.leave_points = []
        self.following_wall = False
        
        logger.info("AutoMapper v2 initialized")
    
    def _set_motors(self, left_dir: str, left_speed: float, 
                    right_dir: str, right_speed: float):
        """
        Set motor speeds with proper constraints
        IMPORTANT: Cannot reverse motors - must stop one side for turning
        """
        # Ensure we don't reverse motors for turning
        if (left_dir == "forward" and right_dir == "backward") or \
           (left_dir == "backward" and right_dir == "forward"):
            # Convert to single-wheel turning
            if left_dir == "forward":
                # Turn right - stop right wheel
                self.motor_controller.set_motor(0, "brake", 0)
                time.sleep(self.command_delay)
                self.motor_controller.set_motor(1, left_dir, left_speed)
            else:
                # Turn left - stop left wheel  
                self.motor_controller.set_motor(1, "brake", 0)
                time.sleep(self.command_delay)
                self.motor_controller.set_motor(0, right_dir, right_speed)
        else:
            # Normal operation - both wheels same direction or brake
            self.motor_controller.set_motor(0, right_dir, right_speed)
            time.sleep(self.command_delay)
            self.motor_controller.set_motor(1, left_dir, left_speed)
    
    def start_mapping(self, goal_x: float = None, goal_y: float = None) -> bool:
        """
        Start autonomous mapping
        
        Args:
            goal_x: Optional goal X coordinate in mm
            goal_y: Optional goal Y coordinate in mm
        """
        with self._state_lock:
            if self.mapping_active:
                logger.warning("Mapping already active")
                return False
            
            self.mapping_active = True
            self.emergency_stop = False
            self.state = RobotState.IDLE
            
            # Set goal if provided
            if goal_x is not None and goal_y is not None:
                self.current_goal = Goal(Point(goal_x, goal_y))
                logger.info(f"Goal set to ({goal_x}, {goal_y})")
            
            # Reset state
            self.robot_pose = Point(0.0, 0.0)
            self.robot_theta = 0.0
            self.path_history.clear()
            self.hit_points.clear()
            self.leave_points.clear()
            
            # Calibrate if not done
            if not self.calibration_complete:
                self.calibrate_static_obstacles()
            
            # Start mapping thread
            self._mapping_thread = threading.Thread(target=self._mapping_loop)
            self._mapping_thread.daemon = True
            self._mapping_thread.start()
            
            logger.info("Started autonomous mapping v2")
            return True
    
    def stop_mapping(self) -> bool:
        """Stop autonomous mapping"""
        with self._state_lock:
            if not self.mapping_active:
                return False
            
            self.mapping_active = False
            self.emergency_stop = True
            
        # Stop all motors
        self.motor_controller.stop_all_motors()
        
        # Wait for thread to finish
        if self._mapping_thread:
            self._mapping_thread.join(timeout=5.0)
        
        logger.info("Stopped autonomous mapping")
        return True
    
    def calibrate_static_obstacles(self):
        """Calibrate static obstacles (robot parts) in lidar view"""
        logger.info("Calibrating static obstacles...")
        
        # Collect scans while stationary
        samples = []
        for _ in range(10):
            scan_data = self.lidar_sensor.get_latest_scan()
            if scan_data and scan_data.get("points"):
                samples.append(scan_data["points"])
            time.sleep(0.1)
        
        if len(samples) < 5:
            logger.warning("Not enough samples for calibration")
            return
        
        # Find persistent points (robot structure)
        angle_bins = {}
        for scan in samples:
            for point in scan:
                angle_deg = int(math.degrees(point.get("theta", 0)))
                distance = point.get("r", 0)
                
                if angle_deg not in angle_bins:
                    angle_bins[angle_deg] = []
                angle_bins[angle_deg].append(distance)
        
        # Identify static obstacles
        self.static_obstacles = {}
        for angle_deg, distances in angle_bins.items():
            if len(distances) >= len(samples) * 0.8:  # Present in 80% of scans
                mean_dist = np.mean(distances)
                std_dist = np.std(distances)
                
                # Low variance = static obstacle
                if std_dist < 0.02:  # 2cm threshold
                    self.static_obstacles[angle_deg] = {
                        "distance": mean_dist,
                        "std": std_dist
                    }
        
        self.calibration_complete = True
        logger.info(f"Calibration complete. Found {len(self.static_obstacles)} static points")
    
    def filter_static_obstacles(self, scan_data: Dict[str, Any]) -> Dict[str, Any]:
        """Remove static obstacles from scan data"""
        if not self.calibration_complete or not scan_data.get("points"):
            return scan_data
        
        filtered_points = []
        for point in scan_data["points"]:
            angle_deg = int(math.degrees(point.get("theta", 0)))
            distance = point.get("r", 0)
            
            # Check if this matches a static obstacle
            is_static = False
            for static_angle in range(angle_deg - 2, angle_deg + 3):
                if static_angle in self.static_obstacles:
                    static_dist = self.static_obstacles[static_angle]["distance"]
                    if abs(distance - static_dist) < 0.05:  # 5cm tolerance
                        is_static = True
                        break
            
            if not is_static:
                filtered_points.append(point)
        
        # Update scan data
        filtered_data = scan_data.copy()
        filtered_data["points"] = filtered_points
        filtered_data["point_count"] = len(filtered_points)
        
        # Recalculate min distance
        if filtered_points:
            min_dist = min(p.get("r", float('inf')) for p in filtered_points)
            filtered_data["min_distance"] = min_dist
        
        return filtered_data
    
    def _mapping_loop(self):
        """Main mapping loop with improved state machine"""
        logger.info("Mapping loop v2 started")
        
        # Wait for sensors
        time.sleep(2.0)
        
        while self.mapping_active and not self.emergency_stop:
            try:
                # Get and filter lidar scan
                scan_data = self.lidar_sensor.get_latest_scan()
                if not scan_data:
                    time.sleep(0.1)
                    continue
                
                # Filter static obstacles
                filtered_scan = self.filter_static_obstacles(scan_data)
                
                # Update occupancy grid
                self._update_occupancy_grid(filtered_scan)
                
                # Process scan and decide action
                self._process_scan(filtered_scan)
                
                # Execute state-based behavior
                if self.state == RobotState.MOVING_TO_GOAL:
                    self._move_to_goal(filtered_scan)
                elif self.state == RobotState.WALL_FOLLOWING:
                    self._follow_wall(filtered_scan)
                elif self.state == RobotState.OBSTACLE_AVOIDANCE:
                    self._avoid_obstacle(filtered_scan)
                elif self.state == RobotState.ROTATING:
                    self._execute_rotation(filtered_scan)
                elif self.state == RobotState.EXPLORING:
                    self._explore(filtered_scan)
                elif self.state == RobotState.EMERGENCY_STOP:
                    self._emergency_stop()
                    break
                
                # Update odometry
                self._update_odometry()
                
                # Record path
                self.path_history.append(Point(self.robot_pose.x, self.robot_pose.y))
                
                # Small delay
                time.sleep(0.05)
                
            except Exception as e:
                logger.error(f"Error in mapping loop: {e}")
                self._emergency_stop()
                break
        
        # Ensure motors are stopped
        self.motor_controller.stop_all_motors()
        logger.info("Mapping loop ended")
    
    def _process_scan(self, scan_data: Dict[str, Any]):
        """Process lidar scan and determine robot state"""
        min_distance = scan_data.get("min_distance", float('inf')) * 1000  # to mm
        
        # Check for emergency stop
        if min_distance < self.critical_distance:
            logger.warning(f"CRITICAL: Obstacle at {min_distance}mm - Emergency stop!")
            self.state = RobotState.EMERGENCY_STOP
            return
        
        # Check for obstacles requiring avoidance
        if min_distance < self.safety_distance:
            if self.state != RobotState.WALL_FOLLOWING:
                logger.info(f"Obstacle detected at {min_distance}mm - Avoiding")
                self.state = RobotState.OBSTACLE_AVOIDANCE
            return
        
        # Determine behavior based on current state and goal
        if self.current_goal and not self.following_wall:
            # Check if we can move toward goal
            if self._is_path_clear_to_goal(scan_data):
                self.state = RobotState.MOVING_TO_GOAL
            else:
                # Start wall following (Bug2)
                self.following_wall = True
                self.state = RobotState.WALL_FOLLOWING
                self.hit_points.append(Point(self.robot_pose.x, self.robot_pose.y))
                logger.info("Path blocked - starting wall following")
        elif self.following_wall:
            # Continue wall following until we can leave
            if self._can_leave_wall(scan_data):
                self.following_wall = False
                self.state = RobotState.MOVING_TO_GOAL
                self.leave_points.append(Point(self.robot_pose.x, self.robot_pose.y))
                logger.info("Can reach goal - leaving wall")
        else:
            # No goal - explore
            self.state = RobotState.EXPLORING
    
    def _update_occupancy_grid(self, scan_data: Dict[str, Any]):
        """Update occupancy grid with scan data"""
        if not scan_data.get("points"):
            return
        
        # Robot position in world frame
        robot_x = self.robot_pose.x
        robot_y = self.robot_pose.y
        
        # Lidar position in world frame
        lidar_x = robot_x + self.lidar_offset_x * math.cos(self.robot_theta) - \
                  self.lidar_offset_y * math.sin(self.robot_theta)
        lidar_y = robot_y + self.lidar_offset_x * math.sin(self.robot_theta) + \
                  self.lidar_offset_y * math.cos(self.robot_theta)
        
        # Update grid with each scan point
        for point in scan_data["points"]:
            if point["r"] > 0.1 and point["r"] < 10.0:  # Valid range
                # Point in world frame
                world_angle = point["theta"] + self.robot_theta
                end_x = lidar_x + point["r"] * 1000 * math.cos(world_angle)
                end_y = lidar_y + point["r"] * 1000 * math.sin(world_angle)
                
                # Ray cast to update cells
                self.occupancy_grid.ray_cast(lidar_x, lidar_y, end_x, end_y)
    
    def _is_path_clear_to_goal(self, scan_data: Dict[str, Any]) -> bool:
        """Check if path to goal is clear"""
        if not self.current_goal:
            return False
        
        # Calculate angle to goal
        goal_angle = self.robot_pose.angle_to(self.current_goal.position)
        angle_diff = self._normalize_angle(goal_angle - self.robot_theta)
        
        # Check if goal is in front (±45 degrees)
        if abs(angle_diff) > math.pi / 4:
            return False
        
        # Check for obstacles in goal direction
        for point in scan_data.get("points", []):
            point_angle = self._normalize_angle(point["theta"])
            if abs(point_angle - angle_diff) < math.pi / 6:  # ±30 degrees
                if point["r"] * 1000 < self.robot_pose.distance_to(self.current_goal.position):
                    return False
        
        return True
    
    def _can_leave_wall(self, scan_data: Dict[str, Any]) -> bool:
        """Check if robot can leave wall (Bug2 condition)"""
        if not self.current_goal or not self.m_line_start:
            return False
        
        # Check if we're on the M-line
        distance_to_line = self._distance_to_m_line()
        if distance_to_line > 100:  # Not on M-line
            return False
        
        # Check if path to goal is clear
        return self._is_path_clear_to_goal(scan_data)
    
    def _distance_to_m_line(self) -> float:
        """Calculate distance to M-line (line from start to goal)"""
        if not self.m_line_start or not self.m_line_goal:
            return float('inf')
        
        # Point-to-line distance formula
        x0, y0 = self.robot_pose.x, self.robot_pose.y
        x1, y1 = self.m_line_start.x, self.m_line_start.y
        x2, y2 = self.m_line_goal.x, self.m_line_goal.y
        
        num = abs((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1)
        den = math.sqrt((y2-y1)**2 + (x2-x1)**2)
        
        return num / den if den > 0 else float('inf')
    
    def _move_to_goal(self, scan_data: Dict[str, Any]):
        """Move toward goal using simple proportional control"""
        if not self.current_goal:
            self.state = RobotState.EXPLORING
            return
        
        # Check if reached goal
        distance_to_goal = self.robot_pose.distance_to(self.current_goal.position)
        if distance_to_goal < self.current_goal.tolerance:
            logger.info("Goal reached!")
            self.visited_goals.add((self.current_goal.position.x, self.current_goal.position.y))
            self.current_goal = None
            self.state = RobotState.IDLE
            return
        
        # Calculate angle to goal
        goal_angle = self.robot_pose.angle_to(self.current_goal.position)
        angle_error = self._normalize_angle(goal_angle - self.robot_theta)
        
        # Proportional control for steering
        if abs(angle_error) > math.pi / 6:  # > 30 degrees
            # Need to rotate
            self.state = RobotState.ROTATING
            self.target_angle = goal_angle
        else:
            # Move forward with steering adjustment
            steer_gain = 0.5
            speed_diff = steer_gain * angle_error
            
            left_speed = self.base_speed - speed_diff * 10
            right_speed = self.base_speed + speed_diff * 10
            
            # Clamp speeds
            left_speed = max(self.slow_speed, min(100, left_speed))
            right_speed = max(self.slow_speed, min(100, right_speed))
            
            self._set_motors("forward", left_speed, "forward", right_speed)
    
    def _follow_wall(self, scan_data: Dict[str, Any]):
        """Follow wall using single-wheel turning"""
        # Get wall distance on following side
        if self.wall_follow_side == WallFollowSide.RIGHT:
            wall_angle = -math.pi / 2  # -90 degrees
            front_angle = -math.pi / 4  # -45 degrees
        else:
            wall_angle = math.pi / 2   # 90 degrees
            front_angle = math.pi / 4   # 45 degrees
        
        wall_distance = self._get_distance_at_angle(scan_data, wall_angle)
        front_distance = self._get_distance_at_angle(scan_data, 0)
        diagonal_distance = self._get_distance_at_angle(scan_data, front_angle)
        
        # Check if wall is lost
        if wall_distance is None or wall_distance > self.wall_follow_distance * 2:
            self.wall_lost_count += 1
            if self.wall_lost_count > self.wall_lost_threshold:
                # Wall lost - try to find it again
                logger.info("Wall lost - searching")
                if self.wall_follow_side == WallFollowSide.RIGHT:
                    # Turn right to find wall
                    self._set_motors("forward", self.turn_speed, "brake", 0)
                else:
                    # Turn left to find wall
                    self._set_motors("brake", 0, "forward", self.turn_speed)
                return
        else:
            self.wall_lost_count = 0
        
        # Check front obstacle
        if front_distance and front_distance < self.wall_follow_distance:
            # Turn away from wall
            logger.info("Front obstacle - turning away from wall")
            if self.wall_follow_side == WallFollowSide.RIGHT:
                # Turn left (away from right wall)
                self._set_motors("brake", 0, "forward", self.turn_speed)
            else:
                # Turn right (away from left wall)
                self._set_motors("forward", self.turn_speed, "brake", 0)
            return
        
        # Normal wall following with proportional control
        if wall_distance:
            error = wall_distance - self.wall_follow_distance
            
            # Simple P controller
            kp = 0.1
            correction = kp * error
            
            # Apply correction using single-wheel turning
            if abs(error) > self.wall_follow_tolerance:
                if error > 0:  # Too far from wall
                    if self.wall_follow_side == WallFollowSide.RIGHT:
                        # Turn right slightly
                        left_speed = self.base_speed
                        right_speed = max(0, self.base_speed - abs(correction))
                    else:
                        # Turn left slightly
                        left_speed = max(0, self.base_speed - abs(correction))
                        right_speed = self.base_speed
                else:  # Too close to wall
                    if self.wall_follow_side == WallFollowSide.RIGHT:
                        # Turn left slightly
                        left_speed = max(0, self.base_speed - abs(correction))
                        right_speed = self.base_speed
                    else:
                        # Turn right slightly
                        left_speed = self.base_speed
                        right_speed = max(0, self.base_speed - abs(correction))
                
                self._set_motors("forward", left_speed, "forward", right_speed)
            else:
                # Good distance - go straight
                self._set_motors("forward", self.base_speed, "forward", self.base_speed)
    
    def _avoid_obstacle(self, scan_data: Dict[str, Any]):
        """Avoid obstacle using single-wheel turning"""
        # Stop first
        self.motor_controller.stop_all_motors()
        time.sleep(0.2)
        
        # Find best escape direction
        left_clear = self._check_direction_clear(scan_data, math.pi / 2)
        right_clear = self._check_direction_clear(scan_data, -math.pi / 2)
        
        if right_clear and (not left_clear or self.wall_follow_side == WallFollowSide.RIGHT):
            # Turn right
            logger.info("Obstacle avoidance - turning right")
            self._set_motors("forward", self.turn_speed, "brake", 0)
        elif left_clear:
            # Turn left
            logger.info("Obstacle avoidance - turning left")
            self._set_motors("brake", 0, "forward", self.turn_speed)
        else:
            # Back up carefully (both sides blocked)
            logger.warning("Both sides blocked - backing up")
            self._set_motors("backward", self.slow_speed, "backward", self.slow_speed)
            time.sleep(1.0)
            # Then try turning
            self._set_motors("forward", self.turn_speed, "brake", 0)
        
        time.sleep(0.5)
        self.state = RobotState.IDLE
    
    def _execute_rotation(self, scan_data: Dict[str, Any]):
        """Execute rotation to target angle using single-wheel turning"""
        if not hasattr(self, 'target_angle'):
            self.state = RobotState.IDLE
            return
        
        angle_error = self._normalize_angle(self.target_angle - self.robot_theta)
        
        if abs(angle_error) < math.pi / 18:  # < 10 degrees
            # Close enough
            self.motor_controller.stop_all_motors()
            self.state = RobotState.IDLE
            return
        
        # Calculate rotation time
        rotation_time = abs(angle_error) * self.rotation_time_per_degree * 180 / math.pi
        
        if angle_error > 0:
            # Turn left
            self._set_motors("brake", 0, "forward", self.turn_speed)
        else:
            # Turn right
            self._set_motors("forward", self.turn_speed, "brake", 0)
        
        # Simple timed rotation (can be improved with feedback)
        time.sleep(min(rotation_time, 0.5))  # Max 0.5s per iteration
    
    def _explore(self, scan_data: Dict[str, Any]):
        """Explore unknown areas"""
        # Simple exploration: move forward and turn when blocked
        front_distance = self._get_distance_at_angle(scan_data, 0)
        
        if front_distance and front_distance < self.wall_follow_distance:
            # Obstacle ahead - pick a direction to turn
            left_distance = self._get_distance_at_angle(scan_data, math.pi / 2)
            right_distance = self._get_distance_at_angle(scan_data, -math.pi / 2)
            
            if right_distance and (not left_distance or right_distance > left_distance):
                # Turn right
                self._set_motors("forward", self.turn_speed, "brake", 0)
            else:
                # Turn left
                self._set_motors("brake", 0, "forward", self.turn_speed)
            
            time.sleep(1.0)
        else:
            # Move forward
            self._set_motors("forward", self.explore_speed, "forward", self.explore_speed)
    
    def _get_distance_at_angle(self, scan_data: Dict[str, Any], target_angle: float) -> Optional[float]:
        """Get distance measurement at specific angle"""
        points = scan_data.get("points", [])
        if not points:
            return None
        
        # Find points near target angle
        angle_tolerance = math.pi / 12  # 15 degrees
        valid_distances = []
        
        for point in points:
            angle_diff = abs(self._normalize_angle(point["theta"] - target_angle))
            if angle_diff <= angle_tolerance:
                valid_distances.append(point["r"] * 1000)  # Convert to mm
        
        return np.median(valid_distances) if valid_distances else None
    
    def _check_direction_clear(self, scan_data: Dict[str, Any], angle: float) -> bool:
        """Check if direction is clear for movement"""
        distance = self._get_distance_at_angle(scan_data, angle)
        return distance is None or distance > self.safety_distance
    
    def _normalize_angle(self, angle: float) -> float:
        """Normalize angle to [-pi, pi]"""
        while angle > math.pi:
            angle -= 2 * math.pi
        while angle < -math.pi:
            angle += 2 * math.pi
        return angle
    
    def _update_odometry(self):
        """Update robot position estimate"""
        current_time = time.time()
        dt = current_time - self.last_odometry_update
        self.last_odometry_update = current_time
        
        # Get motor states
        motor_states = self.motor_controller.get_all_motor_states()
        
        # Estimate velocities (simplified)
        left_velocity = 0
        right_velocity = 0
        
        if motor_states[1]["direction"] == "forward":
            left_velocity = motor_states[1]["speed"] * 10  # mm/s at 100%
        elif motor_states[1]["direction"] == "backward":
            left_velocity = -motor_states[1]["speed"] * 10
        
        if motor_states[0]["direction"] == "forward":
            right_velocity = motor_states[0]["speed"] * 10
        elif motor_states[0]["direction"] == "backward":
            right_velocity = -motor_states[0]["speed"] * 10
        
        # Differential drive kinematics
        v = (left_velocity + right_velocity) / 2
        w = (right_velocity - left_velocity) / self.wheelbase
        
        # Update pose
        if abs(w) < 0.001:
            # Straight motion
            self.robot_pose.x += v * dt * math.cos(self.robot_theta)
            self.robot_pose.y += v * dt * math.sin(self.robot_theta)
        else:
            # Arc motion
            self.robot_pose.x += (v/w) * (math.sin(self.robot_theta + w*dt) - math.sin(self.robot_theta))
            self.robot_pose.y += (v/w) * (-math.cos(self.robot_theta + w*dt) + math.cos(self.robot_theta))
            self.robot_theta = self._normalize_angle(self.robot_theta + w * dt)
    
    def _emergency_stop(self):
        """Execute emergency stop"""
        logger.warning("Emergency stop activated!")
        self.motor_controller.stop_all_motors()
        self.state = RobotState.EMERGENCY_STOP
        time.sleep(1.0)
    
    def get_status(self) -> Dict[str, Any]:
        """Get current mapping status"""
        with self._state_lock:
            return {
                "active": self.mapping_active,
                "state": self.state.value,
                "emergency_stop": self.emergency_stop,
                "robot_position": {
                    "x": round(self.robot_pose.x),
                    "y": round(self.robot_pose.y),
                    "theta": round(math.degrees(self.robot_theta), 1)
                },
                "current_goal": {
                    "x": self.current_goal.position.x,
                    "y": self.current_goal.position.y
                } if self.current_goal else None,
                "path_length": len(self.path_history),
                "calibration_complete": self.calibration_complete,
                "static_obstacles_count": len(self.static_obstacles),
                "wall_following": self.following_wall,
                "wall_side": self.wall_follow_side.value
            }
    
    def set_goal(self, x: float, y: float) -> bool:
        """Set navigation goal"""
        self.current_goal = Goal(Point(x, y))
        self.m_line_start = Point(self.robot_pose.x, self.robot_pose.y)
        self.m_line_goal = self.current_goal.position
        logger.info(f"Goal set to ({x}, {y})")
        return True
    
    def get_occupancy_grid(self) -> np.ndarray:
        """Get occupancy grid as probability array"""
        # Convert log-odds to probabilities
        return 1.0 - 1.0 / (1.0 + np.exp(self.occupancy_grid.log_odds))

# Singleton instance
_auto_mapper_v2 = None

def get_auto_mapper_v2(motor_controller=None, lidar_sensor=None):
    """Get or create AutoMapperV2 instance"""
    global _auto_mapper_v2
    if _auto_mapper_v2 is None and motor_controller and lidar_sensor:
        _auto_mapper_v2 = AutoMapperV2(motor_controller, lidar_sensor)
    return _auto_mapper_v2
================================================================================


================================================================================
FILE: backend/config_manager.py
Category: Python | Size: 3.3 KB | Lines: 105
================================================================================
#!/usr/bin/env python3
"""
Configuration manager for persistent settings
Saves and loads configuration from a JSON file
"""

import json
import os
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class ConfigManager:
    """Manages persistent configuration settings"""
    
    def __init__(self, config_file: str = None):
        """
        Initialize configuration manager
        
        Args:
            config_file: Path to configuration file (default: ~/.robot_dashboard_config.json)
        """
        if config_file is None:
            # Use home directory for config file
            self.config_file = Path.home() / ".robot_dashboard_config.json"
        else:
            self.config_file = Path(config_file)
        
        # Default configuration
        self.default_config = {
            "PI_IP": "192.168.2.1",
            "ROS_BRIDGE_PORT": 9090,
            "FLASK_PORT": 5001,
            "FLASK_HOST": "0.0.0.0"
        }
        
        # Load configuration
        self.config = self.load_config()
    
    def load_config(self) -> dict:
        """Load configuration from file or return defaults"""
        try:
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    loaded_config = json.load(f)
                    # Merge with defaults (in case new fields are added)
                    config = self.default_config.copy()
                    config.update(loaded_config)
                    logger.info(f"Loaded configuration from {self.config_file}")
                    return config
            else:
                logger.info("No config file found, using defaults")
                return self.default_config.copy()
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            return self.default_config.copy()
    
    def save_config(self):
        """Save current configuration to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
            logger.info(f"Saved configuration to {self.config_file}")
            return True
        except Exception as e:
            logger.error(f"Error saving config: {e}")
            return False
    
    def update_config(self, updates: dict) -> bool:
        """
        Update configuration values
        
        Args:
            updates: Dictionary of configuration updates
            
        Returns:
            bool: True if successful
        """
        try:
            # Update configuration
            self.config.update(updates)
            # Save to file
            return self.save_config()
        except Exception as e:
            logger.error(f"Error updating config: {e}")
            return False
    
    def get(self, key: str, default=None):
        """Get configuration value"""
        return self.config.get(key, default)
    
    def get_all(self) -> dict:
        """Get all configuration values"""
        return self.config.copy()

# Singleton instance
_config_manager = None

def get_config_manager(config_file: str = None) -> ConfigManager:
    """Get or create ConfigManager instance"""
    global _config_manager
    if _config_manager is None:
        _config_manager = ConfigManager(config_file)
    return _config_manager
================================================================================


================================================================================
FILE: backend/host_backend.py
Category: Python | Size: 30.5 KB | Lines: 961
================================================================================
#!/usr/bin/env python3
"""
Flask backend server for ROS 2 robot control
Main application entry point with multi-component support
"""

import os
import sys
from pathlib import Path

# Add parent directory to path for imports
sys.path.append(str(Path(__file__).parent.parent))

from flask import Flask, render_template, jsonify, request
from flask_cors import CORS
from flask_socketio import SocketIO, emit
import logging

# Import configuration manager
from backend.config_manager import get_config_manager

# Import ROS bridge components
from backend.ros_bridge import get_ros_bridge, get_motor_controller
from backend.sensors.lidar import get_lidar_sensor
from backend.sensors.thermal_camera import get_thermal_camera_sensor
from backend.sensors.system_monitor import get_system_monitor
from backend.motors.servo_control import ServoController
from backend.motors.actuator_control import get_actuator_controller
from backend.automation import get_auto_mapper
from backend.automation_aiming import get_auto_aiming

# Create Flask app
app = Flask(__name__, 
            template_folder='../frontend/templates',
            static_folder='../frontend/static')
CORS(app)  # Enable CORS for API requests
socketio = SocketIO(app, cors_allowed_origins="*")  # For real-time data

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Load configuration from persistent storage
config_manager = get_config_manager()
CONFIG = config_manager.get_all()

# Initialize ROS components with saved configuration
ros_bridge = get_ros_bridge(CONFIG["PI_IP"], CONFIG["ROS_BRIDGE_PORT"])
motor_controller = get_motor_controller()
lidar_sensor = get_lidar_sensor()
thermal_camera_sensor = get_thermal_camera_sensor()
system_monitor = get_system_monitor()
servo_controller = ServoController()
actuator_controller = get_actuator_controller()

# Initialize automation components
auto_mapper = get_auto_mapper(motor_controller, lidar_sensor)
auto_aiming = get_auto_aiming(servo_controller, thermal_camera_sensor)

# Set ROS bridge for servo controller
servo_controller.set_ros_bridge(ros_bridge)
actuator_controller.set_ros_bridge(ros_bridge)

# Data streaming states
lidar_streaming = False
servo_streaming = False
system_streaming = False

# =============================================================================
# MAIN DASHBOARD ROUTES
# =============================================================================

@app.route('/')
def index():
    """Serve the main dashboard home page"""
    return render_template('dashboard_home.html')

@app.route('/motors')
def motors_page():
    """Serve the motor control interface"""
    return render_template('motor_control.html')

@app.route('/lidar')
def lidar_page():
    """Serve the lidar visualization interface"""
    return render_template('lidar_visualization.html')

@app.route('/thermal')
def thermal_page():
    """Serve the thermal camera interface"""
    return render_template('thermal_camera.html')

@app.route('/aiming')
def aiming_system():
    """Serve the aiming system control interface"""
    return render_template('aiming_system.html')

# =============================================================================
# MOTOR CONTROL API ROUTES
# =============================================================================

@app.route('/api/motor/<int:motor_id>', methods=['POST'])
def control_motor(motor_id):
    """Control a specific motor"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        # Use motor controller
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in control_motor: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/motor/<int:motor_id>', methods=['GET'])
def get_motor_status(motor_id):
    """Get current status of a specific motor"""
    state = motor_controller.get_motor_state(motor_id)
    
    if state:
        return jsonify({
            "success": True,
            "motor_id": motor_id,
            "state": state
        })
    else:
        return jsonify({
            "success": False,
            "error": "Invalid motor ID"
        }), 404

@app.route('/api/motors', methods=['GET'])
def get_all_motors_status():
    """Get current status of all motors"""
    states = motor_controller.get_all_motor_states()
    
    return jsonify({
        "success": True,
        "motors": states
    })

@app.route('/api/motors/stop', methods=['POST'])
def stop_all_motors():
    """Emergency stop - brake all motors"""
    result = motor_controller.stop_all_motors()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

# =============================================================================
# AUTOMATION API ROUTES
# =============================================================================

@app.route('/api/automation/start', methods=['POST'])
def start_automation():
    """Start autonomous mapping"""
    try:
        if auto_mapper.start_mapping():
            return jsonify({
                "success": True,
                "message": "Autonomous mapping started"
            })
        else:
            return jsonify({
                "success": False,
                "error": "Mapping already active"
            }), 400
    except Exception as e:
        logger.error(f"Error starting automation: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/automation/stop', methods=['POST'])
def stop_automation():
    """Stop autonomous mapping"""
    try:
        if auto_mapper.stop_mapping():
            return jsonify({
                "success": True,
                "message": "Autonomous mapping stopped"
            })
        else:
            return jsonify({
                "success": False,
                "error": "Mapping not active"
            }), 400
    except Exception as e:
        logger.error(f"Error stopping automation: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/automation/status', methods=['GET'])
def get_automation_status():
    """Get current automation status"""
    try:
        status = auto_mapper.get_status()
        return jsonify({
            "success": True,
            "status": status
        })
    except Exception as e:
        logger.error(f"Error getting automation status: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/automation/safety', methods=['POST'])
def update_safety_parameters():
    """Update automation safety parameters"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        critical = data.get('critical_distance', 200)
        safety = data.get('safety_distance', 300)
        wall_follow = data.get('wall_follow_distance', 500)
        
        if auto_mapper.update_safety_parameters(critical, safety, wall_follow):
            return jsonify({
                "success": True,
                "message": "Safety parameters updated",
                "parameters": {
                    "critical_distance": critical,
                    "safety_distance": safety,
                    "wall_follow_distance": wall_follow
                }
            })
        else:
            return jsonify({
                "success": False,
                "error": "Failed to update parameters"
            }), 400
    except Exception as e:
        logger.error(f"Error updating safety parameters: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/automation/safety', methods=['GET'])
def get_safety_parameters():
    """Get current automation safety parameters"""
    try:
        return jsonify({
            "success": True,
            "parameters": {
                "critical_distance": auto_mapper.critical_distance,
                "safety_distance": auto_mapper.safety_distance,
                "wall_follow_distance": auto_mapper.wall_follow_distance
            }
        })
    except Exception as e:
        logger.error(f"Error getting safety parameters: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/automation/calibrate', methods=['POST'])
def calibrate_background():
    """Calibrate lidar background to remove static obstacles"""
    try:
        if auto_mapper.calibrate_background():
            return jsonify({
                "success": True,
                "message": "Background calibration successful",
                "static_points": len(auto_mapper.static_obstacles)
            })
        else:
            return jsonify({
                "success": False,
                "error": "Background calibration failed"
            }), 400
    except Exception as e:
        logger.error(f"Error calibrating background: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/automation/background', methods=['GET'])
def get_background_status():
    """Get background removal status"""
    try:
        return jsonify({
            "success": True,
            "enabled": auto_mapper.background_removal_enabled,
            "static_points": len(auto_mapper.static_obstacles),
            "calibrated": len(auto_mapper.static_obstacles) > 0
        })
    except Exception as e:
        logger.error(f"Error getting background status: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/automation/background/toggle', methods=['POST'])
def toggle_background_removal():
    """Toggle background removal on/off"""
    try:
        auto_mapper.background_removal_enabled = not auto_mapper.background_removal_enabled
        return jsonify({
            "success": True,
            "enabled": auto_mapper.background_removal_enabled
        })
    except Exception as e:
        logger.error(f"Error toggling background removal: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

# =============================================================================
# SERVO/AIMING SYSTEM API ROUTES
# =============================================================================

@app.route('/api/servo/position', methods=['POST'])
def set_servo_position():
    """Set servo position for pan/tilt"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        pan_angle = data.get('pan_angle', servo_controller.pan_angle)
        tilt_angle = data.get('tilt_angle', servo_controller.tilt_angle)
        
        # Move servos
        result = servo_controller.move_to_position(pan_angle, tilt_angle)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in set_servo_position: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/servo/position', methods=['GET'])
def get_servo_position():
    """Get current servo position"""
    state = servo_controller.get_state()
    
    return jsonify({
        "success": True,
        "state": state
    })

@app.route('/api/servo/center', methods=['POST'])
def center_servos():
    """Move servos to center position"""
    result = servo_controller.center_position()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 400

@app.route('/api/servo/preset/<string:position>', methods=['POST'])
def move_to_preset(position):
    """Move servos to preset position (left, right, up, down)"""
    preset_functions = {
        'left': servo_controller.move_left,
        'right': servo_controller.move_right,
        'up': servo_controller.move_up,
        'down': servo_controller.move_down,
        'center': servo_controller.center_position
    }
    
    if position not in preset_functions:
        return jsonify({
            "success": False,
            "error": f"Invalid preset position: {position}"
        }), 400
    
    result = preset_functions[position]()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 400

# =============================================================================
# AUTO AIMING API ROUTES
# =============================================================================

@app.route('/api/aiming/auto/enable', methods=['POST'])
def enable_auto_aiming():
    """Enable automatic aiming based on thermal targets"""
    try:
        result = auto_aiming.enable()
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error enabling auto aiming: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/aiming/auto/disable', methods=['POST'])
def disable_auto_aiming():
    """Disable automatic aiming"""
    try:
        result = auto_aiming.disable()
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error disabling auto aiming: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/aiming/auto/status', methods=['GET'])
def get_auto_aiming_status():
    """Get auto aiming status"""
    try:
        status = auto_aiming.get_status()
        return jsonify({
            "success": True,
            "status": status
        })
    except Exception as e:
        logger.error(f"Error getting auto aiming status: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/aiming/auto/threshold', methods=['POST'])
def set_auto_aiming_threshold():
    """Set temperature threshold for auto aiming"""
    try:
        data = request.get_json()
        
        if not data or 'threshold' not in data:
            return jsonify({"error": "No threshold provided"}), 400
        
        threshold = float(data['threshold'])
        result = auto_aiming.set_threshold(threshold)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error setting auto aiming threshold: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

# =============================================================================
# ACTUATOR CONTROL API ROUTES
# =============================================================================

@app.route('/api/actuator/control', methods=['POST'])
def control_actuator():
    """Control the actuator for fire extinguisher trigger"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        action = data.get('action', 'stop')
        speed = data.get('speed', 0)
        duration = data.get('duration', 0.0)
        
        result = actuator_controller.control_actuator(action, speed, duration)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in control_actuator: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/actuator/status', methods=['GET'])
def get_actuator_status():
    """Get current actuator status"""
    state = actuator_controller.get_state()
    
    return jsonify({
        "success": True,
        "state": state
    })

@app.route('/api/actuator/test', methods=['GET'])
def test_actuator_connection():
    """Test actuator connection"""
    connected = actuator_controller.test_connection()
    
    return jsonify({
        "success": True,
        "connected": connected,
        "message": "Actuator service is available" if connected else "Actuator service not responding"
    })

@app.route('/api/actuator/stop', methods=['POST'])
def stop_actuator():
    """Emergency stop for actuator"""
    result = actuator_controller.emergency_stop()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 400

# =============================================================================
# LIDAR API ROUTES
# =============================================================================

@app.route('/api/lidar/status', methods=['GET'])
def get_lidar_status():
    """Get lidar sensor status"""
    latest_scan = lidar_sensor.get_latest_scan()
    
    return jsonify({
        "connected": lidar_sensor.subscription_active,
        "has_data": latest_scan is not None,
        "timestamp": latest_scan["timestamp"] if latest_scan else None
    })

@app.route('/api/lidar/latest', methods=['GET'])
def get_latest_lidar_scan():
    """Get the most recent lidar scan data"""
    scan_data = lidar_sensor.get_latest_scan()
    
    if scan_data:
        return jsonify({
            "success": True,
            "data": scan_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "No scan data available"
        }), 404

@app.route('/api/lidar/subscribe', methods=['POST'])
def subscribe_lidar():
    """Start lidar data subscription"""
    global lidar_streaming
    
    def lidar_callback(scan_data):
        """Emit lidar data through WebSocket"""
        if lidar_streaming:
            socketio.emit('lidar_data', scan_data)
            
            # Also emit to automation system if active
            automation_status = auto_mapper.get_status()
            if automation_status.get("active"):
                socketio.emit('automation_status', automation_status)
    
    success = lidar_sensor.subscribe(callback=lidar_callback, processed_data=True)
    
    if success:
        lidar_streaming = True
        return jsonify({"success": True, "message": "Lidar subscription started"})
    else:
        return jsonify({"success": False, "error": "Failed to subscribe to lidar"}), 500

@app.route('/api/lidar/unsubscribe', methods=['POST'])
def unsubscribe_lidar():
    """Stop lidar data subscription"""
    global lidar_streaming
    
    lidar_streaming = False
    lidar_sensor.unsubscribe()
    
    return jsonify({"success": True, "message": "Lidar subscription stopped"})

# =============================================================================
# THERMAL CAMERA API ROUTES
# =============================================================================

@app.route('/api/thermal/status', methods=['GET'])
def get_thermal_status():
    """Get thermal camera sensor status"""
    latest_frame = thermal_camera_sensor.get_latest_frame()
    
    return jsonify({
        "connected": thermal_camera_sensor.subscription_active,
        "has_data": latest_frame is not None,
        "timestamp": latest_frame["timestamp"] if latest_frame else None
    })

@app.route('/api/thermal/latest', methods=['GET'])
def get_latest_thermal_frame():
    """Get the most recent thermal frame data"""
    frame_data = thermal_camera_sensor.get_latest_frame()
    
    if frame_data:
        return jsonify({
            "success": True,
            "data": frame_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "No thermal data available"
        }), 404

@app.route('/api/thermal/frame', methods=['GET'])
def get_thermal_frame():
    """Get a single thermal frame via service call"""
    frame_data = thermal_camera_sensor.get_thermal_frame_once()
    
    if frame_data:
        return jsonify({
            "success": True,
            "data": frame_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "Failed to capture thermal frame"
        }), 500

@app.route('/api/thermal/subscribe', methods=['POST'])
def subscribe_thermal():
    """Start thermal camera data subscription"""
    def thermal_callback(frame_data):
        """Emit thermal data through WebSocket"""
        socketio.emit('thermal_data', frame_data)
    
    success = thermal_camera_sensor.subscribe(callback=thermal_callback)
    
    if success:
        return jsonify({"success": True, "message": "Thermal camera subscription started"})
    else:
        return jsonify({"success": False, "error": "Failed to subscribe to thermal camera"}), 500

@app.route('/api/thermal/unsubscribe', methods=['POST'])
def unsubscribe_thermal():
    """Stop thermal camera data subscription"""
    thermal_camera_sensor.unsubscribe()
    
    return jsonify({"success": True, "message": "Thermal camera subscription stopped"})

# =============================================================================
# SYSTEM MONITOR API ROUTES
# =============================================================================

@app.route('/api/system/status', methods=['GET'])
def get_system_status_monitor():
    """Get system monitor status"""
    latest_status = system_monitor.get_latest_status()
    
    return jsonify({
        "connected": system_monitor.subscription_active,
        "has_data": latest_status is not None,
        "data": latest_status,
        "timestamp": latest_status["timestamp"] if latest_status else None
    })

@app.route('/api/system/subscribe', methods=['POST'])
def subscribe_system_monitor():
    """Start system monitor subscription"""
    global system_streaming
    
    def system_callback(status_data):
        """Emit system data through WebSocket"""
        if system_streaming:
            socketio.emit('system_status', status_data)
    
    success = system_monitor.subscribe(callback=system_callback)
    
    if success:
        system_streaming = True
        return jsonify({"success": True, "message": "System monitor subscription started"})
    else:
        return jsonify({"success": False, "error": "Failed to subscribe to system monitor"}), 500

@app.route('/api/system/unsubscribe', methods=['POST'])
def unsubscribe_system_monitor():
    """Stop system monitor subscription"""
    global system_streaming
    
    system_streaming = False
    system_monitor.unsubscribe()
    
    return jsonify({"success": True, "message": "System monitor subscription stopped"})

# =============================================================================
# SYSTEM STATUS ROUTES
# =============================================================================

@app.route('/api/status', methods=['GET'])
def get_system_status():
    """Check connection status to ROS bridge and system info"""
    ros_connected = ros_bridge.test_connection()
    
    return jsonify({
        "connected": ros_connected,
        "rosbridge_url": ros_bridge.url,
        "config": {
            "robot_ip": CONFIG["PI_IP"],
            "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"]
        },
        "components": {
            "motors": True,
            "lidar": lidar_sensor.subscription_active,
            "thermal": thermal_camera_sensor.subscription_active,
            "servo": servo_controller.connected,
            "system_monitor": system_monitor.subscription_active,
            "actuator": actuator_controller.connected,
            "automation": auto_mapper.mapping_active,
            "auto_aiming": auto_aiming.enabled
        }
    }), 200 if ros_connected else 503

@app.route('/api/config', methods=['GET'])
def get_config():
    """Get current configuration"""
    return jsonify({
        "robot_ip": CONFIG["PI_IP"],
        "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"],
        "flask_port": CONFIG["FLASK_PORT"],
        "flask_host": CONFIG["FLASK_HOST"]
    })

@app.route('/api/config', methods=['POST'])
def update_config():
    """Update configuration with new connection settings"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        # Get new settings
        new_ip = data.get('robot_ip')
        new_port = data.get('rosbridge_port')
        
        if not new_ip or not new_port:
            return jsonify({"error": "Missing robot_ip or rosbridge_port"}), 400
        
        # Update configuration in memory
        CONFIG["PI_IP"] = new_ip
        CONFIG["ROS_BRIDGE_PORT"] = int(new_port)
        
        # Save to persistent storage
        config_updates = {
            "PI_IP": new_ip,
            "ROS_BRIDGE_PORT": int(new_port)
        }
        config_manager.update_config(config_updates)
        
        # Update ROS bridge connection
        global ros_bridge, motor_controller, lidar_sensor, thermal_camera_sensor, servo_controller, actuator_controller, auto_mapper, auto_aiming
        ros_bridge = get_ros_bridge(CONFIG["PI_IP"], CONFIG["ROS_BRIDGE_PORT"])
        motor_controller = get_motor_controller()
        lidar_sensor = get_lidar_sensor()
        thermal_camera_sensor = get_thermal_camera_sensor()
        
        # Update servo and actuator controllers with new ROS bridge
        servo_controller.set_ros_bridge(ros_bridge)
        actuator_controller.set_ros_bridge(ros_bridge)
        
        # Recreate auto mapper and auto aiming with new components
        auto_mapper = get_auto_mapper(motor_controller, lidar_sensor)
        auto_aiming = get_auto_aiming(servo_controller, thermal_camera_sensor)
        
        logger.info(f"Configuration updated and saved: IP={new_ip}, Port={new_port}")
        
        return jsonify({
            "success": True,
            "message": "Configuration updated successfully",
            "config": {
                "robot_ip": CONFIG["PI_IP"],
                "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"]
            }
        })
        
    except Exception as e:
        logger.error(f"Error updating configuration: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

# =============================================================================
# WEBSOCKET EVENTS
# =============================================================================

@socketio.on('connect')
def handle_connect():
    """Handle WebSocket connection"""
    logger.info("Client connected to WebSocket")
    emit('connected', {'data': 'Connected to robot dashboard'})

@socketio.on('disconnect')
def handle_disconnect():
    """Handle WebSocket disconnection"""
    logger.info("Client disconnected from WebSocket")

# Servo WebSocket events
@socketio.on('servo_command')
def handle_servo_command(data):
    """Handle servo commands via WebSocket"""
    global servo_streaming
    
    try:
        command_type = data.get('type', 'servo_command')
        
        if command_type == 'servo_command':
            result = servo_controller.handle_websocket_command(data)
            
            # Send response
            emit('servo_response', {
                'type': 'command_result',
                'result': result
            })
            
            # Send updated state to all clients
            state = servo_controller.get_state()
            socketio.emit('servo_state', {
                'type': 'servo_state',
                **state
            })
            
    except Exception as e:
        logger.error(f"Error handling servo command: {e}")
        emit('servo_error', {
            'type': 'error',
            'error': str(e)
        })

@socketio.on('request_servo_state')
def handle_servo_state_request():
    """Send current servo state via WebSocket"""
    state = servo_controller.get_state()
    emit('servo_state', {
        'type': 'servo_state',
        **state
    })

# Automation WebSocket events
@socketio.on('request_automation_status')
def handle_automation_status_request():
    """Send current automation status via WebSocket"""
    status = auto_mapper.get_status()
    emit('automation_status', status)

# =============================================================================
# ERROR HANDLERS
# =============================================================================

@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Not found"}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Internal server error"}), 500

# Health check endpoint
@app.route('/health', methods=['GET'])
def health_check():
    """Simple health check endpoint"""
    return jsonify({
        "status": "healthy",
        "service": "robot-dashboard-backend"
    })

# =============================================================================
# INITIALIZATION
# =============================================================================

def initialize_system():
    """Initialize all system components"""
    logger.info("Initializing system components...")
    
    # Set WebSocket handler for servo updates
    def servo_websocket_handler(data):
        """Handle servo state updates"""
        socketio.emit('servo_state', data)
    
    servo_controller.set_websocket_handler(servo_websocket_handler)
    
    # Initialize servo to center position
    logger.info("Moving servos to center position...")
    servo_controller.center_position()
    
    logger.info("System initialization complete")

def main():
    """Main entry point"""
    logger.info("=" * 50)
    logger.info("ROS 2 Robot Dashboard Backend")
    logger.info(f"Robot IP: {CONFIG['PI_IP']}")
    logger.info(f"ROS Bridge Port: {CONFIG['ROS_BRIDGE_PORT']}")
    logger.info(f"Flask Server: {CONFIG['FLASK_HOST']}:{CONFIG['FLASK_PORT']}")
    logger.info(f"Config file: {config_manager.config_file}")
    logger.info("=" * 50)
    
    # Initialize system
    initialize_system()
    
    # Run Flask app with SocketIO
    debug_mode = os.environ.get('FLASK_ENV', 'development') == 'development'
    
    socketio.run(
        app,
        debug=debug_mode,
        host=CONFIG['FLASK_HOST'],
        port=CONFIG['FLASK_PORT'],
        use_reloader=False  # Disable auto-reloader to prevent numpy reload issues
    )

if __name__ == '__main__':
    main()
================================================================================


================================================================================
FILE: backend/motors/__init__.py
Category: Python | Size: 0.0 B | Lines: 0
================================================================================

================================================================================


================================================================================
FILE: backend/motors/actuator_control.py
Category: Python | Size: 7.5 KB | Lines: 205
================================================================================
#!/usr/bin/env python3
"""
Actuator Control Module for Fire Extinguisher Trigger
Handles linear actuator control through ROS2 service calls
"""

import logging
from typing import Dict, Any, Optional
from datetime import datetime

logger = logging.getLogger(__name__)

class ActuatorController:
    """Controls the linear actuator for fire extinguisher trigger mechanism"""
    
    def __init__(self, ros_bridge=None):
        """
        Initialize actuator controller
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.connected = False
        self.current_state = "stopped"
        self.current_speed = 0
        self.last_command_time = None
        
        logger.info("Actuator controller initialized")
    
    def set_ros_bridge(self, ros_bridge):
        """Set or update the ROS bridge instance"""
        self.ros_bridge = ros_bridge
        self.connected = True
        logger.info("ROS bridge connected to actuator controller")
    
    def control_actuator(self, action: str, speed: int = 0, duration: float = 0.0) -> Dict[str, Any]:
        """
        Control the actuator
        
        Args:
            action: 'extend', 'retract', or 'stop'
            speed: Speed percentage (0-100)
            duration: Duration in seconds (0 for continuous)
            
        Returns:
            Dict with operation result
        """
        # Validate inputs
        if action not in ['extend', 'retract', 'stop']:
            return {
                "success": False,
                "error": f"Invalid action: {action}. Must be 'extend', 'retract', or 'stop'"
            }
        
        if action != 'stop':
            speed = max(0, min(100, speed))
        else:
            speed = 0
        
        duration = max(0.0, duration)
        
        # Update state
        self.current_state = action
        self.current_speed = speed
        self.last_command_time = datetime.now()
        
        # Send command via ROS bridge if available
        if self.ros_bridge:
            try:
                # Call the set_actuator service with proper type
                service_args = {
                    "action": action,
                    "speed": speed,
                    "duration": duration
                }
                
                logger.info(f"Calling /set_actuator with args: {service_args}")
                
                # Add service type for rosbridge
                success, response = self.ros_bridge.call_service(
                    "/set_actuator",
                    service_args,
                    "set_actuator",
                    service_type="actuator_interfaces/srv/SetActuator"
                )
                
                logger.info(f"Service call response: success={success}, response={response}")
                
                # Check different response formats
                if success:
                    # Extract the actual service response from rosbridge format
                    service_response = response.get("values", {})
                    
                    # Check if the service itself returned success
                    service_success = service_response.get("success", True)
                    service_message = service_response.get("message", "Command sent")
                    
                    if service_success:
                        logger.info(f"Actuator command successful: {service_message}")
                        return {
                            "success": True,
                            "action": action,
                            "speed": speed,
                            "duration": duration,
                            "message": service_message or f"Actuator {action} at {speed}% speed" + (f" for {duration}s" if duration > 0 else " (continuous)"),
                            "response": service_response
                        }
                    else:
                        logger.error(f"Service returned failure: {service_message}")
                        return {
                            "success": False,
                            "error": service_message or "Actuator command failed",
                            "details": service_response
                        }
                else:
                    error_msg = response.get("error", response.get("msg", "Unknown error"))
                    logger.error(f"Failed to call service: {error_msg}")
                    logger.error(f"Full response: {response}")
                    return {
                        "success": False,
                        "error": error_msg,
                        "details": response
                    }
                    
            except Exception as e:
                logger.error(f"Failed to send actuator command: {e}")
                return {
                    "success": False,
                    "error": str(e)
                }
        else:
            # No ROS bridge - just update local state
            return {
                "success": True,
                "action": action,
                "speed": speed,
                "duration": duration,
                "message": "Actuator command simulated (no ROS bridge connected)"
            }
    
    def extend(self, speed: int = 100, duration: float = 0.0) -> Dict[str, Any]:
        """Extend the actuator"""
        return self.control_actuator("extend", speed, duration)
    
    def retract(self, speed: int = 100, duration: float = 0.0) -> Dict[str, Any]:
        """Retract the actuator"""
        return self.control_actuator("retract", speed, duration)
    
    def stop(self) -> Dict[str, Any]:
        """Stop the actuator immediately"""
        return self.control_actuator("stop", 0, 0.0)
    
    def get_state(self) -> Dict[str, Any]:
        """Get current actuator state"""
        return {
            "state": self.current_state,
            "speed": self.current_speed,
            "connected": self.connected,
            "last_command": self.last_command_time.isoformat() if self.last_command_time else None,
            "timestamp": datetime.now().isoformat()
        }
    
    def test_connection(self) -> bool:
        """Test if actuator service is available"""
        if not self.ros_bridge:
            self.connected = False
            return False
            
        try:
            # Try to call service with a test command
            success, response = self.ros_bridge.call_service(
                "/set_actuator",
                {"action": "stop", "speed": 0, "duration": 0.0},
                "test_actuator_connection",
                service_type="actuator_interfaces/srv/SetActuator"
            )
            
            self.connected = success
            return success
            
        except Exception as e:
            logger.error(f"Actuator connection test failed: {e}")
            self.connected = False
            return False
    
    def emergency_stop(self) -> Dict[str, Any]:
        """Emergency stop - immediately stop actuator"""
        logger.warning("Emergency stop activated for actuator")
        return self.stop()


# Singleton instance
_actuator_controller = None

def get_actuator_controller(ros_bridge=None):
    """Get or create actuator controller instance"""
    global _actuator_controller
    
    if _actuator_controller is None:
        _actuator_controller = ActuatorController(ros_bridge)
    elif ros_bridge is not None:
        _actuator_controller.set_ros_bridge(ros_bridge)
    
    return _actuator_controller
================================================================================


================================================================================
FILE: backend/motors/motor_controller.py
Category: Python | Size: 6.3 KB | Lines: 192
================================================================================
"""
Motor Controller Module
Handles motor control logic and ROS communication
"""

import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

class MotorController:
    """Motor controller for 4-motor robot using L298N drivers"""
    
    def __init__(self, ros_bridge=None):
        self.ros_bridge = ros_bridge
        
        # Motor state tracking
        self.motor_states = {
            1: {"direction": "brake", "speed": 0},
            2: {"direction": "brake", "speed": 0},
            3: {"direction": "brake", "speed": 0},
            4: {"direction": "brake", "speed": 0}
        }
        
        # Motor channel mapping (2 motors per L298N channel)
        self.motor_to_channel = {
            1: 'A',  # Front-left
            2: 'A',  # Front-right
            3: 'B',  # Rear-left
            4: 'B'   # Rear-right
        }
        
        logger.info("Motor controller initialized")
    
    def set_ros_bridge(self, ros_bridge):
        """Set or update the ROS bridge instance"""
        self.ros_bridge = ros_bridge
        logger.info("ROS bridge connected to motor controller")
    
    def set_motor(self, motor_id: int, direction: str, speed: int) -> Dict[str, Any]:
        """
        Control a specific motor
        
        Args:
            motor_id: Motor number (1-4)
            direction: 'forward', 'backward', or 'brake'
            speed: Speed value (0-100)
        
        Returns:
            Result dictionary with success status
        """
        # Validate inputs
        if motor_id not in range(1, 5):
            return {
                "success": False,
                "error": f"Invalid motor ID: {motor_id}. Must be 1-4."
            }
        
        if direction not in ['forward', 'backward', 'brake']:
            return {
                "success": False,
                "error": f"Invalid direction: {direction}"
            }
        
        # Clamp speed to valid range
        speed = max(0, min(100, speed))
        
        # Update motor state
        self.motor_states[motor_id] = {
            "direction": direction,
            "speed": speed
        }
        
        # Get channel for this motor
        channel = self.motor_to_channel[motor_id]
        
        # Send command via ROS bridge if available
        if self.ros_bridge:
            try:
                # For motors sharing a channel, we need to consider both motors
                channel_motors = [m for m, ch in self.motor_to_channel.items() if ch == channel]
                
                # If both motors on the channel have the same direction, use that
                # Otherwise, handle mixed directions appropriately
                channel_direction = direction
                channel_speed = speed
                
                # Send motor command
                self.ros_bridge.send_motor_command(channel, channel_direction, channel_speed)
                
                logger.info(f"Motor {motor_id} set to {direction} at speed {speed}")
                
                return {
                    "success": True,
                    "motor_id": motor_id,
                    "direction": direction,
                    "speed": speed,
                    "channel": channel
                }
                
            except Exception as e:
                logger.error(f"Failed to send motor command: {e}")
                return {
                    "success": False,
                    "error": str(e)
                }
        else:
            # No ROS bridge - just update local state
            return {
                "success": True,
                "motor_id": motor_id,
                "direction": direction,
                "speed": speed,
                "message": "Motor state updated (no ROS bridge connected)"
            }
    
    def get_motor_state(self, motor_id: int) -> Optional[Dict[str, Any]]:
        """Get current state of a specific motor"""
        if motor_id in self.motor_states:
            return self.motor_states[motor_id]
        return None
    
    def get_all_motor_states(self) -> Dict[int, Dict[str, Any]]:
        """Get current state of all motors"""
        return self.motor_states.copy()
    
    def stop_all_motors(self) -> Dict[str, Any]:
        """Emergency stop - brake all motors"""
        try:
            for motor_id in range(1, 5):
                self.set_motor(motor_id, "brake", 0)
            
            logger.warning("Emergency stop - all motors braked")
            
            return {
                "success": True,
                "message": "All motors stopped"
            }
            
        except Exception as e:
            logger.error(f"Failed to stop all motors: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def set_channel_motors(self, channel: str, direction: str, speed: int) -> Dict[str, Any]:
        """
        Control all motors on a specific channel
        Used for coordinated movement (e.g., both left motors for turning)
        
        Args:
            channel: 'A' or 'B'
            direction: 'forward', 'backward', or 'brake'
            speed: Speed value (0-100)
        """
        if channel not in ['A', 'B']:
            return {
                "success": False,
                "error": f"Invalid channel: {channel}"
            }
        
        # Find motors on this channel
        channel_motors = [m for m, ch in self.motor_to_channel.items() if ch == channel]
        
        # Set all motors on the channel
        for motor_id in channel_motors:
            result = self.set_motor(motor_id, direction, speed)
            if not result['success']:
                return result
        
        return {
            "success": True,
            "channel": channel,
            "motors": channel_motors,
            "direction": direction,
            "speed": speed
        }

# Singleton instance
_motor_controller_instance = None

def get_motor_controller(ros_bridge=None):
    """Get or create motor controller instance"""
    global _motor_controller_instance
    
    if _motor_controller_instance is None:
        _motor_controller_instance = MotorController(ros_bridge)
    elif ros_bridge is not None:
        _motor_controller_instance.set_ros_bridge(ros_bridge)
    
    return _motor_controller_instance
================================================================================


================================================================================
FILE: backend/motors/motor_routes.py
Category: Python | Size: 4.1 KB | Lines: 127
================================================================================
"""
Motor Control Routes Module
Handles all motor-related API endpoints
Fixed: Left/Right motor reversal issue
"""

from flask import Blueprint, jsonify, request, render_template
import logging

# Create Blueprint
motor_bp = Blueprint('motors', __name__)

# Setup logging
logger = logging.getLogger(__name__)

# =============================================================================
# MOTOR PAGE ROUTE
# =============================================================================

@motor_bp.route('/motors')
def motors_page():
    """Serve the motor control interface"""
    return render_template('motor_control.html')

# =============================================================================
# MOTOR CONTROL API ROUTES
# =============================================================================

@motor_bp.route('/api/motor/<int:motor_id>', methods=['POST'])
def control_motor(motor_id):
    """Control a specific motor"""
    try:
        from backend.motors.motor_controller import get_motor_controller
        motor_controller = get_motor_controller()
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        # Use motor controller
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in control_motor: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@motor_bp.route('/api/motor/<int:motor_id>', methods=['GET'])
def get_motor_status(motor_id):
    """Get current status of a specific motor"""
    from backend.motors.motor_controller import get_motor_controller
    motor_controller = get_motor_controller()
    state = motor_controller.get_motor_state(motor_id)
    
    if state:
        return jsonify({
            "success": True,
            "motor_id": motor_id,
            "state": state
        })
    else:
        return jsonify({
            "success": False,
            "error": "Invalid motor ID"
        }), 404

@motor_bp.route('/api/motors', methods=['GET'])
def get_all_motors_status():
    """Get current status of all motors"""
    from backend.motors.motor_controller import get_motor_controller
    motor_controller = get_motor_controller()
    states = motor_controller.get_all_motor_states()
    
    return jsonify({
        "success": True,
        "motors": states
    })

@motor_bp.route('/api/motors/stop', methods=['POST'])
def stop_all_motors():
    """Emergency stop - brake all motors"""
    from backend.motors.motor_controller import get_motor_controller
    motor_controller = get_motor_controller()
    result = motor_controller.stop_all_motors()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

# Optional: WebSocket support for real-time motor control
def init_motor_websocket(socketio):
    """Initialize WebSocket handlers for motor control"""
    
    @socketio.on('motor_command')
    def handle_motor_command(data):
        """Handle real-time motor commands via WebSocket"""
        from backend.motors.motor_controller import get_motor_controller
        motor_controller = get_motor_controller()
        motor_id = data.get('motor_id')
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        socketio.emit('motor_response', {
            'motor_id': motor_id,
            'result': result
        })
    
    @socketio.on('request_motor_states')
    def handle_motor_states_request():
        """Send current motor states via WebSocket"""
        from backend.motors.motor_controller import get_motor_controller
        motor_controller = get_motor_controller()
        states = motor_controller.get_all_motor_states()
        socketio.emit('motor_states', states)
================================================================================


================================================================================
FILE: backend/motors/servo_control.py
Category: Python | Size: 6.7 KB | Lines: 199
================================================================================
"""
Servo Control Interface for Aiming System
Controls pan and tilt servos through ROS2 topics
"""

import json
import logging
from typing import Dict, Any, Optional, Callable
from datetime import datetime
import asyncio

logger = logging.getLogger(__name__)

class ServoController:
    def __init__(self):
        self.pan_angle = 135.0  # Default center position
        self.tilt_angle = 135.0  # Default center position
        self.pan_moving = False
        self.tilt_moving = False
        self.connected = False
        self.ros_bridge = None
        self.websocket_handler = None
        self.last_command_time = None
        
        # Servo limits
        self.pan_min = 75.0
        self.pan_max = 195.0
        self.tilt_min = 75.0
        self.tilt_max = 195.0
        
        # Movement tracking
        self.target_pan = 135.0
        self.target_tilt = 135.0
        self.movement_speed = 60.0  # degrees per second
        
        logger.info("Servo controller initialized")
    
    def set_ros_bridge(self, ros_bridge):
        """Set the ROS bridge instance for publishing commands"""
        self.ros_bridge = ros_bridge
        self.connected = True
        logger.info("ROS bridge connected to servo controller")
    
    def set_websocket_handler(self, handler: Callable):
        """Set the WebSocket handler for sending updates"""
        self.websocket_handler = handler
    
    def move_to_position(self, pan: float, tilt: float) -> Dict[str, Any]:
        """
        Move servos to specified position (synchronous version)
        
        Args:
            pan: Pan angle (75-195 degrees)
            tilt: Tilt angle (75-195 degrees)
            
        Returns:
            Status dictionary
        """
        # Run async version in sync context
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        result = loop.run_until_complete(self._async_move_to_position(pan, tilt))
        loop.close()
        return result
    
    async def _async_move_to_position(self, pan: float, tilt: float) -> Dict[str, Any]:
        """
        Move servos to specified position (async version)
        
        Args:
            pan: Pan angle (75-195 degrees)
            tilt: Tilt angle (75-195 degrees)
            
        Returns:
            Status dictionary
        """
        # Validate angles
        pan = max(self.pan_min, min(self.pan_max, pan))
        tilt = max(self.tilt_min, min(self.tilt_max, tilt))
        
        self.target_pan = pan
        self.target_tilt = tilt
        self.last_command_time = datetime.now()
        
        # Check if movement needed
        if abs(self.pan_angle - pan) > 0.5:
            self.pan_moving = True
        if abs(self.tilt_angle - tilt) > 0.5:
            self.tilt_moving = True
        
        # Send ROS command if bridge available
        if self.ros_bridge:
            try:
                from backend.ros_bridge import get_servo_publisher
                servo_pub = get_servo_publisher()
                success = servo_pub.publish_position(pan, tilt)
                if success:
                    logger.info(f"Servo command sent: pan={pan}, tilt={tilt}")
                else:
                    logger.error("Failed to publish servo command")
                    return {
                        'success': False,
                        'error': 'Failed to publish servo command'
                    }
            except Exception as e:
                logger.error(f"Failed to send servo command: {e}")
                return {
                    'success': False,
                    'error': str(e)
                }
        
        # Update positions immediately for UI feedback
        self.pan_angle = pan
        self.tilt_angle = tilt
        self.pan_moving = False
        self.tilt_moving = False
        
        return {
            'success': True,
            'pan_angle': pan,
            'tilt_angle': tilt,
            'message': f"Moving to pan={pan}°, tilt={tilt}°"
        }
    
    def get_state(self) -> Dict[str, Any]:
        """Get current servo state"""
        return {
            'pan_angle': round(self.pan_angle, 1),
            'tilt_angle': round(self.tilt_angle, 1),
            'pan_moving': self.pan_moving,
            'tilt_moving': self.tilt_moving,
            'connected': self.connected,
            'target_pan': self.target_pan,
            'target_tilt': self.target_tilt,
            'timestamp': datetime.now().isoformat()
        }
    
    def center_position(self) -> Dict[str, Any]:
        """Move servos to center position (135, 135)"""
        return self.move_to_position(135.0, 135.0)
    
    def move_left(self) -> Dict[str, Any]:
        """Move to left position"""
        return self.move_to_position(75.0, 135.0)
    
    def move_right(self) -> Dict[str, Any]:
        """Move to right position"""
        return self.move_to_position(195.0, 135.0)
    
    def move_up(self) -> Dict[str, Any]:
        """Move to up position"""
        return self.move_to_position(135.0, 195.0)
    
    def move_down(self) -> Dict[str, Any]:
        """Move to down position"""
        return self.move_to_position(135.0, 75.0)
    
    def emergency_stop(self):
        """Stop all servo movement"""
        self.pan_moving = False
        self.tilt_moving = False
        self.target_pan = self.pan_angle
        self.target_tilt = self.tilt_angle
        logger.warning("Emergency stop activated for servos")
    
    def process_ros_feedback(self, data: Dict[str, Any]):
        """Process feedback from ROS about actual servo positions"""
        if 'pan_angle' in data:
            self.pan_angle = data['pan_angle']
        if 'tilt_angle' in data:
            self.tilt_angle = data['tilt_angle']
        
        # Check if reached target
        if abs(self.pan_angle - self.target_pan) < 1.0:
            self.pan_moving = False
        if abs(self.tilt_angle - self.target_tilt) < 1.0:
            self.tilt_moving = False
    
    def handle_websocket_command(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle commands from WebSocket (synchronous)"""
        action = data.get('action')
        
        if action == 'move':
            pan = data.get('pan_angle', self.pan_angle)
            tilt = data.get('tilt_angle', self.tilt_angle)
            return self.move_to_position(pan, tilt)
        
        elif action == 'center':
            return self.center_position()
        
        elif action == 'get_state':
            return self.get_state()
        
        elif action == 'emergency_stop':
            self.emergency_stop()
            return {'success': True, 'message': 'Emergency stop activated'}
        
        else:
            return {'success': False, 'error': f'Unknown action: {action}'}
================================================================================


================================================================================
FILE: backend/ros_bridge.py
Category: Python | Size: 16.9 KB | Lines: 522
================================================================================
#!/usr/bin/env python3
"""
ROS Bridge WebSocket communication module
Handles all ROS 2 communication via rosbridge
"""

import json
import logging
from websocket import create_connection
from typing import Dict, Any, Optional, Tuple

# Setup logging
logger = logging.getLogger(__name__)

class ROSBridgeConnection:
    """Manages WebSocket connection to ROS 2 via rosbridge"""
    
    def __init__(self, host: str = "192.168.2.4", port: int = 9090):
        """
        Initialize ROS Bridge connection parameters
        
        Args:
            host: IP address of the ROS 2 robot
            port: rosbridge websocket port (default: 9090)
        """
        self.host = host
        self.port = port
        self.url = f"ws://{host}:{port}"
        self._connection = None
        
        # Known service types mapping
        self.service_types = {
            "/set_motor": "motor_interfaces/srv/SetMotor",
            "/set_actuator": "actuator_interfaces/srv/SetActuator",
            "/get_thermal_frame": "mlx90640_interfaces/srv/GetThermalFrame",
            "/get_system_status": "system_interfaces/srv/GetSystemStatus"
        }
    
    def connect(self) -> bool:
        """
        Establish connection to rosbridge
        
        Returns:
            bool: True if connection successful, False otherwise
        """
        try:
            self._connection = create_connection(self.url, timeout=5)
            logger.info(f"Connected to rosbridge at {self.url}")
            return True
        except Exception as e:
            logger.error(f"Failed to connect to rosbridge: {e}")
            return False
    
    def disconnect(self):
        """Close the websocket connection"""
        if self._connection:
            self._connection.close()
            self._connection = None
            logger.info("Disconnected from rosbridge")
    
    def is_connected(self) -> bool:
        """Check if connection is active"""
        return self._connection is not None
    
    def call_service(self, service_name: str, args: Dict[str, Any], 
                    service_id: Optional[str] = None,
                    service_type: Optional[str] = None) -> Tuple[bool, Dict[str, Any]]:
        """
        Call a ROS service through rosbridge
        
        Args:
            service_name: Name of the ROS service (e.g., "/set_motor")
            args: Service arguments as dictionary
            service_id: Optional ID for the service call
            service_type: Optional service type (e.g., "actuator_interfaces/srv/SetActuator")
        
        Returns:
            Tuple[bool, Dict]: (success, response_data)
        """
        try:
            # Try to create a new connection for each call to avoid broken pipe
            ws = create_connection(self.url, timeout=10)  # Increased timeout
            
            # Determine service type if not provided
            if not service_type and service_name in self.service_types:
                service_type = self.service_types[service_name]
            
            # Prepare service call message
            request = {
                "op": "call_service",
                "service": service_name,
                "args": args
            }
            
            # Add service type if known
            if service_type:
                request["type"] = service_type
                logger.debug(f"Using service type: {service_type}")
            
            if service_id:
                request["id"] = service_id
            
            logger.debug(f"Service call request: {request}")
            
            # Send request
            ws.send(json.dumps(request))
            
            # Get response with longer timeout
            ws.settimeout(10)
            response = ws.recv()
            response_data = json.loads(response)
            
            # Close connection
            ws.close()
            
            logger.debug(f"Service call response: {response_data}")
            
            # Check if response indicates success
            if "result" in response_data and response_data["result"] is True:
                return True, response_data
            elif "values" in response_data:
                # Service call succeeded, return the values
                return True, response_data
            else:
                # Check for error in response
                error_msg = response_data.get("error", response_data.get("msg", "Unknown error"))
                if error_msg:
                    logger.error(f"Service call error: {error_msg}")
                    return False, {"error": error_msg}
                else:
                    # No error but also no clear success indicator
                    return True, response_data
                    
        except Exception as e:
            logger.error(f"Service call failed: {e}")
            return False, {"error": str(e)}
    
    def publish_topic(self, topic_name: str, msg_type: str, msg_data: Dict[str, Any]) -> bool:
        """
        Publish a message to a ROS topic
        
        Args:
            topic_name: Name of the ROS topic (e.g., "/servo_position_cmd")
            msg_type: ROS message type (e.g., "servo_interfaces/msg/ServoPosition")
            msg_data: Message data as dictionary
        
        Returns:
            bool: True if publish successful, False otherwise
        """
        try:
            # Create a new connection for publishing
            ws = create_connection(self.url, timeout=5)
            
            # First advertise the topic
            advertise_msg = {
                "op": "advertise",
                "topic": topic_name,
                "type": msg_type
            }
            ws.send(json.dumps(advertise_msg))
            
            # Then publish the message
            publish_msg = {
                "op": "publish",
                "topic": topic_name,
                "msg": msg_data
            }
            ws.send(json.dumps(publish_msg))
            
            # Close connection
            ws.close()
            
            logger.debug(f"Published to {topic_name}: {msg_data}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to publish to topic {topic_name}: {e}")
            return False
    
    def subscribe_topic(self, topic_name: str, callback=None) -> bool:
        """
        Subscribe to a ROS topic
        
        Args:
            topic_name: Name of the ROS topic
            callback: Function to call when message received
        
        Returns:
            bool: True if subscription successful
        """
        try:
            if not self._connection:
                self.connect()
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": topic_name
            }
            self._connection.send(json.dumps(subscribe_msg))
            
            logger.info(f"Subscribed to topic: {topic_name}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to topic {topic_name}: {e}")
            return False
    
    def test_connection(self) -> bool:
        """
        Test if rosbridge connection is working
        
        Returns:
            bool: True if connection is working
        """
        try:
            temp_conn = create_connection(self.url, timeout=2)
            temp_conn.close()
            return True
        except Exception:
            return False
    
    def send_motor_command(self, channel: str, direction: str, speed: int):
        """
        Send motor command via service call
        
        Args:
            channel: Motor channel ('A' or 'B')
            direction: Motor direction
            speed: Motor speed (PWM value)
        """
        # Map channel to motor IDs
        if channel == 'A':
            motor_ids = [0, 1]  # Motors on channel A
        else:
            motor_ids = [2, 3]  # Motors on channel B
        
        # Send command to each motor on the channel
        for motor_id in motor_ids:
            self.call_service(
                "/set_motor",
                {
                    "motor_id": motor_id,
                    "direction": direction,
                    "speed": speed
                },
                f"motor_cmd_{motor_id}"
            )

class MotorController:
    """High-level motor control interface using ROSBridge"""
    
    def __init__(self, ros_bridge: ROSBridgeConnection):
        """
        Initialize motor controller
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.motor_states = {
            0: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            1: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            2: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            3: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0}
        }
    
    @staticmethod
    def percent_to_pwm(percent: float) -> int:
        """
        Convert percentage (0-100) to PWM value (0-65535)
        
        For dual-PWM motor drivers, use NORMAL mapping:
        - 0% speed → PWM 0 (motor stopped)
        - 100% speed → PWM 65535 (motor full speed)
        
        Note: The previous INVERTED mapping was for different motor drivers
        """
        # Ensure percent is within bounds
        percent = max(0, min(100, percent))
        
        # NORMAL PWM calculation (not inverted)
        # 0% → 0, 100% → 65535
        pwm = int((percent / 100.0) * 65535)
        
        logger.debug(f"Converting {percent}% to PWM: {pwm}")
        return pwm
    
    @staticmethod
    def pwm_to_percent(pwm: int) -> float:
        """
        Convert PWM value (0-65535) to percentage (0-100)
        
        Using NORMAL mapping:
        - PWM 0 = 0% speed
        - PWM 65535 = 100% speed
        """
        # NORMAL calculation (not inverted)
        return round((pwm / 65535.0) * 100, 1)
    
    def set_motor(self, motor_id: int, direction: str, speed_percent: float) -> Dict[str, Any]:
        """
        Set motor speed and direction
        
        Args:
            motor_id: Motor ID (0-3)
            direction: Direction ("forward", "backward", "brake")
            speed_percent: Speed in percentage (0-100)
        
        Returns:
            Dict containing operation result
        """
        # Validate inputs
        if motor_id < 0 or motor_id > 3:
            return {
                "success": False,
                "error": "Invalid motor ID. Must be 0-3"
            }
        
        if direction not in ["forward", "backward", "brake"]:
            return {
                "success": False,
                "error": "Invalid direction. Must be 'forward', 'backward', or 'brake'"
            }
        
        if not isinstance(speed_percent, (int, float)) or speed_percent < 0 or speed_percent > 100:
            return {
                "success": False,
                "error": "Invalid speed. Must be 0-100"
            }
        
        # Convert to PWM with NORMAL mapping
        if direction == "brake":
            # Brake always uses PWM 0
            speed_pwm = 0
        else:
            # Use normal PWM mapping: 0% = PWM 0, 100% = PWM 65535
            speed_pwm = self.percent_to_pwm(speed_percent)
        
        # Call ROS service (connection is handled in call_service)
        service_args = {
            "motor_id": motor_id,
            "direction": direction,
            "speed": speed_pwm
        }
        
        logger.info(f"Sending to ROS - Motor: {motor_id}, Direction: {direction}, Speed: {speed_percent}% (PWM: {speed_pwm})")
        
        success, response = self.ros_bridge.call_service(
            "/set_motor", 
            service_args,
            f"motor_cmd_{motor_id}"
        )
        
        if success:
            # Update internal state
            self.motor_states[motor_id] = {
                "direction": direction,
                "speed_percent": speed_percent,
                "speed_pwm": speed_pwm
            }
            
            logger.info(f"Motor {motor_id} set to {direction} at {speed_percent}% (PWM: {speed_pwm})")
            
            return {
                "success": True,
                "motor_id": motor_id,
                "direction": direction,
                "speed_percent": speed_percent,
                "speed_pwm": speed_pwm,
                "response": response
            }
        else:
            return {
                "success": False,
                "error": response.get("error", "Unknown error"),
                "motor_id": motor_id
            }
    
    def stop_all_motors(self) -> Dict[str, Any]:
        """
        Emergency stop - brake all motors
        
        Returns:
            Dict containing results for all motors
        """
        results = []
        
        for motor_id in range(4):
            # Brake with speed 0
            result = self.set_motor(motor_id, "brake", 0)
            results.append(result)
        
        all_success = all(r["success"] for r in results)
        
        return {
            "success": all_success,
            "results": results
        }
    
    def get_motor_state(self, motor_id: int) -> Optional[Dict[str, Any]]:
        """
        Get current state of a motor
        
        Args:
            motor_id: Motor ID (0-3)
        
        Returns:
            Dict with motor state or None if invalid ID
        """
        if motor_id in self.motor_states:
            return self.motor_states[motor_id].copy()
        return None
    
    def get_all_motor_states(self) -> Dict[int, Dict[str, Any]]:
        """Get current state of all motors"""
        return self.motor_states.copy()

class ServoPublisher:
    """High-level servo control interface using ROSBridge"""
    
    def __init__(self, ros_bridge: ROSBridgeConnection):
        """
        Initialize servo publisher
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.topic_name = "/servo_position_cmd"
        self.msg_type = "servo_interfaces/msg/ServoPosition"
    
    def publish_position(self, pan_angle: float, tilt_angle: float) -> bool:
        """
        Publish servo position command
        
        Args:
            pan_angle: Pan servo angle (75-195 degrees)
            tilt_angle: Tilt servo angle (75-195 degrees)
        
        Returns:
            bool: True if successful
        """
        # Prepare message
        msg_data = {
            "pan_angle": pan_angle,
            "tilt_angle": tilt_angle
        }
        
        # Publish to topic
        success = self.ros_bridge.publish_topic(
            self.topic_name,
            self.msg_type,
            msg_data
        )
        
        if success:
            logger.info(f"Published servo position: pan={pan_angle}, tilt={tilt_angle}")
        else:
            logger.error(f"Failed to publish servo position")
        
        return success

# Create singleton instances for easy import
_ros_bridge = None
_motor_controller = None
_servo_publisher = None

def get_ros_bridge(host: str = None, port: int = None) -> ROSBridgeConnection:
    """Get or create ROSBridge connection instance"""
    global _ros_bridge
    
    # If host/port provided, update or create new connection
    if host is not None or port is not None:
        if _ros_bridge:
            # Update existing connection
            if host:
                _ros_bridge.host = host
                _ros_bridge.url = f"ws://{host}:{_ros_bridge.port}"
            if port:
                _ros_bridge.port = port
                _ros_bridge.url = f"ws://{_ros_bridge.host}:{port}"
        else:
            # Create new connection with provided settings
            _ros_bridge = ROSBridgeConnection(
                host or "192.168.2.4", 
                port or 9090
            )
    elif _ros_bridge is None:
        # Create with defaults if not exists
        _ros_bridge = ROSBridgeConnection()
    
    return _ros_bridge

def get_motor_controller() -> MotorController:
    """Get or create MotorController instance"""
    global _motor_controller
    if _motor_controller is None:
        _motor_controller = MotorController(get_ros_bridge())
    return _motor_controller

def get_servo_publisher() -> ServoPublisher:
    """Get or create ServoPublisher instance"""
    global _servo_publisher
    if _servo_publisher is None:
        _servo_publisher = ServoPublisher(get_ros_bridge())
    return _servo_publisher

# Convenience function for servo control to match the expected interface
async def publish_servo_position(pan_angle: float, tilt_angle: float) -> bool:
    """
    Publish servo position (async wrapper for compatibility)
    
    Args:
        pan_angle: Pan servo angle
        tilt_angle: Tilt servo angle
    
    Returns:
        bool: Success status
    """
    servo_pub = get_servo_publisher()
    return servo_pub.publish_position(pan_angle, tilt_angle)
================================================================================


================================================================================
FILE: backend/sensors/__init__.py
Category: Python | Size: 390.0 B | Lines: 16
================================================================================
"""
Sensor modules for ROS 2 robot
"""

from .lidar import LidarSensor, get_lidar_sensor
from .thermal_camera import ThermalCameraSensor, get_thermal_camera_sensor
from .system_monitor import SystemMonitor, get_system_monitor

__all__ = [
    'LidarSensor',
    'get_lidar_sensor',
    'ThermalCameraSensor',
    'get_thermal_camera_sensor',
    'SystemMonitor',
    'get_system_monitor',
]
================================================================================


================================================================================
FILE: backend/sensors/lidar.py
Category: Python | Size: 8.0 KB | Lines: 243
================================================================================
#!/usr/bin/env python3
"""
Lidar sensor module for ROS 2
Handles lidar data subscription and processing
"""

import json
import logging
import threading
import time
from typing import Dict, Any, Optional, Callable, List
import numpy as np
from websocket import create_connection

logger = logging.getLogger(__name__)

class LidarSensor:
    """Subscribe to and process lidar scan data via ROSBridge"""
    
    def __init__(self, ros_bridge):
        """
        Initialize lidar sensor
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.scan_callback = None
        self.latest_scan = None
        self.subscription_active = False
        self._ws = None
        self._ws_thread = None
        self._stop_thread = False
        
    def subscribe(self, callback: Optional[Callable] = None, 
                 processed_data: bool = True) -> bool:
        """
        Subscribe to /scan topic
        
        Args:
            callback: Optional callback function for new scan data
            processed_data: If True, return processed data; if False, return raw
        
        Returns:
            bool: Success status
        """
        try:
            # Create a dedicated connection for subscription
            self._ws = create_connection(self.ros_bridge.url, timeout=5)
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": "/scan",
                "type": "sensor_msgs/LaserScan"
            }
            
            self._ws.send(json.dumps(subscribe_msg))
            logger.info("Subscribed to /scan topic")
            
            # Start receiving thread
            self.subscription_active = True
            self._stop_thread = False
            self._ws_thread = threading.Thread(
                target=self._receive_scan_data, 
                args=(callback, processed_data)
            )
            self._ws_thread.daemon = True
            self._ws_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to scan: {e}")
            return False
    
    def _receive_scan_data(self, callback, processed_data):
        """Receive scan data in separate thread"""
        while self.subscription_active and not self._stop_thread:
            try:
                response = self._ws.recv()
                data = json.loads(response)
                
                if data.get("op") == "publish" and data.get("topic") == "/scan":
                    msg = data["msg"]
                    
                    if processed_data:
                        # Process the data for easier use
                        processed = self._process_scan_data(msg)
                        self.latest_scan = processed
                        
                        if callback:
                            callback(processed)
                    else:
                        # Return raw data
                        self.latest_scan = msg
                        
                        if callback:
                            callback(msg)
                            
            except Exception as e:
                if self.subscription_active:
                    logger.error(f"Error receiving scan data: {e}")
                break
        
        if self._ws:
            self._ws.close()
        logger.info("Scan subscription thread ended")
    
    def _process_scan_data(self, scan_msg: Dict) -> Dict[str, Any]:
        """
        Process raw scan data into more useful format
        
        Args:
            scan_msg: Raw LaserScan message
            
        Returns:
            Dict with processed data including points for visualization
        """
        ranges = scan_msg["ranges"]
        angle_min = scan_msg["angle_min"]
        angle_increment = scan_msg["angle_increment"]
        
        # Filter out invalid readings (0.0 or inf)
        valid_ranges = [(i, r) for i, r in enumerate(ranges) 
                       if r > 0.1 and r < 10.0]
        
        if not valid_ranges:
            return {
                "min_distance": float('inf'),
                "min_angle": 0,
                "obstacles": [],
                "safe_directions": ["all"],
                "points": [],
                "timestamp": time.time(),
                "point_count": 0
            }
        
        # Find minimum distance
        min_idx, min_dist = min(valid_ranges, key=lambda x: x[1])
        min_angle = angle_min + min_idx * angle_increment
        
        # Convert to cartesian coordinates for visualization
        points = []
        obstacles = []
        
        for idx, dist in valid_ranges:
            angle = angle_min + idx * angle_increment
            x = dist * np.cos(angle)
            y = dist * np.sin(angle)
            
            points.append({
                "x": float(x),
                "y": float(y),
                "r": float(dist),
                "theta": float(angle),
                "theta_deg": float(np.degrees(angle))
            })
            
            # Detect obstacles (anything closer than 0.5m)
            if dist < 0.5:
                obstacles.append({
                    "angle": float(angle),
                    "angle_deg": float(np.degrees(angle)),
                    "distance": float(dist),
                    "x": float(x),
                    "y": float(y)
                })
        
        # Determine safe directions
        safe_directions = self._calculate_safe_directions(valid_ranges, angle_min, angle_increment)
        
        return {
            "min_distance": float(min_dist),
            "min_angle": float(min_angle),
            "min_angle_deg": float(np.degrees(min_angle)),
            "obstacles": obstacles,
            "safe_directions": safe_directions,
            "obstacle_count": len(obstacles),
            "points": points,
            "point_count": len(points),
            "timestamp": time.time()
        }
    
    def _calculate_safe_directions(self, valid_ranges, angle_min, angle_increment):
        """Calculate safe movement directions based on scan data"""
        safe_directions = []
        
        # Check sectors (front, left, right, back)
        sectors = {
            "front": (-30, 30),
            "left": (60, 120),
            "right": (-120, -60),
            "back": (150, 180)  # and (-180, -150)
        }
        
        for direction, (start_deg, end_deg) in sectors.items():
            start_rad = np.radians(start_deg)
            end_rad = np.radians(end_deg)
            
            # Check if sector is clear
            sector_clear = True
            for idx, dist in valid_ranges:
                angle = angle_min + idx * angle_increment
                
                # Handle back sector wraparound
                if direction == "back":
                    if (angle > np.radians(150) or angle < np.radians(-150)):
                        if dist < 0.5:
                            sector_clear = False
                            break
                else:
                    if start_rad <= angle <= end_rad and dist < 0.5:
                        sector_clear = False
                        break
            
            if sector_clear:
                safe_directions.append(direction)
        
        return safe_directions
    
    def get_latest_scan(self) -> Optional[Dict[str, Any]]:
        """Get the most recent scan data"""
        return self.latest_scan
    
    def unsubscribe(self):
        """Stop subscription"""
        self.subscription_active = False
        self._stop_thread = True
        if self._ws_thread:
            self._ws_thread.join(timeout=2)
        logger.info("Unsubscribed from scan topic")

# Singleton instance
_lidar_sensor = None

def get_lidar_sensor():
    """Get or create LidarSensor instance"""
    global _lidar_sensor
    if _lidar_sensor is None:
        from backend.ros_bridge import get_ros_bridge
        _lidar_sensor = LidarSensor(get_ros_bridge())
    return _lidar_sensor
================================================================================


================================================================================
FILE: backend/sensors/system_monitor.py
Category: Python | Size: 7.5 KB | Lines: 209
================================================================================
#!/usr/bin/env python3
"""
System monitor module for ROS 2
Handles system status subscription and processing
"""

import json
import logging
import threading
import time
from typing import Dict, Any, Optional, Callable
from websocket import create_connection

logger = logging.getLogger(__name__)

class SystemMonitor:
    """Subscribe to and process system monitor data via ROSBridge"""
    
    def __init__(self, ros_bridge):
        """
        Initialize system monitor
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.status_callback = None
        self.latest_status = None
        self.subscription_active = False
        self._ws = None
        self._ws_thread = None
        self._stop_thread = False
        
        # Default values
        self.default_status = {
            "cpu_usage": 0.0,
            "memory_usage": 0.0,
            "disk_usage": 0.0,
            "temperature": 0.0,
            "timestamp": time.time()
        }
        
    def subscribe(self, callback: Optional[Callable] = None) -> bool:
        """
        Subscribe to system status topics
        
        Args:
            callback: Optional callback function for new status data
        
        Returns:
            bool: Success status
        """
        try:
            # Create a dedicated connection for subscription
            self._ws = create_connection(self.ros_bridge.url, timeout=5)
            
            # Subscribe to all system topics
            topics = [
                ("/system/cpu_usage", "std_msgs/Float32"),
                ("/system/memory_usage", "std_msgs/Float32"),
                ("/system/temperature", "sensor_msgs/Temperature"),
                ("/system/status_json", "std_msgs/String")
            ]
            
            for topic, msg_type in topics:
                subscribe_msg = {
                    "op": "subscribe",
                    "topic": topic,
                    "type": msg_type
                }
                self._ws.send(json.dumps(subscribe_msg))
                logger.info(f"Subscribed to {topic}")
            
            # Start receiving thread
            self.subscription_active = True
            self._stop_thread = False
            self._ws_thread = threading.Thread(
                target=self._receive_status_data, 
                args=(callback,)
            )
            self._ws_thread.daemon = True
            self._ws_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to system monitor: {e}")
            return False
    
    def _receive_status_data(self, callback):
        """Receive status data in separate thread"""
        current_status = self.default_status.copy()
        
        while self.subscription_active and not self._stop_thread:
            try:
                response = self._ws.recv()
                data = json.loads(response)
                
                if data.get("op") == "publish":
                    topic = data.get("topic")
                    msg = data.get("msg")
                    
                    # Update status based on topic
                    if topic == "/system/cpu_usage":
                        current_status["cpu_usage"] = msg.get("data", 0.0)
                    elif topic == "/system/memory_usage":
                        current_status["memory_usage"] = msg.get("data", 0.0)
                    elif topic == "/system/temperature":
                        # Temperature message has a different structure
                        current_status["temperature"] = msg.get("temperature", 0.0)
                    elif topic == "/system/status_json":
                        # Parse JSON status if available
                        try:
                            status_data = json.loads(msg.get("data", "{}"))
                            current_status.update(status_data)
                        except:
                            pass
                    
                    # Update timestamp
                    current_status["timestamp"] = time.time()
                    
                    # Process the status data
                    processed = self._process_status_data(current_status)
                    self.latest_status = processed
                    
                    if callback:
                        callback(processed)
                        
            except Exception as e:
                if self.subscription_active:
                    logger.error(f"Error receiving status data: {e}")
                break
        
        if self._ws:
            self._ws.close()
        logger.info("System monitor subscription thread ended")
    
    def _process_status_data(self, status: Dict) -> Dict[str, Any]:
        """
        Process raw status data for easier use
        
        Args:
            status: Raw status data
            
        Returns:
            Dict with processed data
        """
        return {
            "cpu_usage": round(status.get("cpu_usage", 0.0), 1),
            "memory_usage": round(status.get("memory_usage", 0.0), 1),
            "disk_usage": round(status.get("disk_usage", 0.0), 1),
            "temperature": round(status.get("temperature", 0.0), 1),
            "cpu_percent": f"{round(status.get('cpu_usage', 0.0), 1)}%",
            "memory_percent": f"{round(status.get('memory_usage', 0.0), 1)}%",
            "disk_percent": f"{round(status.get('disk_usage', 0.0), 1)}%",
            "temp_celsius": f"{round(status.get('temperature', 0.0), 1)}°C",
            "timestamp": status.get("timestamp", time.time()),
            "healthy": status.get("cpu_usage", 0) < 80 and status.get("temperature", 0) < 70
        }
    
    def get_latest_status(self) -> Optional[Dict[str, Any]]:
        """Get the most recent system status"""
        return self.latest_status
    
    def get_status_once(self) -> Optional[Dict[str, Any]]:
        """Request system status via service calls (if available)"""
        try:
            # Try to get status from service
            success, response = self.ros_bridge.call_service(
                "/get_system_status",
                {},
                "get_system_status"
            )
            
            if success and response.get("values"):
                status_data = response["values"]
                return self._process_status_data({
                    "cpu_usage": status_data.get("cpu_usage", 0.0),
                    "memory_usage": status_data.get("memory_usage", 0.0),
                    "disk_usage": status_data.get("disk_usage", 0.0),
                    "temperature": status_data.get("temperature", 0.0),
                    "timestamp": time.time()
                })
            else:
                logger.error("Failed to get system status via service")
                return None
                
        except Exception as e:
            logger.error(f"Error calling system status service: {e}")
            return None
    
    def unsubscribe(self):
        """Stop subscription"""
        self.subscription_active = False
        self._stop_thread = True
        if self._ws_thread:
            self._ws_thread.join(timeout=2)
        logger.info("Unsubscribed from system monitor")

# Singleton instance
_system_monitor = None

def get_system_monitor():
    """Get or create SystemMonitor instance"""
    global _system_monitor
    if _system_monitor is None:
        from backend.ros_bridge import get_ros_bridge
        _system_monitor = SystemMonitor(get_ros_bridge())
    return _system_monitor
================================================================================


================================================================================
FILE: backend/sensors/thermal_camera.py
Category: Python | Size: 7.7 KB | Lines: 222
================================================================================
#!/usr/bin/env python3
"""
Thermal camera sensor module for MLX90640
Handles thermal data subscription and processing
"""

import json
import logging
import threading
import time
from typing import Dict, Any, Optional, Callable
import numpy as np
from websocket import create_connection

logger = logging.getLogger(__name__)

class ThermalCameraSensor:
    """Subscribe to and process thermal camera data via ROSBridge"""
    
    def __init__(self, ros_bridge):
        """
        Initialize thermal camera sensor
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.thermal_callback = None
        self.latest_frame = None
        self.subscription_active = False
        self._ws = None
        self._ws_thread = None
        self._stop_thread = False
        
    def subscribe(self, callback: Optional[Callable] = None) -> bool:
        """
        Subscribe to /thermal_frame topic
        
        Args:
            callback: Optional callback function for new thermal data
        
        Returns:
            bool: Success status
        """
        try:
            # Create a dedicated connection for subscription
            self._ws = create_connection(self.ros_bridge.url, timeout=5)
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": "/thermal_frame",
                "type": "mlx90640_interfaces/ThermalFrame"
            }
            
            self._ws.send(json.dumps(subscribe_msg))
            logger.info("Subscribed to /thermal_frame topic")
            
            # Start receiving thread
            self.subscription_active = True
            self._stop_thread = False
            self._ws_thread = threading.Thread(
                target=self._receive_thermal_data, 
                args=(callback,)
            )
            self._ws_thread.daemon = True
            self._ws_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to thermal camera: {e}")
            return False
    
    def _receive_thermal_data(self, callback):
        """Receive thermal data in separate thread"""
        while self.subscription_active and not self._stop_thread:
            try:
                response = self._ws.recv()
                data = json.loads(response)
                
                if data.get("op") == "publish" and data.get("topic") == "/thermal_frame":
                    msg = data["msg"]
                    
                    # Process the thermal frame data
                    processed = self._process_thermal_data(msg)
                    self.latest_frame = processed
                    
                    if callback:
                        callback(processed)
                        
            except Exception as e:
                if self.subscription_active:
                    logger.error(f"Error receiving thermal data: {e}")
                break
        
        if self._ws:
            self._ws.close()
        logger.info("Thermal camera subscription thread ended")
    
    def _process_thermal_data(self, frame_msg: Dict) -> Dict[str, Any]:
        """
        Process raw thermal frame data for visualization
        
        Args:
            frame_msg: Raw ThermalFrame message
            
        Returns:
            Dict with processed data including heatmap
        """
        try:
            # Extract frame data
            width = frame_msg.get("width", 32)
            height = frame_msg.get("height", 24)
            data = frame_msg.get("data", [])
            
            # Reshape to 2D array
            thermal_array = np.array(data).reshape((height, width))
            
            # Calculate temperature ranges for better visualization
            min_temp = frame_msg.get("min_temp", 20.0)
            max_temp = frame_msg.get("max_temp", 30.0)
            avg_temp = frame_msg.get("avg_temp", 25.0)
            center_temp = frame_msg.get("center_temp", 25.0)
            
            # Normalize data to 0-255 for color mapping
            if max_temp > min_temp:
                normalized = ((thermal_array - min_temp) / (max_temp - min_temp) * 255).astype(np.uint8)
            else:
                normalized = np.full((height, width), 128, dtype=np.uint8)
            
            # Find hotspots (temperatures above average + threshold)
            threshold = (max_temp - min_temp) * 0.7 + min_temp
            hotspots = []
            for y in range(height):
                for x in range(width):
                    if thermal_array[y, x] > threshold:
                        hotspots.append({
                            "x": x,
                            "y": y,
                            "temp": float(thermal_array[y, x])
                        })
            
            # Convert to list for JSON serialization
            thermal_list = thermal_array.tolist()
            normalized_list = normalized.tolist()
            
            return {
                "width": width,
                "height": height,
                "thermal_data": thermal_list,
                "normalized_data": normalized_list,
                "min_temp": min_temp,
                "max_temp": max_temp,
                "avg_temp": avg_temp,
                "center_temp": center_temp,
                "frame_count": frame_msg.get("frame_count", 0),
                "hotspots": hotspots,
                "hotspot_count": len(hotspots),
                "timestamp": time.time()
            }
            
        except Exception as e:
            logger.error(f"Error processing thermal data: {e}")
            return {
                "width": 32,
                "height": 24,
                "thermal_data": [[20.0] * 32 for _ in range(24)],
                "normalized_data": [[128] * 32 for _ in range(24)],
                "min_temp": 20.0,
                "max_temp": 30.0,
                "avg_temp": 25.0,
                "center_temp": 25.0,
                "frame_count": 0,
                "hotspots": [],
                "hotspot_count": 0,
                "timestamp": time.time()
            }
    
    def get_latest_frame(self) -> Optional[Dict[str, Any]]:
        """Get the most recent thermal frame data"""
        return self.latest_frame
    
    def get_thermal_frame_once(self) -> Optional[Dict[str, Any]]:
        """Request a single thermal frame via service call"""
        try:
            # Call the get_thermal_frame service
            success, response = self.ros_bridge.call_service(
                "/get_thermal_frame",
                {},
                "get_thermal_frame"
            )
            
            if success and response.get("values", {}).get("success"):
                frame_data = response["values"]["frame"]
                return self._process_thermal_data(frame_data)
            else:
                logger.error("Failed to get thermal frame via service")
                return None
                
        except Exception as e:
            logger.error(f"Error calling thermal frame service: {e}")
            return None
    
    def unsubscribe(self):
        """Stop subscription"""
        self.subscription_active = False
        self._stop_thread = True
        if self._ws_thread:
            self._ws_thread.join(timeout=2)
        logger.info("Unsubscribed from thermal camera topic")

# Singleton instance
_thermal_camera_sensor = None

def get_thermal_camera_sensor():
    """Get or create ThermalCameraSensor instance"""
    global _thermal_camera_sensor
    if _thermal_camera_sensor is None:
        from backend.ros_bridge import get_ros_bridge
        _thermal_camera_sensor = ThermalCameraSensor(get_ros_bridge())
    return _thermal_camera_sensor
================================================================================


================================================================================
FILE: quick_test_automation.py
Category: Python | Size: 23.1 KB | Lines: 608
================================================================================
#!/usr/bin/env python3
"""
Grid-based exploration with proper obstacle detection and motor control
"""

import sys
import time
import signal
import logging
import math
import random
import numpy as np
from pathlib import Path
from collections import deque

# Add parent directory to path for imports
sys.path.append(str(Path(__file__).parent.parent))

from backend.ros_bridge import get_ros_bridge, get_motor_controller
from backend.sensors.lidar import get_lidar_sensor

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)

# Configuration
ROBOT_IP = "192.168.124.39"
ROS_PORT = 9090

# Robot dimensions
ROBOT_WIDTH = 500  # mm
ROBOT_LENGTH = 500  # mm
SAFE_DISTANCE = 600  # mm - minimum distance to obstacles (60cm for safe turning)
CRITICAL_DISTANCE = 400  # mm - emergency stop distance (40cm)

# Speeds
TURN_SPEED = 90  # Increased for better single-wheel turning
FORWARD_SPEED = 80

# Grid mapping parameters
GRID_RESOLUTION = 50  # mm per grid cell
GRID_SIZE = 200  # 200x200 grid = 10m x 10m area
OBSTACLE_THRESHOLD = 0.7  # Probability threshold for obstacle

class GridMapper:
    """Simple occupancy grid mapper"""
    
    def __init__(self, size=GRID_SIZE, resolution=GRID_RESOLUTION):
        self.size = size
        self.resolution = resolution
        self.grid = np.ones((size, size)) * 0.5  # Initialize with unknown (0.5)
        self.robot_x = size // 2  # Start in center
        self.robot_y = size // 2
        self.robot_theta = 0
        
    def world_to_grid(self, x, y):
        """Convert world coordinates (mm) to grid indices"""
        grid_x = int(x / self.resolution) + self.size // 2
        grid_y = int(y / self.resolution) + self.size // 2
        return grid_x, grid_y
    
    def update_map(self, lidar_points, robot_x, robot_y, robot_theta):
        """Update occupancy grid with lidar data"""
        self.robot_x, self.robot_y = self.world_to_grid(robot_x, robot_y)
        self.robot_theta = robot_theta
        
        for point in lidar_points:
            r = point['r'] * 1000  # Convert to mm
            theta = point['theta'] + robot_theta
            
            # Point in world coordinates
            px = robot_x + r * math.cos(theta)
            py = robot_y + r * math.sin(theta)
            
            # Convert to grid
            gx, gy = self.world_to_grid(px, py)
            
            # Mark as obstacle if within grid bounds
            if 0 <= gx < self.size and 0 <= gy < self.size:
                self.grid[gy, gx] = min(0.9, self.grid[gy, gx] + 0.1)
            
            # Ray trace to mark free space
            self._ray_trace(self.robot_x, self.robot_y, gx, gy)
    
    def _ray_trace(self, x0, y0, x1, y1):
        """Mark cells as free along a ray"""
        dx = abs(x1 - x0)
        dy = abs(y1 - y0)
        sx = 1 if x0 < x1 else -1
        sy = 1 if y0 < y1 else -1
        err = dx - dy
        
        x, y = x0, y0
        
        while x != x1 or y != y1:
            if 0 <= x < self.size and 0 <= y < self.size:
                self.grid[y, x] = max(0.1, self.grid[y, x] - 0.05)
            
            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                x += sx
            if e2 < dx:
                err += dx
                y += sy
    
    def is_obstacle_ahead(self, distance=SAFE_DISTANCE):
        """Check if there's an obstacle ahead of the robot"""
        check_dist = int(distance / self.resolution)
        
        for d in range(1, check_dist):
            check_x = self.robot_x + int(d * math.cos(self.robot_theta))
            check_y = self.robot_y + int(d * math.sin(self.robot_theta))
            
            if 0 <= check_x < self.size and 0 <= check_y < self.size:
                if self.grid[check_y, check_x] > OBSTACLE_THRESHOLD:
                    return True, d * self.resolution
        
        return False, distance

class SmartExplorer:
    """Explorer with grid mapping and better control"""
    
    def __init__(self):
        """Initialize with grid mapper"""
        logger.info(f"Initializing - Robot IP: {ROBOT_IP}, Port: {ROS_PORT}")
        
        # ROS connection
        self.ros_bridge = get_ros_bridge(ROBOT_IP, ROS_PORT)
        if not self.ros_bridge.test_connection():
            logger.error("Failed to connect to ROS bridge!")
            sys.exit(1)
        
        logger.info("✓ Connected to ROS bridge")
        
        # Components
        self.motor_controller = get_motor_controller()
        self.lidar_sensor = get_lidar_sensor()
        self.grid_mapper = GridMapper()
        
        # Signal handler
        signal.signal(signal.SIGINT, self._signal_handler)
        
        # State
        self.running = True
        self.exploring = False
        self._last_lidar_data = None
        self._last_motor_cmd = {'left': None, 'right': None}
        self._motor_cmd_time = 0
        
        # Robot pose
        self.x = 0.0  # mm
        self.y = 0.0  # mm
        self.theta = 0.0  # radians
        
        # Calibration
        self.robot_body_points = []
        self.calibration_complete = False
        
        logger.info("✓ All components initialized")
    
    def _signal_handler(self, sig, frame):
        """Handle shutdown"""
        logger.info("\nShutdown requested...")
        self.running = False
        self.exploring = False
        self.stop()
        sys.exit(0)
    
    def calibrate_robot_body(self):
        """Quick calibration to identify robot body points"""
        logger.info("\n=== Starting robot body calibration ===")
        
        calibration_points = []
        all_scan_data = []
        
        def calibration_callback(scan_data):
            if scan_data and 'points' in scan_data:
                points = []
                for p in scan_data['points']:
                    if p['r'] < 0.6:  # Only close points (< 600mm)
                        points.append({'r': p['r'], 'theta': p['theta']})
                calibration_points.append(points)
                all_scan_data.append(scan_data)
        
        if not self.lidar_sensor.subscribe(callback=calibration_callback, processed_data=True):
            logger.error("Failed to start lidar")
            return False
        
        logger.info("Rotating for calibration...")
        time.sleep(1)
        
        # Rotate slowly using one wheel only (no counter-rotation)
        self.set_motors(85, 0)  # Left wheel forward at 85%, right wheel stopped
        time.sleep(6)  # 6 seconds for full rotation
        self.stop_motors()
        
        # Analyze data
        if len(calibration_points) > 10:
            # Find consistent points
            all_points = []
            for scan in calibration_points[5:]:  # Skip first few
                all_points.extend(scan)
            
            # Simple clustering - points that appear frequently
            self.robot_body_points = []
            for p in all_points[:20]:  # Take first 20 close points
                self.robot_body_points.append(p)
            
            # Also update grid map with scan data from calibration
            logger.info("Updating grid map with calibration data...")
            for scan_data in all_scan_data[-5:]:  # Use last few scans
                filtered_points = []
                for point in scan_data.get('points', []):
                    if not self.is_robot_body(point):
                        filtered_points.append(point)
                self.grid_mapper.update_map(filtered_points, self.x, self.y, self.theta)
        
        self.lidar_sensor.unsubscribe()
        self.calibration_complete = True
        
        logger.info(f"✓ Calibration complete! Found {len(self.robot_body_points)} body points")
        return True
    
    def is_robot_body(self, point):
        """Check if point belongs to robot"""
        r = point['r']
        theta = point['theta']
        
        # Simple check - very close points behind or to sides
        if r < 0.3:  # Less than 300mm
            if abs(theta) > 2.0:  # Behind (more than ~115 degrees)
                return True
            if 0.5 < abs(theta) < 2.5:  # Sides
                return True
        
        # Check against calibrated points if available
        if self.calibration_complete:
            for bp in self.robot_body_points:
                if abs(r - bp['r']) < 0.1 and abs(theta - bp['theta']) < 0.2:
                    return True
        
        return False
    
    def set_motors(self, left_speed, right_speed):
        """Set motor speeds with rate limiting"""
        current_time = time.time()
        
        # Rate limit motor commands (max 5Hz)
        if current_time - self._motor_cmd_time < 0.2:
            return
        
        # Only send if changed
        if (self._last_motor_cmd['left'] != left_speed or 
            self._last_motor_cmd['right'] != right_speed):
            
            if left_speed == 0:
                self.motor_controller.set_motor(0, "brake", 0)
            elif left_speed < 0:
                self.motor_controller.set_motor(0, "backward", abs(left_speed))
            else:
                direction = "forward" if left_speed > 0 else "backward"
                self.motor_controller.set_motor(0, direction, abs(left_speed))
            
            if right_speed == 0:
                self.motor_controller.set_motor(1, "brake", 0)
            elif right_speed < 0:
                self.motor_controller.set_motor(1, "backward", abs(right_speed))
            else:
                direction = "forward" if right_speed > 0 else "backward"
                self.motor_controller.set_motor(1, direction, abs(right_speed))
            
            self._last_motor_cmd = {'left': left_speed, 'right': right_speed}
            self._motor_cmd_time = current_time
    
    def stop_motors(self):
        """Stop all motors"""
        self.set_motors(0, 0)
        self.motor_controller.stop_all_motors()
    
    def process_lidar_data(self, scan_data):
        """Process lidar data and update grid map"""
        if not scan_data or 'points' not in scan_data:
            return
        
        # Filter robot body points
        filtered_points = []
        for point in scan_data['points']:
            if not self.is_robot_body(point):
                filtered_points.append(point)
        
        # Update grid map
        self.grid_mapper.update_map(filtered_points, self.x, self.y, self.theta)
        
        # Store for other uses
        self._last_lidar_data = filtered_points
        
        # Check for obstacles in different directions
        front_clear = True
        min_front = float('inf')
        
        for point in filtered_points:
            r = point['r'] * 1000  # mm
            theta = point['theta']
            
            # Front cone (±30 degrees)
            if -0.52 < theta < 0.52:
                if r < min_front:
                    min_front = r
                if r < SAFE_DISTANCE:
                    front_clear = False
        
        return front_clear, min_front
    
    def explore(self, duration=60):
        """Main exploration routine"""
        logger.info(f"\n=== Starting EXPLORATION for {duration} seconds ===")
        
        # Calibrate if needed
        if not self.calibration_complete:
            self.calibrate_robot_body()
        
        # Start lidar
        front_clear = True
        min_front_dist = float('inf')
        
        def lidar_callback(scan_data):
            nonlocal front_clear, min_front_dist
            result = self.process_lidar_data(scan_data)
            if result:
                front_clear, min_front_dist = result
        
        if not self.lidar_sensor.subscribe(callback=lidar_callback, processed_data=True):
            logger.error("Failed to start lidar")
            return
        
        logger.info("✓ Lidar started")
        time.sleep(1)  # Let lidar stabilize
        
        # Exploration state machine
        start_time = time.time()
        last_log_time = 0
        state = "forward"
        turn_start = None
        turn_count = 0  # Track consecutive turns
        stuck_count = 0  # Track if we're stuck
        self.exploring = True
        
        # Starting position for return home
        start_x, start_y = self.x, self.y
        
        # Movement tracking
        last_move_time = time.time()
        last_position_check = time.time()
        last_check_x, last_check_y = self.x, self.y
        
        while self.running and self.exploring and (time.time() - start_time) < duration:
            current_time = time.time()
            dt = current_time - last_move_time
            last_move_time = current_time
            
            # Update position estimate (simple dead reckoning)
            if state == "forward":
                self.x += FORWARD_SPEED * dt * math.cos(self.theta)
                self.y += FORWARD_SPEED * dt * math.sin(self.theta)
            elif state == "backward":
                self.x -= FORWARD_SPEED * 0.8 * dt * math.cos(self.theta)  # Slower backward
                self.y -= FORWARD_SPEED * 0.8 * dt * math.sin(self.theta)
            elif state == "turn_left":
                self.theta += 0.5 * dt  # ~0.5 rad/s (slower turning)
            elif state == "turn_right":
                self.theta -= 0.5 * dt
            elif state == "return_home":
                # Position updates handled in the state logic
                pass
            
            # Normalize angle
            self.theta = math.atan2(math.sin(self.theta), math.cos(self.theta))
            
            # Check grid map for obstacles
            grid_obstacle, grid_dist = self.grid_mapper.is_obstacle_ahead()
            
            # Check if stuck (every 10 seconds)
            if current_time - last_position_check > 10.0:
                distance_moved = math.sqrt((self.x - last_check_x)**2 + (self.y - last_check_y)**2)
                total_distance_from_start = math.sqrt((self.x - start_x)**2 + (self.y - start_y)**2)
                
                if distance_moved < 300:  # Less than 30cm in 10 seconds
                    logger.warning(f"Stuck! Only moved {int(distance_moved)}mm in 10s")
                    stuck_count += 2
                    
                    # If very stuck and far from start, try to return
                    if stuck_count > 4 and total_distance_from_start > 500:
                        logger.warning("Very stuck! Attempting to return to start...")
                        state = "return_home"
                        turn_start = current_time
                
                last_check_x, last_check_y = self.x, self.y
                last_position_check = current_time
            
            # Check minimum progress for short explorations
            if duration <= 20 and (current_time - start_time) > 15:
                total_distance = math.sqrt((self.x - start_x)**2 + (self.y - start_y)**2)
                if total_distance < 1000:  # Less than 1 meter
                    logger.warning(f"Poor progress! Only {int(total_distance)}mm from start")
                    state = "return_home"
                    turn_start = current_time
            
            # Status logging
            if current_time - last_log_time > 3.0:
                front_dist_str = "inf" if min_front_dist == float('inf') else f"{int(min_front_dist)}"
                logger.info(f"[{int(current_time - start_time)}s/{duration}s] "
                          f"State: {state} | "
                          f"Pos: ({int(self.x)}, {int(self.y)})mm, {int(math.degrees(self.theta))}° | "
                          f"Front: {front_dist_str}mm | "
                          f"Grid obstacle: {grid_obstacle} at {int(grid_dist)}mm")
                last_log_time = current_time
            
            # State machine
            if state == "forward":
                # Check both direct lidar and grid map
                if not front_clear or min_front_dist < SAFE_DISTANCE or grid_obstacle:
                    logger.warning(f"Obstacle detected! Lidar: {int(min_front_dist)}mm, "
                                 f"Grid: {grid_obstacle} at {int(grid_dist)}mm")
                    self.stop_motors()
                    time.sleep(0.3)  # Longer pause before turning
                    
                    # If very close, back up first
                    if min_front_dist < CRITICAL_DISTANCE:
                        state = "backward"
                        turn_start = current_time
                        stuck_count += 1
                        logger.warning(f"Too close ({int(min_front_dist)}mm)! Backing up...")
                    else:
                        # Choose turn direction - alternate if stuck
                        if stuck_count > 2:
                            state = "turn_right" if turn_count % 2 == 0 else "turn_left"
                        else:
                            state = "turn_left" if random.random() < 0.5 else "turn_right"
                        turn_start = current_time
                        turn_count += 1
                else:
                    self.set_motors(FORWARD_SPEED, FORWARD_SPEED)
                    turn_count = 0  # Reset turn count when moving forward
                    stuck_count = 0
            
            elif state == "backward":
                # Move backward for longer when stuck
                self.set_motors(-FORWARD_SPEED, -FORWARD_SPEED)  # Both wheels backward
                
                # Back up longer if we're really stuck
                backup_duration = 2.0 if stuck_count > 2 else 1.5
                
                if current_time - turn_start > backup_duration:
                    self.stop_motors()
                    time.sleep(0.2)
                    # After backing up, turn
                    state = "turn_right" if random.random() < 0.5 else "turn_left"
                    turn_start = current_time
                    logger.info(f"Backed up for {backup_duration}s, now turning...")
            
            elif state in ["turn_left", "turn_right"]:
                if state == "turn_left":
                    # Turn left by moving only left wheel
                    self.set_motors(TURN_SPEED, 0)
                else:
                    # Turn right by moving only right wheel
                    self.set_motors(0, TURN_SPEED)
                
                # Turn for longer if we've been stuck
                turn_duration = random.uniform(2.0, 3.0) if stuck_count > 2 else random.uniform(1.5, 2.5)
                
                if current_time - turn_start > turn_duration:
                    self.stop_motors()
                    time.sleep(0.2)
                    state = "forward"
                    logger.info("Turn complete, checking path...")
            
            elif state == "return_home":
                # Calculate angle to home
                dx = start_x - self.x
                dy = start_y - self.y
                distance_to_home = math.sqrt(dx**2 + dy**2)
                
                if distance_to_home < 200:  # Close enough to start
                    logger.info("Returned to starting area!")
                    self.stop_motors()
                    state = "forward"
                    stuck_count = 0
                    turn_count = 0
                else:
                    # Calculate desired angle
                    desired_angle = math.atan2(dy, dx)
                    angle_diff = desired_angle - self.theta
                    
                    # Normalize angle difference to [-pi, pi]
                    while angle_diff > math.pi:
                        angle_diff -= 2 * math.pi
                    while angle_diff < -math.pi:
                        angle_diff += 2 * math.pi
                    
                    # Turn towards home or move forward
                    if abs(angle_diff) > 0.3:  # Need to turn (about 17 degrees)
                        if angle_diff > 0:
                            self.set_motors(TURN_SPEED, 0)  # Turn left
                        else:
                            self.set_motors(0, TURN_SPEED)  # Turn right
                    else:
                        # Check for obstacles while returning
                        if not front_clear and min_front_dist < SAFE_DISTANCE:
                            # Obstacle while returning, try to go around
                            if random.random() < 0.5:
                                self.set_motors(TURN_SPEED, 0)
                            else:
                                self.set_motors(0, TURN_SPEED)
                        else:
                            # Move toward home
                            self.set_motors(FORWARD_SPEED, FORWARD_SPEED)
            
            time.sleep(0.05)  # 20Hz control loop
        
        # Cleanup
        self.exploring = False
        self.stop_motors()
        self.lidar_sensor.unsubscribe()
        
        logger.info(f"\n✓ Exploration completed!")
        logger.info(f"Distance traveled: ~{int(math.sqrt(self.x**2 + self.y**2))}mm from start")
        logger.info(f"Final position: ({int(self.x)}, {int(self.y)})mm")
        
        # Check if we should warn about poor exploration
        total_distance = math.sqrt((self.x - start_x)**2 + (self.y - start_y)**2)
        if total_distance < 1000 and duration >= 20:
            logger.warning("Limited exploration area covered. Consider trying a different starting position.")
    
    def stop(self):
        """Clean shutdown"""
        logger.info("Stopping all systems...")
        self.exploring = False
        
        if hasattr(self, 'motor_controller'):
            try:
                self.motor_controller.stop_all_motors()
            except:
                pass
        
        if hasattr(self, 'lidar_sensor'):
            try:
                self.lidar_sensor.unsubscribe()
            except:
                pass
        
        logger.info("✓ All systems stopped")

def main():
    """Main function"""
    print("=== Smart Grid-Based Explorer ===")
    print(f"Robot IP: {ROBOT_IP}")
    print(f"Safe distance: {SAFE_DISTANCE}mm")
    print(f"Grid resolution: {GRID_RESOLUTION}mm/cell")
    print()
    
    try:
        explorer = SmartExplorer()
    except Exception as e:
        logger.error(f"Failed to initialize: {e}")
        return
    
    while True:
        print("\n=== OPTIONS ===")
        print("1. Quick exploration (20 seconds)")
        print("2. Standard exploration (60 seconds)")
        print("3. Extended exploration (120 seconds)")
        print("0. Exit")
        
        choice = input("\nSelect option: ").strip()
        
        try:
            if choice == '0':
                break
            elif choice == '1':
                explorer.explore(20)
            elif choice == '2':
                explorer.explore(60)
            elif choice == '3':
                explorer.explore(120)
            else:
                print("Invalid option")
        
        except KeyboardInterrupt:
            logger.info("\nInterrupted by user")
        except Exception as e:
            logger.error(f"Error: {e}")
            import traceback
            traceback.print_exc()
        finally:
            explorer.stop_motors()
            time.sleep(0.5)
    
    explorer.stop()
    print("\nDemo completed!")

if __name__ == "__main__":
    main()
================================================================================


================================================================================
FILE: run.py
Category: Python | Size: 341.0 B | Lines: 16
================================================================================
#!/usr/bin/env python3
"""
Main entry point for the ROS 2 Motor Control application
Run this file to start the Flask backend server
"""

import sys
from pathlib import Path

# Add the current directory to Python path
sys.path.insert(0, str(Path(__file__).parent))

from backend.host_backend import main

if __name__ == '__main__':
    main()
================================================================================


================================================================================
FILE: frontend/templates/aiming_system.html
Category: Web | Size: 56.6 KB | Lines: 1631
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aiming System - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 40px 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .section-title {
            font-size: 2em;
            font-weight: 500;
            color: #00aaff;
            margin: 40px 0 20px 0;
            text-align: center;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin-bottom: 40px;
        }

        .servo-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 400px;
        }

        .servo-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
        }

        .servo-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .servo-title {
            font-size: 1.5em;
            font-weight: 500;
            color: #00aaff;
        }

        .servo-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            background: #333;
            color: #888;
            transition: all 0.3s ease;
        }

        .servo-status.active {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .angle-control {
            margin-top: auto;
        }

        .angle-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            color: #aaa;
        }

        .angle-value {
            font-size: 2.5em;
            font-weight: 700;
            color: #00ff88;
            min-width: 120px;
            text-align: right;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .angle-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            transition: all 0.3s ease;
        }

        /* Add tick marks for discrete positions */
        .angle-slider {
            background-image: linear-gradient(to right, 
                #444 0%, #444 1px,
                transparent 1px, transparent 20%,
                #444 20%, #444 21%,
                transparent 21%, transparent 40%,
                #444 40%, #444 41%,
                transparent 41%, transparent 60%,
                #444 60%, #444 61%,
                transparent 61%, transparent 80%,
                #444 80%, #444 81%,
                transparent 81%, transparent 99%,
                #444 99%, #444 100%
            );
            background-size: 100% 100%;
            background-repeat: no-repeat;
        }

        .angle-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .angle-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.7);
        }

        .angle-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .angle-marks {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            padding: 0 12px;
        }

        .angle-mark {
            font-size: 0.75em;
            color: #666;
            text-align: center;
            position: relative;
        }

        .preset-panel {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            text-align: center;
        }

        .preset-title {
            font-size: 1.5em;
            font-weight: 500;
            color: #00aaff;
            margin-bottom: 30px;
        }

        .preset-btn {
            padding: 15px 25px;
            margin: 8px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 120px;
        }

        .preset-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .center-btn {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            font-size: 1.2em;
            padding: 20px 40px;
            min-width: 150px;
        }

        .center-btn:hover {
            background: linear-gradient(135deg, #ff5555, #dd1111);
            box-shadow: 0 5px 20px rgba(255, 68, 68, 0.4);
        }

        .visualization-panel {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
        }

        .servo-visual {
            width: 300px;
            height: 300px;
            margin: 0 auto 20px;
            position: relative;
            background: radial-gradient(circle at center, #1a1a1a 0%, #0a0a0a 100%);
            border: 2px solid #333;
            border-radius: 15px;
            overflow: hidden;
        }

        .grid-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .safe-zone {
            position: absolute;
            border: 2px dashed #00ff88;
            border-radius: 10px;
            top: 16.67%;
            left: 16.67%;
            width: 66.66%;
            height: 66.66%;
            opacity: 0.3;
        }

        .crosshair {
            position: absolute;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }

        .crosshair::before {
            width: 100%;
            height: 2px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        .crosshair::after {
            width: 2px;
            height: 100%;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair-center {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #00ff88;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        /* Actuator Control Styles */
        .actuator-section {
            margin-top: 60px;
        }

        .actuator-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            margin-bottom: 30px;
        }

        .actuator-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .actuator-title {
            font-size: 1.8em;
            font-weight: 500;
            color: #ff6b6b;
        }

        .actuator-status {
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 1em;
            background: #333;
            color: #888;
            transition: all 0.3s ease;
        }

        .actuator-status.extending {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .actuator-status.retracting {
            background: rgba(255, 170, 0, 0.2);
            color: #ffaa00;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.3);
        }

        .actuator-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .actuator-btn {
            padding: 20px;
            border: none;
            border-radius: 15px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .actuator-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        }

        .actuator-btn.extend {
            background: linear-gradient(135deg, #00ff88, #00cc66);
        }

        .actuator-btn.extend:hover {
            box-shadow: 0 8px 20px rgba(0, 255, 136, 0.4);
        }

        .actuator-btn.retract {
            background: linear-gradient(135deg, #ffaa00, #ff8800);
        }

        .actuator-btn.retract:hover {
            box-shadow: 0 8px 20px rgba(255, 170, 0, 0.4);
        }

        .actuator-btn.stop {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .actuator-btn.stop:hover {
            box-shadow: 0 8px 20px rgba(255, 68, 68, 0.4);
        }

        .actuator-icon {
            font-size: 2em;
        }

        .speed-duration-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #252525;
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #333;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            color: #aaa;
            font-size: 1.1em;
        }

        .control-value {
            font-size: 1.5em;
            font-weight: 600;
            color: #ff6b6b;
        }

        .speed-slider, .duration-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            transition: all 0.3s ease;
        }

        .speed-slider::-webkit-slider-thumb,
        .duration-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff6b6b, #ff4444);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
            transition: all 0.3s ease;
        }

        .speed-slider::-webkit-slider-thumb:hover,
        .duration-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.7);
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
        }

        .preset-actuator-btn {
            padding: 15px 10px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            font-weight: 500;
            text-align: center;
        }

        .preset-actuator-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        /* Auto Aim Control Styles */
        .auto-aim-section {
            margin-top: 30px;
        }

        .auto-aim-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            margin-bottom: 30px;
        }

        .auto-aim-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .auto-aim-title {
            font-size: 1.8em;
            font-weight: 500;
            color: #ff6b6b;
        }

        .auto-aim-toggle {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .auto-aim-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 15px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1.1em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .auto-aim-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        }

        .auto-aim-btn.enable {
            background: linear-gradient(135deg, #00ff88, #00cc66);
        }

        .auto-aim-btn.enable:hover {
            box-shadow: 0 8px 20px rgba(0, 255, 136, 0.4);
        }

        .auto-aim-btn.disable {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .auto-aim-btn.disable:hover {
            box-shadow: 0 8px 20px rgba(255, 68, 68, 0.4);
        }

        .auto-aim-status {
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1.1em;
            background: #333;
            color: #888;
            transition: all 0.3s ease;
        }

        .auto-aim-status.active {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.3);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 10px rgba(255, 107, 107, 0.3); }
            50% { box-shadow: 0 0 20px rgba(255, 107, 107, 0.5); }
            100% { box-shadow: 0 0 10px rgba(255, 107, 107, 0.3); }
        }

        .auto-aim-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .auto-aim-info-item {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .auto-aim-info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .auto-aim-info-value {
            font-size: 1.2em;
            font-weight: 600;
            color: #ff6b6b;
        }

        .threshold-control {
            background: #252525;
            padding: 20px;
            border-radius: 15px;
            border: 1px solid #333;
            margin-top: 20px;
        }

        .threshold-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            color: #aaa;
            font-size: 1.1em;
        }

        .threshold-value {
            font-size: 1.5em;
            font-weight: 600;
            color: #ff6b6b;
        }

        .threshold-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            transition: all 0.3s ease;
        }

        .threshold-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff6b6b, #ff4444);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
            transition: all 0.3s ease;
        }

        .threshold-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.7);
        }

        .log-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            border: 1px solid #333;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            background: #252525;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #aaa;
            border-left: 3px solid #444;
        }

        .log-entry.success {
            border-left-color: #00ff88;
            color: #00ff88;
        }

        .log-entry.error {
            border-left-color: #ff4444;
            color: #ff6666;
        }

        @media (max-width: 1200px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .actuator-controls {
                grid-template-columns: 1fr;
            }
            
            .speed-duration-controls {
                grid-template-columns: 1fr;
            }
            
            .preset-buttons {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .servo-visual {
                width: 250px;
                height: 250px;
            }
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>Aiming System Control Panel</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span>Servo Connection:</span>
            <div class="status-indicator" id="servoConnectionStatus"></div>
            <span id="servoStatusText">Disconnected</span>
        </div>
        <div class="status-item" style="margin-left: 30px;">
            <span>Actuator Connection:</span>
            <div class="status-indicator" id="actuatorConnectionStatus"></div>
            <span id="actuatorStatusText">Disconnected</span>
        </div>
    </div>

    <div class="main-container">
        <!-- Servo Control Section -->
        <h2 class="section-title">Servo Aiming Control</h2>
        
        <div class="controls-grid">
            <!-- Pan Control -->
            <div class="servo-card">
                <div class="servo-header">
                    <h2 class="servo-title">Pan Control (Horizontal)</h2>
                    <span class="servo-status" id="panStatus">IDLE</span>
                </div>
                <div class="angle-control">
                    <div class="angle-label">
                        <span>Angle Control</span>
                        <span class="angle-value" id="panValue">135°</span>
                    </div>
                    <input type="range" class="angle-slider" id="panSlider" 
                           min="75" max="195" value="135" step="30">
                    <div class="angle-marks">
                        <span class="angle-mark">75°<br>Left</span>
                        <span class="angle-mark">105°</span>
                        <span class="angle-mark">135°<br>Center</span>
                        <span class="angle-mark">165°</span>
                        <span class="angle-mark">195°<br>Right</span>
                    </div>
                </div>
            </div>

            <!-- Tilt Control -->
            <div class="servo-card">
                <div class="servo-header">
                    <h2 class="servo-title">Tilt Control (Vertical)</h2>
                    <span class="servo-status" id="tiltStatus">IDLE</span>
                </div>
                <div class="angle-control">
                    <div class="angle-label">
                        <span>Angle Control</span>
                        <span class="angle-value" id="tiltValue">135°</span>
                    </div>
                    <input type="range" class="angle-slider" id="tiltSlider" 
                           min="75" max="195" value="135" step="30">
                    <div class="angle-marks">
                        <span class="angle-mark">75°<br>Down</span>
                        <span class="angle-mark">105°</span>
                        <span class="angle-mark">135°<br>Center</span>
                        <span class="angle-mark">165°</span>
                        <span class="angle-mark">195°<br>Up</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Preset Controls -->
        <div class="preset-panel">
            <h2 class="preset-title">Quick Position Presets</h2>
            <div style="margin-bottom: 20px;">
                <button class="preset-btn" onclick="moveToPreset(135, 195)">↑ UP</button>
            </div>
            <div style="margin-bottom: 20px;">
                <button class="preset-btn" onclick="moveToPreset(75, 135)">← LEFT</button>
                <button class="preset-btn center-btn" onclick="moveToCenter()">CENTER</button>
                <button class="preset-btn" onclick="moveToPreset(195, 135)">RIGHT →</button>
            </div>
            <div>
                <button class="preset-btn" onclick="moveToPreset(135, 75)">↓ DOWN</button>
            </div>
        </div>

        <!-- Visualization -->
        <div class="visualization-panel" style="margin-top: 30px;">
            <h2 class="servo-title" style="text-align: center; margin-bottom: 20px;">Position Visualization</h2>
            <div class="servo-visual">
                <div class="grid-lines"></div>
                <div class="safe-zone"></div>
                <div class="crosshair" id="crosshair" style="left: 50%; top: 50%;">
                    <div class="crosshair-center"></div>
                </div>
            </div>
        </div>

        <!-- Auto Aiming Section -->
        <div class="auto-aim-section">
            <h2 class="section-title">Automatic Heat Targeting System</h2>
            
            <div class="auto-aim-card">
                <div class="auto-aim-header">
                    <h3 class="auto-aim-title">Thermal Auto-Aim Control</h3>
                    <div class="auto-aim-toggle">
                        <span class="auto-aim-status" id="autoAimStatus">DISABLED</span>
                        <button class="auto-aim-btn enable" id="enableAutoAimBtn" onclick="toggleAutoAim(true)">
                            Enable Auto-Aim
                        </button>
                        <button class="auto-aim-btn disable" id="disableAutoAimBtn" onclick="toggleAutoAim(false)" style="display: none;">
                            Disable Auto-Aim
                        </button>
                    </div>
                </div>

                <div class="auto-aim-info">
                    <div class="auto-aim-info-item">
                        <div class="auto-aim-info-label">Current Target</div>
                        <div class="auto-aim-info-value" id="currentTarget">None</div>
                    </div>
                    <div class="auto-aim-info-item">
                        <div class="auto-aim-info-label">Target Temperature</div>
                        <div class="auto-aim-info-value" id="targetTemp">-°C</div>
                    </div>
                    <div class="auto-aim-info-item">
                        <div class="auto-aim-info-label">Target Position</div>
                        <div class="auto-aim-info-value" id="targetPosition">-</div>
                    </div>
                    <div class="auto-aim-info-item">
                        <div class="auto-aim-info-label">Last Detection</div>
                        <div class="auto-aim-info-value" id="lastDetection">Never</div>
                    </div>
                </div>

                <div class="threshold-control">
                    <div class="threshold-label">
                        <span>Temperature Threshold</span>
                        <span class="threshold-value" id="thresholdValue">100°C</span>
                    </div>
                    <input type="range" class="threshold-slider" id="thresholdSlider" 
                           min="30" max="300" value="100" step="10">
                    <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                        <span style="color: #666; font-size: 0.8em;">30°C</span>
                        <span style="color: #666; font-size: 0.8em;">300°C</span>
                    </div>
                </div>

                <p style="color: #888; font-size: 0.9em; margin-top: 20px; text-align: center;">
                    <strong>Note:</strong> Auto-aim will target the leftmost heat source above the threshold temperature.
                    Servo movement is limited to ±60° from center position for safety.
                </p>
            </div>
        </div>

        <!-- Actuator Control Section -->
        <div class="actuator-section">
            <h2 class="section-title">Fire Extinguisher Trigger Control</h2>
            
            <div class="actuator-card">
                <div class="actuator-header">
                    <h3 class="actuator-title">Linear Actuator Control</h3>
                    <span class="actuator-status" id="actuatorStatus">STOPPED</span>
                </div>

                <!-- Main Control Buttons -->
                <div class="actuator-controls">
                    <button class="actuator-btn extend" onclick="actuatorControl('extend')">
                        <span class="actuator-icon">↑</span>
                        <span>EXTEND</span>
                    </button>
                    <button class="actuator-btn stop" onclick="actuatorControl('stop')">
                        <span class="actuator-icon">■</span>
                        <span>STOP</span>
                    </button>
                    <button class="actuator-btn retract" onclick="actuatorControl('retract')">
                        <span class="actuator-icon">↓</span>
                        <span>RETRACT</span>
                    </button>
                </div>

                <!-- Speed and Duration Controls -->
                <div class="speed-duration-controls">
                    <div class="control-group">
                        <div class="control-label">
                            <span>Speed Control</span>
                            <span class="control-value" id="speedValue">100%</span>
                        </div>
                        <input type="range" class="speed-slider" id="speedSlider" 
                               min="0" max="100" value="100" step="25">
                        <div class="speed-marks">
                            <span style="float: left; color: #666; font-size: 0.8em;">0%</span>
                            <span style="float: right; color: #666; font-size: 0.8em;">100%</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <div class="control-label">
                            <span>Duration (0 = Continuous)</span>
                            <span class="control-value" id="durationValue">0s</span>
                        </div>
                        <input type="range" class="duration-slider" id="durationSlider" 
                               min="0" max="10" value="0" step="0.5">
                        <div class="speed-marks">
                            <span style="float: left; color: #666; font-size: 0.8em;">0s</span>
                            <span style="float: right; color: #666; font-size: 0.8em;">10s</span>
                        </div>
                    </div>
                </div>

                <!-- Preset Buttons -->
                <div class="preset-panel" style="margin-top: 20px;">
                    <h3 style="color: #ff6b6b; margin-bottom: 15px;">Quick Presets</h3>
                    <div class="preset-buttons">
                        <button class="preset-actuator-btn" onclick="actuatorPreset('extend', 100, 1)">
                            Extend 1s
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('extend', 100, 3)">
                            Extend 3s
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('retract', 100, 1)">
                            Retract 1s
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('retract', 100, 3)">
                            Retract 3s
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('extend', 50, 0)">
                            Slow Extend
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('retract', 50, 0)">
                            Slow Retract
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('extend', 100, 5)">
                            Full Deploy
                        </button>
                        <button class="preset-actuator-btn" onclick="actuatorPreset('retract', 100, 5)">
                            Full Retract
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <h3 style="margin-bottom: 10px; color: #888;">Activity Log</h3>
            <div id="logContainer"></div>
        </div>
    </div>

    <script>
        let socket = null;
        let isConnected = false;
        let isUpdatingFromServer = false;
        let currentPanValue = 135;
        let currentTiltValue = 135;
        let actuatorState = 'stopped';

        // Auto-aim state
        let autoAimEnabled = false;
        let autoAimStatusInterval = null;

        // Add log entry
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // Keep only last 10 entries
            while (logContainer.children.length > 10) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Initialize Socket.IO connection
        function connectWebSocket() {
            socket = io();

            socket.on('connect', function() {
                console.log('Socket.IO connected');
                isConnected = true;
                
                // Check both connections
                checkActuatorConnection().then(actuatorConnected => {
                    updateConnectionStatus(true, actuatorConnected);
                });
                
                addLog('Connected to servo controller', 'success');
                
                // Request initial servo state
                socket.emit('request_servo_state');
            });

            socket.on('servo_state', function(data) {
                updateServoState(data);
            });

            socket.on('servo_response', function(data) {
                console.log('Servo response:', data);
                if (data.result && !data.result.success) {
                    addLog(`Error: ${data.result.error}`, 'error');
                }
            });

            socket.on('servo_error', function(data) {
                console.error('Servo error:', data);
                addLog(`Error: ${data.error}`, 'error');
            });

            socket.on('disconnect', function() {
                console.log('Socket.IO disconnected');
                isConnected = false;
                updateConnectionStatus(false, false);
                addLog('Connection lost - Reconnecting...', 'error');
            });

            socket.on('connect_error', function(error) {
                console.error('Socket.IO connection error:', error);
                updateConnectionStatus(false, false);
            });
        }

        // Update connection status display
        function updateConnectionStatus(servoConnected, actuatorConnected) {
            const servoIndicator = document.getElementById('servoConnectionStatus');
            const servoText = document.getElementById('servoStatusText');
            const actuatorIndicator = document.getElementById('actuatorConnectionStatus');
            const actuatorText = document.getElementById('actuatorStatusText');
            
            if (servoConnected) {
                servoIndicator.classList.add('connected');
                servoText.textContent = 'Connected';
            } else {
                servoIndicator.classList.remove('connected');
                servoText.textContent = 'Disconnected';
            }
            
            if (actuatorConnected) {
                actuatorIndicator.classList.add('connected');
                actuatorText.textContent = 'Connected';
            } else {
                actuatorIndicator.classList.remove('connected');
                actuatorText.textContent = 'Disconnected';
            }
        }
        
        // Check actuator connection status
        async function checkActuatorConnection() {
            try {
                const response = await fetch('/api/actuator/status');
                const data = await response.json();
                
                if (data.success && data.state) {
                    return data.state.connected;
                }
                return false;
            } catch (error) {
                console.error('Failed to check actuator status:', error);
                return false;
            }
        }

        // Update servo state from WebSocket data
        function updateServoState(data) {
            isUpdatingFromServer = true;
            
            // Store current values
            currentPanValue = Math.round(data.pan_angle);
            currentTiltValue = Math.round(data.tilt_angle);
            
            // Update displays
            document.getElementById('panValue').textContent = `${currentPanValue}°`;
            document.getElementById('tiltValue').textContent = `${currentTiltValue}°`;
            
            // Update status
            const panStatus = document.getElementById('panStatus');
            const tiltStatus = document.getElementById('tiltStatus');
            
            if (data.pan_moving) {
                panStatus.textContent = 'MOVING';
                panStatus.classList.add('active');
            } else {
                panStatus.textContent = 'IDLE';
                panStatus.classList.remove('active');
            }
            
            if (data.tilt_moving) {
                tiltStatus.textContent = 'MOVING';
                tiltStatus.classList.add('active');
            } else {
                tiltStatus.textContent = 'IDLE';
                tiltStatus.classList.remove('active');
            }
            
            // Update sliders only if not being manipulated by user
            const panSlider = document.getElementById('panSlider');
            const tiltSlider = document.getElementById('tiltSlider');
            
            if (!panSlider.matches(':active') && !panSlider.matches(':focus')) {
                panSlider.value = currentPanValue;
                updateSliderBackground('panSlider', currentPanValue);
            }
            
            if (!tiltSlider.matches(':active') && !tiltSlider.matches(':focus')) {
                tiltSlider.value = currentTiltValue;
                updateSliderBackground('tiltSlider', currentTiltValue);
            }
            
            // Update visualization
            updateCrosshair(currentPanValue, currentTiltValue);
            
            isUpdatingFromServer = false;
        }

        // Update slider background
        function updateSliderBackground(sliderId, value) {
            const slider = document.getElementById(sliderId);
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const percentage = ((value - min) / (max - min)) * 100;
            slider.style.background = `linear-gradient(to right, #00ff88 ${percentage}%, #2a2a2a ${percentage}%)`;
        }

        // Update crosshair position
        function updateCrosshair(pan, tilt) {
            const crosshair = document.getElementById('crosshair');
            
            // Map angles to percentages (75-195 degrees to 0-100%)
            const panPercent = ((pan - 75) / 120) * 100;
            const tiltPercent = 100 - ((tilt - 75) / 120) * 100; // Invert for visual
            
            crosshair.style.left = `${panPercent}%`;
            crosshair.style.top = `${tiltPercent}%`;
        }

        // Send servo command
        function sendServoCommand(pan, tilt) {
            if (!isConnected || !socket || isUpdatingFromServer) return;
            
            socket.emit('servo_command', {
                type: 'servo_command',
                action: 'move',
                pan_angle: parseFloat(pan),
                tilt_angle: parseFloat(tilt)
            });
            
            addLog(`Command sent: Pan ${pan}°, Tilt ${tilt}°`, 'success');
        }

        // Preset movements
        function moveToPreset(pan, tilt) {
            document.getElementById('panSlider').value = pan;
            document.getElementById('tiltSlider').value = tilt;
            updateSliderBackground('panSlider', pan);
            updateSliderBackground('tiltSlider', tilt);
            sendServoCommand(pan, tilt);
        }

        function moveToCenter() {
            moveToPreset(135, 135);
        }

        // Auto-aim functions
        async function toggleAutoAim(enable) {
            try {
                const endpoint = enable ? '/api/aiming/auto/enable' : '/api/aiming/auto/disable';
                const response = await fetch(endpoint, { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    autoAimEnabled = enable;
                    updateAutoAimUI(enable);
                    addLog(enable ? 'Auto-aim enabled' : 'Auto-aim disabled', 'success');
                    
                    if (enable) {
                        // Start status polling
                        startAutoAimStatusPolling();
                    } else {
                        // Stop status polling
                        stopAutoAimStatusPolling();
                        clearAutoAimStatus();
                    }
                } else {
                    addLog(`Auto-aim error: ${data.error}`, 'error');
                }
            } catch (error) {
                addLog(`Failed to toggle auto-aim: ${error.message}`, 'error');
            }
        }

        // Update auto-aim UI
        function updateAutoAimUI(enabled) {
            const status = document.getElementById('autoAimStatus');
            const enableBtn = document.getElementById('enableAutoAimBtn');
            const disableBtn = document.getElementById('disableAutoAimBtn');
            
            if (enabled) {
                status.textContent = 'ACTIVE';
                status.classList.add('active');
                enableBtn.style.display = 'none';
                disableBtn.style.display = 'block';
            } else {
                status.textContent = 'DISABLED';
                status.classList.remove('active');
                enableBtn.style.display = 'block';
                disableBtn.style.display = 'none';
            }
        }

        // Start polling for auto-aim status
        function startAutoAimStatusPolling() {
            // Clear any existing interval
            stopAutoAimStatusPolling();
            
            // Update immediately
            updateAutoAimStatus();
            
            // Poll every 500ms
            autoAimStatusInterval = setInterval(updateAutoAimStatus, 500);
        }

        // Stop polling
        function stopAutoAimStatusPolling() {
            if (autoAimStatusInterval) {
                clearInterval(autoAimStatusInterval);
                autoAimStatusInterval = null;
            }
        }

        // Update auto-aim status
        async function updateAutoAimStatus() {
            try {
                const response = await fetch('/api/aiming/auto/status');
                const data = await response.json();
                
                if (data.success && data.status) {
                    const status = data.status;
                    
                    // Update target info
                    if (status.current_target) {
                        document.getElementById('currentTarget').textContent = 'Locked';
                        document.getElementById('targetTemp').textContent = `${status.current_target.temperature.toFixed(1)}°C`;
                        document.getElementById('targetPosition').textContent = 
                            `(${status.current_target.x}, ${status.current_target.y})`;
                    } else {
                        document.getElementById('currentTarget').textContent = 'Searching...';
                        document.getElementById('targetTemp').textContent = '-°C';
                        document.getElementById('targetPosition').textContent = '-';
                    }
                    
                    // Update last detection time
                    if (status.last_target_time) {
                        const time = new Date(status.last_target_time);
                        document.getElementById('lastDetection').textContent = time.toLocaleTimeString();
                    }
                    
                    // If not enabled but UI shows enabled, update UI
                    if (!status.enabled && autoAimEnabled) {
                        autoAimEnabled = false;
                        updateAutoAimUI(false);
                        stopAutoAimStatusPolling();
                    }
                }
            } catch (error) {
                console.error('Failed to update auto-aim status:', error);
            }
        }

        // Clear auto-aim status display
        function clearAutoAimStatus() {
            document.getElementById('currentTarget').textContent = 'None';
            document.getElementById('targetTemp').textContent = '-°C';
            document.getElementById('targetPosition').textContent = '-';
            document.getElementById('lastDetection').textContent = 'Never';
        }

        // Update threshold display
        function updateThresholdDisplay() {
            const value = document.getElementById('thresholdSlider').value;
            document.getElementById('thresholdValue').textContent = `${value}°C`;
            
            // Update slider background
            const slider = document.getElementById('thresholdSlider');
            const percentage = (value - 30) / (300 - 30);
            slider.style.background = `linear-gradient(to right, #ff6b6b ${percentage * 100}%, #2a2a2a ${percentage * 100}%)`;
        }

        // Set temperature threshold
        async function setThreshold(threshold) {
            try {
                const response = await fetch('/api/aiming/auto/threshold', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ threshold: parseFloat(threshold) })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    addLog(`Temperature threshold set to ${threshold}°C`, 'success');
                } else {
                    addLog(`Failed to set threshold: ${data.error}`, 'error');
                }
            } catch (error) {
                addLog(`Error setting threshold: ${error.message}`, 'error');
            }
        }

        // Actuator Control Functions
        async function actuatorControl(action) {
            const speed = parseInt(document.getElementById('speedSlider').value);
            const duration = parseFloat(document.getElementById('durationSlider').value);
            
            try {
                const response = await fetch('/api/actuator/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: action,
                        speed: speed,
                        duration: duration
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    updateActuatorStatus(action);
                    addLog(data.message, 'success');
                    
                    // Check actuator connection after command
                    checkActuatorConnection().then(connected => {
                        const servoConnected = isConnected;
                        updateConnectionStatus(servoConnected, connected);
                    });
                } else {
                    addLog(`Actuator error: ${data.error}`, 'error');
                    // Update connection status on error
                    updateConnectionStatus(isConnected, false);
                }
            } catch (error) {
                addLog(`Failed to control actuator: ${error.message}`, 'error');
            }
        }

        async function actuatorPreset(action, speed, duration) {
            // Update sliders
            document.getElementById('speedSlider').value = speed;
            document.getElementById('durationSlider').value = duration;
            updateSpeedDisplay();
            updateDurationDisplay();
            
            // Send command
            try {
                const response = await fetch('/api/actuator/control', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: action,
                        speed: speed,
                        duration: duration
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    updateActuatorStatus(action);
                    addLog(data.message, 'success');
                } else {
                    addLog(`Actuator error: ${data.error}`, 'error');
                }
            } catch (error) {
                addLog(`Failed to control actuator: ${error.message}`, 'error');
            }
        }

        function updateActuatorStatus(action) {
            const status = document.getElementById('actuatorStatus');
            actuatorState = action;
            
            // Remove all status classes
            status.classList.remove('extending', 'retracting');
            
            switch(action) {
                case 'extend':
                    status.textContent = 'EXTENDING';
                    status.classList.add('extending');
                    break;
                case 'retract':
                    status.textContent = 'RETRACTING';
                    status.classList.add('retracting');
                    break;
                case 'stop':
                default:
                    status.textContent = 'STOPPED';
                    break;
            }
        }

        function updateSpeedDisplay() {
            const value = document.getElementById('speedSlider').value;
            document.getElementById('speedValue').textContent = `${value}%`;
            
            // Update slider background
            const slider = document.getElementById('speedSlider');
            const percentage = value / 100;
            slider.style.background = `linear-gradient(to right, #ff6b6b ${percentage * 100}%, #2a2a2a ${percentage * 100}%)`;
        }

        function updateDurationDisplay() {
            const value = document.getElementById('durationSlider').value;
            document.getElementById('durationValue').textContent = value == 0 ? 'Continuous' : `${value}s`;
            
            // Update slider background
            const slider = document.getElementById('durationSlider');
            const percentage = value / 10;
            slider.style.background = `linear-gradient(to right, #ff6b6b ${percentage * 100}%, #2a2a2a ${percentage * 100}%)`;
        }

        // Check auto-aim status on page load
        async function checkAutoAimStatus() {
            try {
                const response = await fetch('/api/aiming/auto/status');
                const data = await response.json();
                
                if (data.success && data.status) {
                    autoAimEnabled = data.status.enabled;
                    updateAutoAimUI(autoAimEnabled);
                    
                    if (autoAimEnabled) {
                        startAutoAimStatusPolling();
                    }
                    
                    // Set threshold slider to current value
                    document.getElementById('thresholdSlider').value = data.status.target_threshold;
                    updateThresholdDisplay();
                }
            } catch (error) {
                console.error('Failed to check auto-aim status:', error);
            }
        }

        // Slider event handlers - keep track of values independently
        document.getElementById('panSlider').addEventListener('input', function(e) {
            if (isUpdatingFromServer) return;
            const value = parseInt(e.target.value);
            document.getElementById('panValue').textContent = `${value}°`;
            updateSliderBackground('panSlider', value);
        });

        document.getElementById('panSlider').addEventListener('change', function(e) {
            if (isUpdatingFromServer) return;
            const panValue = parseInt(e.target.value);
            // Use the current tilt value from state, not from the slider
            sendServoCommand(panValue, currentTiltValue);
        });

        document.getElementById('tiltSlider').addEventListener('input', function(e) {
            if (isUpdatingFromServer) return;
            const value = parseInt(e.target.value);
            document.getElementById('tiltValue').textContent = `${value}°`;
            updateSliderBackground('tiltSlider', value);
        });

        document.getElementById('tiltSlider').addEventListener('change', function(e) {
            if (isUpdatingFromServer) return;
            const tiltValue = parseInt(e.target.value);
            // Use the current pan value from state, not from the slider
            sendServoCommand(currentPanValue, tiltValue);
        });

        // Actuator slider handlers
        document.getElementById('speedSlider').addEventListener('input', updateSpeedDisplay);
        document.getElementById('durationSlider').addEventListener('input', updateDurationDisplay);

        // Initialize threshold slider
        document.getElementById('thresholdSlider').addEventListener('input', updateThresholdDisplay);
        document.getElementById('thresholdSlider').addEventListener('change', function(e) {
            setThreshold(e.target.value);
        });

        // Initialize on page load
        window.addEventListener('load', function() {
            connectWebSocket();
            updateSliderBackground('panSlider', 135);
            updateSliderBackground('tiltSlider', 135);
            updateSpeedDisplay();
            updateDurationDisplay();
            updateThresholdDisplay();
            addLog('Aiming system initialized', 'success');
            
            // Request initial state after a short delay
            setTimeout(() => {
                if (socket && isConnected) {
                    socket.emit('request_servo_state');
                }
                
                // Check actuator connection
                checkActuatorConnection().then(actuatorConnected => {
                    updateConnectionStatus(isConnected, actuatorConnected);
                    if (!actuatorConnected) {
                        addLog('Actuator service not available - Check if actuator_controller is running', 'error');
                    }
                });
                
                // Check auto-aim status
                checkAutoAimStatus();
            }, 500);
            
            // Periodically check actuator connection
            setInterval(() => {
                checkActuatorConnection().then(actuatorConnected => {
                    updateConnectionStatus(isConnected, actuatorConnected);
                });
            }, 5000);
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            stopAutoAimStatusPolling();
            if (socket) {
                socket.disconnect();
            }
        });
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/dashboard_home.html
Category: Web | Size: 27.7 KB | Lines: 827
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Fighting Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 30px;
            text-align: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 3em;
            font-weight: 300;
            letter-spacing: 3px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: gradient 3s ease infinite;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .subtitle {
            color: #888;
            font-size: 1.2em;
            font-weight: 300;
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 60px 20px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .components-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 40px;
            margin-bottom: 60px;
        }

        .component-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .component-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.05) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .component-card:hover::before {
            opacity: 1;
        }

        .component-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7);
            border-color: #555;
        }

        .component-icon {
            font-size: 4em;
            margin-bottom: 20px;
            display: block;
            text-align: center;
        }

        .motor-icon {
            background: linear-gradient(45deg, #00aaff, #0088cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .lidar-icon {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .camera-icon {
            background: linear-gradient(45deg, #ff6b6b, #ff4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .aiming-icon {
            background: linear-gradient(45deg, #ff00ff, #aa00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .sensor-icon {
            background: linear-gradient(45deg, #ffd93d, #ffb300);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .component-title {
            font-size: 2em;
            font-weight: 500;
            margin-bottom: 15px;
            text-align: center;
        }

        .component-description {
            color: #aaa;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .component-status {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .component-status.active {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .component-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .component-card.disabled:hover {
            transform: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .info-section {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 30px;
            margin-top: 40px;
            border: 1px solid #333;
        }

        .info-title {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #00aaff;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .info-item {
            padding: 15px;
            background: #252525;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.2em;
            font-weight: 500;
        }

        .header-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .settings-btn {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        .settings-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: #1a1a1a;
            margin: 10% auto;
            padding: 30px;
            border: 1px solid #333;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .modal-title {
            font-size: 1.8em;
            color: #00aaff;
        }

        .close-btn {
            font-size: 2em;
            color: #888;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-btn:hover {
            color: #fff;
        }

        .settings-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-label {
            color: #aaa;
            font-size: 1.1em;
        }

        .form-input {
            padding: 12px;
            background: #252525;
            border: 1px solid #444;
            border-radius: 8px;
            color: #fff;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #00aaff;
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.3);
        }

        .form-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .btn-secondary {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
        }

        .btn-secondary:hover {
            background: #3a3a3a;
        }

        .connection-info {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid #333;
        }

        .connection-info p {
            margin: 5px 0;
            color: #888;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .components-grid {
                grid-template-columns: 1fr;
            }
            
            .component-icon {
                font-size: 3em;
            }
            
            .modal-content {
                margin: 20% auto;
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Fire Fighting Robot</h1>
        <p class="subtitle">Control & Monitoring Dashboard</p>
        <div class="status-bar">
            <div class="header-controls">
                <div class="status-item">
                    <span>ROS Bridge:</span>
                    <div class="status-indicator" id="rosStatus"></div>
                    <span id="rosStatusText">Disconnected</span>
                </div>
                <button class="settings-btn" onclick="openSettings()">⚙️ Connection Settings</button>
            </div>
            <div class="status-item">
                <span>System:</span>
                <div class="status-indicator connected"></div>
                <span>Online</span>
            </div>
        </div>
    </div>

    <!-- Connection Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Connection Settings</h2>
                <span class="close-btn" onclick="closeSettings()">&times;</span>
            </div>
            <form class="settings-form" onsubmit="saveSettings(event)">
                <div class="form-group">
                    <label class="form-label">Robot IP Address</label>
                    <input type="text" 
                           id="robotIP" 
                           class="form-input" 
                           placeholder="192.168.x.x" 
                           pattern="^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
                           required>
                </div>
                <div class="form-group">
                    <label class="form-label">ROS Bridge Port</label>
                    <input type="number" 
                           id="bridgePort" 
                           class="form-input" 
                           placeholder="9090" 
                           min="1" 
                           max="65535"
                           required>
                </div>
                <div class="connection-info">
                    <p>Current Connection: <span id="currentConnection">Not configured</span></p>
                    <p>Last Connected: <span id="lastConnected">Never</span></p>
                </div>
                <div class="form-buttons">
                    <button type="submit" class="btn btn-primary">Connect</button>
                    <button type="button" class="btn btn-secondary" onclick="closeSettings()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <div class="main-container">
        <div class="components-grid">
            <!-- Motor Control -->
            <div class="component-card" onclick="navigateTo('/motors')">
                <span class="component-icon motor-icon">⚙️</span>
                <h2 class="component-title">Motor Control</h2>
                <p class="component-description">
                    Control all 4 motors independently with forward, backward, and brake modes. 
                    Real-time speed adjustment and emergency stop.
                </p>
                <div class="component-status active">
                    <div class="status-indicator connected"></div>
                    <span>2 Motor Channels Ready</span>
                </div>
            </div>

            <!-- Aiming System -->
            <div class="component-card" onclick="navigateTo('/aiming')">
                <span class="component-icon aiming-icon">🎯</span>
                <h2 class="component-title">Aiming System</h2>
                <p class="component-description">
                    Precision pan/tilt control for targeting system. 
                    Real-time servo positioning with visual feedback.
                </p>
                <div class="component-status" id="aimingStatus">
                    <div class="status-indicator"></div>
                    <span>Click to Activate</span>
                </div>
            </div>

            <!-- Lidar Sensor -->
            <div class="component-card" onclick="navigateTo('/lidar')">
                <span class="component-icon lidar-icon">📡</span>
                <h2 class="component-title">Lidar Sensor</h2>
                <p class="component-description">
                    Real-time 360° environment scanning and obstacle detection. 
                    Visualize surroundings and safe navigation paths.
                </p>
                <div class="component-status" id="lidarStatus">
                    <div class="status-indicator"></div>
                    <span>Click to Activate</span>
                </div>
            </div>

            <!-- Thermal Camera -->
            <div class="component-card" onclick="navigateTo('/thermal')">
                <span class="component-icon camera-icon">🌡️</span>
                <h2 class="component-title">Thermal Camera</h2>
                <p class="component-description">
                    MLX90640 thermal imaging with real-time heatmap visualization. 
                    Monitor temperatures and detect heat signatures.
                </p>
                <div class="component-status" id="thermalStatus">
                    <div class="status-indicator"></div>
                    <span>Click to Activate</span>
                </div>
            </div>

            <!-- Sensors (Future) -->
            <div class="component-card disabled">
                <span class="component-icon sensor-icon">🔥</span>
                <h2 class="component-title">Fire Sensors</h2>
                <p class="component-description">
                    Smoke, flame, and gas sensors for comprehensive fire detection. 
                    Coming soon...
                </p>
                <div class="component-status">
                    <div class="status-indicator"></div>
                    <span>Not Available</span>
                </div>
            </div>
        </div>

        <div class="info-section">
            <h3 class="info-title">System Information</h3>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Robot IP</div>
                    <div class="info-value" id="robotIPInfo">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">ROS Bridge Port</div>
                    <div class="info-value" id="bridgePortInfo">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Active Components</div>
                    <div class="info-value" id="activeComponents">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">System Uptime</div>
                    <div class="info-value" id="uptime">00:00:00</div>
                </div>
                <div class="info-item">
                    <div class="info-label">CPU Usage</div>
                    <div class="info-value" id="cpuUsage">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Memory Usage</div>
                    <div class="info-value" id="memoryUsage">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">CPU Temperature</div>
                    <div class="info-value" id="cpuTemp">-</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Disk Usage</div>
                    <div class="info-value" id="diskUsage">-</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Navigation function
        function navigateTo(path) {
            window.location.href = path;
        }

        // Connection settings management
        let connectionSettings = {
            robotIP: localStorage.getItem('robotIP') || '192.168.2.1',
            bridgePort: localStorage.getItem('bridgePort') || '9090'
        };

        // Initialize settings on page load
        function initializeSettings() {
            document.getElementById('robotIP').value = connectionSettings.robotIP;
            document.getElementById('bridgePort').value = connectionSettings.bridgePort;
            updateConnectionInfo();
        }

        // Open settings modal
        function openSettings() {
            document.getElementById('settingsModal').style.display = 'block';
            initializeSettings();
        }

        // Close settings modal
        function closeSettings() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        // Save settings and update connection
        async function saveSettings(event) {
            event.preventDefault();
            
            const newIP = document.getElementById('robotIP').value;
            const newPort = document.getElementById('bridgePort').value;
            
            // Save to localStorage
            localStorage.setItem('robotIP', newIP);
            localStorage.setItem('bridgePort', newPort);
            localStorage.setItem('lastConnectAttempt', new Date().toLocaleString());
            
            // Update backend configuration
            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        robot_ip: newIP,
                        rosbridge_port: parseInt(newPort)
                    })
                });
                
                if (response.ok) {
                    connectionSettings.robotIP = newIP;
                    connectionSettings.bridgePort = newPort;
                    
                    // Test the new connection
                    await checkSystemStatus();
                    
                    // Close modal and show success
                    closeSettings();
                    updateConnectionInfo();
                    
                    // Inform user that pages need to be refreshed
                    if (confirm('Connection settings updated. Refresh all open dashboard pages to apply changes?')) {
                        window.location.reload();
                    }
                } else {
                    alert('Failed to update connection settings');
                }
            } catch (error) {
                alert('Error updating settings: ' + error.message);
            }
        }

        // Update connection info display
        function updateConnectionInfo() {
            const currentConn = document.getElementById('currentConnection');
            const lastConn = document.getElementById('lastConnected');
            
            currentConn.textContent = `${connectionSettings.robotIP}:${connectionSettings.bridgePort}`;
            lastConn.textContent = localStorage.getItem('lastConnectAttempt') || 'Never';
        }

        // Check system status with current settings
        async function checkSystemStatus() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                
                // Update ROS connection status
                const rosIndicator = document.getElementById('rosStatus');
                const rosStatusText = document.getElementById('rosStatusText');
                
                if (data.connected) {
                    rosIndicator.classList.add('connected');
                    rosStatusText.textContent = 'Connected';
                    localStorage.setItem('lastSuccessfulConnection', new Date().toLocaleString());
                } else {
                    rosIndicator.classList.remove('connected');
                    rosStatusText.textContent = 'Disconnected';
                }
                
                // Update system info
                if (data.config) {
                    document.getElementById('robotIPInfo').textContent = data.config.robot_ip;
                    document.getElementById('bridgePortInfo').textContent = data.config.rosbridge_port;
                }
                
                // Update component status
                let activeCount = 0;
                if (data.components) {
                    if (data.components.motors) activeCount++;
                    
                    if (data.components.servo) {
                        activeCount++;
                        const aimingStatus = document.getElementById('aimingStatus');
                        aimingStatus.classList.add('active');
                        aimingStatus.innerHTML = '<div class="status-indicator connected"></div><span>Active</span>';
                    }
                    
                    if (data.components.lidar) {
                        activeCount++;
                        const lidarStatus = document.getElementById('lidarStatus');
                        lidarStatus.classList.add('active');
                        lidarStatus.innerHTML = '<div class="status-indicator connected"></div><span>Active</span>';
                    }
                    
                    if (data.components.thermal) {
                        activeCount++;
                        const thermalStatus = document.getElementById('thermalStatus');
                        thermalStatus.classList.add('active');
                        thermalStatus.innerHTML = '<div class="status-indicator connected"></div><span>Active</span>';
                    }
                }
                document.getElementById('activeComponents').textContent = activeCount;
                
            } catch (error) {
                console.error('Error checking status:', error);
                // If the backend isn't responding, show disconnected
                const rosIndicator = document.getElementById('rosStatus');
                const rosStatusText = document.getElementById('rosStatusText');
                rosIndicator.classList.remove('connected');
                rosStatusText.textContent = 'Error';
            }
        }

        // Subscribe to system monitor on load
        async function subscribeSystemMonitor() {
            try {
                const response = await fetch('/api/system/subscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    console.log('System monitor subscription started');
                    // Get initial status
                    updateSystemInfo();
                }
            } catch (error) {
                console.error('Failed to subscribe to system monitor:', error);
            }
        }

        // Update system info from monitor
        async function updateSystemInfo() {
            try {
                const response = await fetch('/api/system/status');
                const data = await response.json();
                
                if (data.data) {
                    document.getElementById('cpuUsage').textContent = data.data.cpu_percent || '-';
                    document.getElementById('memoryUsage').textContent = data.data.memory_percent || '-';
                    document.getElementById('cpuTemp').textContent = data.data.temp_celsius || '-';
                    document.getElementById('diskUsage').textContent = data.data.disk_percent || '-';
                }
            } catch (error) {
                console.error('Error fetching system info:', error);
            }
        }

        // Update uptime
        let startTime = Date.now();
        function updateUptime() {
            const elapsed = Date.now() - startTime;
            const hours = Math.floor(elapsed / 3600000);
            const minutes = Math.floor((elapsed % 3600000) / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            
            document.getElementById('uptime').textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('settingsModal');
            if (event.target == modal) {
                closeSettings();
            }
        }

        // Initialize on page load
        window.onload = function() {
            // Check if this is first time or if settings are missing
            if (!localStorage.getItem('robotIP')) {
                openSettings();
            }
            
            checkSystemStatus();
            subscribeSystemMonitor();
            setInterval(checkSystemStatus, 5000);
            setInterval(updateSystemInfo, 2000); // Update system info every 2 seconds
            setInterval(updateUptime, 1000);
        }
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/lidar_visualization.html
Category: Web | Size: 47.8 KB | Lines: 1336
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lidar Sensor - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-height: calc(100vh - 200px);
        }

        .visualization-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 1.5em;
            color: #00ff88;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #0a0a0a;
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .control-button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .control-button.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }

        .control-button.danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .control-button.mapping {
            background: linear-gradient(135deg, #ff00ff, #aa00ff);
        }

        .control-button.mapping.active {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 5px 20px rgba(255, 0, 255, 0.4); }
            50% { box-shadow: 0 5px 30px rgba(255, 0, 255, 0.6); }
            100% { box-shadow: 0 5px 20px rgba(255, 0, 255, 0.4); }
        }

        .info-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-item {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.3em;
            font-weight: 500;
            color: #00ff88;
        }

        .movement-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 200px;
            margin: 20px auto;
        }

        .move-btn {
            padding: 15px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-size: 1.5em;
            transition: all 0.2s ease;
        }

        .move-btn:hover {
            background: #3a3a3a;
            transform: scale(1.1);
        }

        .move-btn:active {
            background: #00ff88;
            transform: scale(0.95);
        }

        .move-btn:nth-child(2) { grid-column: 2; }
        .move-btn:nth-child(4) { grid-column: 1; }
        .move-btn:nth-child(5) { grid-column: 2; }
        .move-btn:nth-child(6) { grid-column: 3; }

        .mapping-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
            display: none;
        }

        .mapping-panel.active {
            display: block;
            border-color: #ff00ff;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.2);
        }

        .mapping-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .mapping-stat {
            background: #252525;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #444;
        }

        .mapping-stat-label {
            color: #ff00ff;
            font-size: 0.8em;
            margin-bottom: 5px;
        }

        .mapping-stat-value {
            color: #fff;
            font-size: 1.2em;
            font-weight: 600;
        }

        .clearance-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
        }

        .clearance-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 15px;
        }

        .clearance-item {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #444;
        }

        .clearance-label {
            color: #aaa;
            font-size: 0.9em;
            margin-bottom: 10px;
            display: block;
        }

        .clearance-input {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #666;
            border-radius: 5px;
            color: #fff;
            font-size: 1.1em;
            text-align: center;
        }

        .clearance-input:focus {
            outline: none;
            border-color: #ff00ff;
            box-shadow: 0 0 5px rgba(255, 0, 255, 0.3);
        }

        .clearance-unit {
            color: #888;
            font-size: 0.8em;
            margin-top: 5px;
            text-align: center;
        }

        .clearance-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .clearance-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .clearance-btn:hover {
            background: #3a3a3a;
        }

        .clearance-btn.apply {
            background: linear-gradient(135deg, #ff00ff, #aa00ff);
        }

        .clearance-btn.apply:hover {
            box-shadow: 0 5px 20px rgba(255, 0, 255, 0.4);
        }

        .background-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
        }

        .background-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .calibrate-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #ffaa00, #ff8800);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            text-transform: uppercase;
        }

        .calibrate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 170, 0, 0.4);
        }

        .calibrate-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #ff00ff;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>Lidar Sensor Visualization</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span>Lidar Status:</span>
            <div class="status-indicator" id="lidarStatus"></div>
            <span id="lidarStatusText">Disconnected</span>
        </div>
        <div class="status-item">
            <span>Data Rate:</span>
            <span id="dataRate">0 Hz</span>
        </div>
        <div class="status-item">
            <span>Points:</span>
            <span id="pointCount">0</span>
        </div>
        <div class="status-item" id="mappingIndicator" style="display: none;">
            <span>Auto Mapping:</span>
            <div class="status-indicator connected"></div>
            <span>ACTIVE</span>
        </div>
    </div>

    <div class="main-container">
        <!-- Polar View -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Live Scan - Polar View</h2>
                <span id="polarFPS">0 FPS</span>
            </div>
            <div class="canvas-container">
                <canvas id="polarCanvas"></canvas>
            </div>
        </div>

        <!-- Occupancy Map -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Occupancy Map</h2>
                <span id="mapFPS">0 FPS</span>
            </div>
            <div class="canvas-container">
                <canvas id="mapCanvas"></canvas>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="control-button" id="startBtn" onclick="startLidar()">Start Scan</button>
        <button class="control-button danger" id="stopBtn" onclick="stopLidar()" disabled>Stop Scan</button>
        <button class="control-button" onclick="clearMap()">Clear Map</button>
        <button class="control-button" onclick="saveMap()">Save Map</button>
        <button class="control-button" id="followRobotBtn" onclick="toggleFollowRobot()">Follow Robot</button>
        <button class="control-button" onclick="resetView()">Reset View</button>
        <button class="control-button mapping" id="mappingBtn" onclick="toggleMapping()">Start Mapping</button>
    </div>

    <div class="info-panel">
        <h3 style="color: #00ff88; margin-bottom: 15px;">Scan Information</h3>
        <div class="info-grid">
            <div class="info-item">
                <div class="info-label">Min Distance</div>
                <div class="info-value" id="minDistance">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Min Angle</div>
                <div class="info-value" id="minAngle">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Obstacles</div>
                <div class="info-value" id="obstacleCount">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">Safe Directions</div>
                <div class="info-value" id="safeDirections" style="font-size: 1em;">-</div>
            </div>
        </div>
    </div>

    <div class="background-panel">
        <h3 style="color: #ffaa00; margin-bottom: 15px;">Lidar Background Removal</h3>
        <div class="background-controls">
            <button class="calibrate-btn" id="calibrateBtn" onclick="calibrateBackground()">
                Calibrate Background
            </button>
            <div style="display: flex; align-items: center; gap: 10px;">
                <label for="bgRemovalToggle" style="color: #aaa;">Background Removal:</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="bgRemovalToggle" checked onchange="toggleBackgroundRemoval()">
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div id="calibrationStatus" style="color: #888;">
                Status: Not calibrated
            </div>
        </div>
        <p style="color: #666; font-size: 0.8em; margin-top: 10px;">
            Calibrate while stationary to remove robot components from lidar scans.
        </p>
    </div>

    <div class="clearance-panel">
        <h3 style="color: #ff00ff; margin-bottom: 15px;">Safety Clearance Settings (from robot body)</h3>
        <div class="clearance-controls">
            <div class="clearance-item">
                <label class="clearance-label">Critical Distance</label>
                <input type="number" class="clearance-input" id="criticalDistance" value="200" min="100" max="500" step="10">
                <div class="clearance-unit">mm (emergency stop)</div>
            </div>
            <div class="clearance-item">
                <label class="clearance-label">Safety Distance</label>
                <input type="number" class="clearance-input" id="safetyDistance" value="300" min="200" max="800" step="10">
                <div class="clearance-unit">mm (obstacle avoidance)</div>
            </div>
            <div class="clearance-item">
                <label class="clearance-label">Wall Follow Distance</label>
                <input type="number" class="clearance-input" id="wallFollowDistance" value="500" min="300" max="1000" step="50">
                <div class="clearance-unit">mm (ideal wall distance)</div>
            </div>
        </div>
        <div class="clearance-buttons">
            <button class="clearance-btn" onclick="resetClearanceDefaults()">Reset Defaults</button>
            <button class="clearance-btn apply" onclick="applyClearanceSettings()">Apply Settings</button>
        </div>
        <p style="color: #888; font-size: 0.8em; margin-top: 10px; text-align: center;">
            Note: Lidar sensor is at front center. All distances are measured from robot body edges.
        </p>
    </div>

    <div class="mapping-panel" id="mappingPanel">
        <h3 style="color: #ff00ff; margin-bottom: 15px;">Autonomous Mapping Status</h3>
        <div class="mapping-status">
            <div class="mapping-stat">
                <div class="mapping-stat-label">State</div>
                <div class="mapping-stat-value" id="mappingState">-</div>
            </div>
            <div class="mapping-stat">
                <div class="mapping-stat-label">Robot X</div>
                <div class="mapping-stat-value" id="robotPosX">0 mm</div>
            </div>
            <div class="mapping-stat">
                <div class="mapping-stat-label">Robot Y</div>
                <div class="mapping-stat-value" id="robotPosY">0 mm</div>
            </div>
            <div class="mapping-stat">
                <div class="mapping-stat-label">Angle</div>
                <div class="mapping-stat-value" id="robotAngle">0°</div>
            </div>
            <div class="mapping-stat">
                <div class="mapping-stat-label">Cells Visited</div>
                <div class="mapping-stat-value" id="cellsVisited">0</div>
            </div>
            <div class="mapping-stat">
                <div class="mapping-stat-label">Walls Found</div>
                <div class="mapping-stat-value" id="wallsFound">0</div>
            </div>
            <div class="mapping-stat">
                <div class="mapping-stat-label">Duration</div>
                <div class="mapping-stat-value" id="mappingDuration">0s</div>
            </div>
        </div>
    </div>

    <div class="controls">
        <h3 style="color: #00ff88; margin-bottom: 15px; text-align: center;">Robot Movement (Manual Control)</h3>
        <div class="movement-controls">
            <button class="move-btn" onclick="moveRobot('forward')">↑</button>
            <button class="move-btn" onclick="moveRobot('left')">←</button>
            <button class="move-btn" onclick="moveRobot('stop')">●</button>
            <button class="move-btn" onclick="moveRobot('right')">→</button>
            <button class="move-btn" onclick="moveRobot('backward')">↓</button>
        </div>
    </div>

    <script>
        // WebSocket connection
        const socket = io();
        
        // Canvas contexts
        const polarCanvas = document.getElementById('polarCanvas');
        const polarCtx = polarCanvas.getContext('2d');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');
        
        // State
        let scanning = false;
        let followRobot = true;
        let latestScanData = null;
        let mappingActive = false;
        let automationStatus = null;
        
        // Map parameters
        const MAP_SIZE = 100;  // 10m x 10m with 10cm resolution
        const MAP_RESOLUTION = 0.1;  // meters per pixel
        const occupancyMap = new Array(MAP_SIZE * MAP_SIZE).fill(0.5);  // Unknown = 0.5
        
        // Robot state
        let robotX = MAP_SIZE / 2;
        let robotY = MAP_SIZE / 2;
        let robotTheta = 0;
        const robotPath = [];
        
        // Performance monitoring
        let polarFPS = 0;
        let mapFPS = 0;
        let lastPolarUpdate = Date.now();
        let lastMapUpdate = Date.now();
        let polarFrameCount = 0;
        let mapFrameCount = 0;
        let dataRate = 0;
        let lastDataTime = Date.now();
        let dataCount = 0;
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
        });
        
        socket.on('lidar_data', (data) => {
            latestScanData = data;
            updateVisualization(data);
            
            // Update data rate
            dataCount++;
            const now = Date.now();
            if (now - lastDataTime > 1000) {
                dataRate = dataCount;
                dataCount = 0;
                lastDataTime = now;
                document.getElementById('dataRate').textContent = `${dataRate} Hz`;
            }
        });
        
        socket.on('automation_status', (status) => {
            automationStatus = status;
            updateMappingStatus(status);
        });
        
        // Resize canvases
        function resizeCanvases() {
            const containers = document.querySelectorAll('.canvas-container');
            containers.forEach((container, index) => {
                const canvas = container.querySelector('canvas');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            });
        }
        
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();
        
        // Start/Stop lidar
        async function startLidar() {
            try {
                const response = await fetch('/api/lidar/subscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    scanning = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('lidarStatus').classList.add('connected');
                    document.getElementById('lidarStatusText').textContent = 'Connected';
                }
            } catch (error) {
                console.error('Failed to start lidar:', error);
            }
        }
        
        async function stopLidar() {
            try {
                const response = await fetch('/api/lidar/unsubscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    scanning = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                    document.getElementById('lidarStatus').classList.remove('connected');
                    document.getElementById('lidarStatusText').textContent = 'Disconnected';
                }
            } catch (error) {
                console.error('Failed to stop lidar:', error);
            }
        }
        
        // Mapping control
        async function toggleMapping() {
            const mappingBtn = document.getElementById('mappingBtn');
            const mappingPanel = document.getElementById('mappingPanel');
            const mappingIndicator = document.getElementById('mappingIndicator');
            
            if (!mappingActive) {
                // Start mapping
                try {
                    // First ensure lidar is started
                    if (!scanning) {
                        await startLidar();
                    }
                    
                    const response = await fetch('/api/automation/start', { method: 'POST' });
                    const data = await response.json();
                    
                    if (data.success) {
                        mappingActive = true;
                        mappingBtn.textContent = 'Stop Mapping';
                        mappingBtn.classList.add('active');
                        mappingPanel.classList.add('active');
                        mappingIndicator.style.display = 'flex';
                        
                        // Request initial status
                        socket.emit('request_automation_status');
                    } else {
                        alert('Failed to start mapping: ' + data.error);
                    }
                } catch (error) {
                    console.error('Failed to start mapping:', error);
                    alert('Failed to start mapping');
                }
            } else {
                // Stop mapping
                try {
                    const response = await fetch('/api/automation/stop', { method: 'POST' });
                    const data = await response.json();
                    
                    if (data.success) {
                        mappingActive = false;
                        mappingBtn.textContent = 'Start Mapping';
                        mappingBtn.classList.remove('active');
                        mappingPanel.classList.remove('active');
                        mappingIndicator.style.display = 'none';
                    }
                } catch (error) {
                    console.error('Failed to stop mapping:', error);
                }
            }
        }
        
        function updateMappingStatus(status) {
            if (!status || !status.status) return;
            
            const s = status.status;
            document.getElementById('mappingState').textContent = s.state || '-';
            document.getElementById('robotPosX').textContent = `${s.robot_position?.x || 0} mm`;
            document.getElementById('robotPosY').textContent = `${s.robot_position?.y || 0} mm`;
            document.getElementById('robotAngle').textContent = `${s.robot_position?.theta || 0}°`;
            document.getElementById('cellsVisited').textContent = s.visited_cells || 0;
            document.getElementById('wallsFound').textContent = s.walls_detected || 0;
            document.getElementById('mappingDuration').textContent = `${s.duration || 0}s`;
            
            // Update robot position on map if mapping
            if (s.active && s.robot_position) {
                // Convert mm to grid coordinates
                robotX = MAP_SIZE / 2 + s.robot_position.x / (MAP_RESOLUTION * 1000);
                robotY = MAP_SIZE / 2 - s.robot_position.y / (MAP_RESOLUTION * 1000);
                robotTheta = (s.robot_position.theta * Math.PI) / 180;
                
                // Add to path
                robotPath.push({ x: robotX, y: robotY });
                if (robotPath.length > 5000) {
                    robotPath.shift();
                }
            }
        }
        
        // Visualization functions
        function updateVisualization(scanData) {
            // Update info panel
            document.getElementById('minDistance').textContent = `${scanData.min_distance.toFixed(2)}m`;
            document.getElementById('minAngle').textContent = `${scanData.min_angle_deg.toFixed(1)}°`;
            document.getElementById('obstacleCount').textContent = scanData.obstacle_count;
            document.getElementById('safeDirections').textContent = scanData.safe_directions.join(', ') || 'None';
            document.getElementById('pointCount').textContent = scanData.point_count;
            
            // Draw polar view
            drawPolarView(scanData);
            
            // Update occupancy map
            updateOccupancyMap(scanData);
            drawMapView();
        }
        
        function drawPolarView(scanData) {
            const width = polarCanvas.width;
            const height = polarCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) / 2 - 20;
            
            // Clear canvas
            polarCtx.fillStyle = '#0a0a0a';
            polarCtx.fillRect(0, 0, width, height);
            
            // Draw grid
            polarCtx.strokeStyle = '#333';
            polarCtx.lineWidth = 1;
            
            // Concentric circles
            for (let r = 1; r <= 4; r++) {
                polarCtx.beginPath();
                polarCtx.arc(centerX, centerY, (r / 4) * maxRadius, 0, 2 * Math.PI);
                polarCtx.stroke();
                
                // Distance labels
                polarCtx.fillStyle = '#666';
                polarCtx.font = '12px Arial';
                polarCtx.fillText(`${r}m`, centerX + 5, centerY - (r / 4) * maxRadius + 5);
            }
            
            // Radial lines
            for (let angle = 0; angle < 360; angle += 30) {
                const rad = angle * Math.PI / 180;
                polarCtx.beginPath();
                polarCtx.moveTo(centerX, centerY);
                polarCtx.lineTo(
                    centerX + maxRadius * Math.cos(rad),
                    centerY - maxRadius * Math.sin(rad)
                );
                polarCtx.stroke();
            }
            
            // Draw scan points
            if (scanData.points) {
                polarCtx.fillStyle = '#00ff88';
                scanData.points.forEach(point => {
                    if (point.r < 4.0) {  // Only show points within 4m
                        const x = centerX + (point.r / 4) * maxRadius * Math.cos(point.theta);
                        const y = centerY - (point.r / 4) * maxRadius * Math.sin(point.theta);
                        
                        polarCtx.beginPath();
                        polarCtx.arc(x, y, 2, 0, 2 * Math.PI);
                        polarCtx.fill();
                    }
                });
            }
            
            // Draw obstacles
            polarCtx.fillStyle = '#ff4444';
            scanData.obstacles.forEach(obstacle => {
                const x = centerX + (obstacle.distance / 4) * maxRadius * Math.cos(obstacle.angle);
                const y = centerY - (obstacle.distance / 4) * maxRadius * Math.sin(obstacle.angle);
                
                polarCtx.beginPath();
                polarCtx.arc(x, y, 4, 0, 2 * Math.PI);
                polarCtx.fill();
            });
            
            // Draw robot center
            polarCtx.fillStyle = mappingActive ? '#ff00ff' : '#00aaff';
            polarCtx.beginPath();
            polarCtx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            polarCtx.fill();
            
            // Update FPS
            polarFrameCount++;
            const now = Date.now();
            if (now - lastPolarUpdate > 1000) {
                polarFPS = polarFrameCount;
                polarFrameCount = 0;
                lastPolarUpdate = now;
                document.getElementById('polarFPS').textContent = `${polarFPS} FPS`;
            }
        }
        
        function updateOccupancyMap(scanData) {
            if (!scanData.points) return;
            
            // Update map with new scan data
            scanData.points.forEach(point => {
                if (point.r > 0 && point.r < 10) {
                    // Ray tracing - mark free space
                    const steps = Math.floor(point.r / MAP_RESOLUTION);
                    for (let step = 0; step < steps; step++) {
                        const r = step * MAP_RESOLUTION;
                        const x = Math.floor(robotX + r * Math.cos(point.theta + robotTheta) / MAP_RESOLUTION);
                        const y = Math.floor(robotY + r * Math.sin(point.theta + robotTheta) / MAP_RESOLUTION);
                        
                        if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
                            const idx = y * MAP_SIZE + x;
                            occupancyMap[idx] = Math.max(0.0, occupancyMap[idx] - 0.02);
                        }
                    }
                    
                    // Mark obstacle
                    if (point.r < 4.0) {
                        const obsX = Math.floor(robotX + point.r * Math.cos(point.theta + robotTheta) / MAP_RESOLUTION);
                        const obsY = Math.floor(robotY + point.r * Math.sin(point.theta + robotTheta) / MAP_RESOLUTION);
                        
                        if (obsX >= 0 && obsX < MAP_SIZE && obsY >= 0 && obsY < MAP_SIZE) {
                            const idx = obsY * MAP_SIZE + obsX;
                            occupancyMap[idx] = Math.min(1.0, occupancyMap[idx] + 0.1);
                        }
                    }
                }
            });
        }
        
        function drawMapView() {
            const width = mapCanvas.width;
            const height = mapCanvas.height;
            const scale = Math.min(width, height) / (MAP_SIZE * MAP_RESOLUTION);
            
            // Clear canvas
            mapCtx.fillStyle = '#0a0a0a';
            mapCtx.fillRect(0, 0, width, height);
            
            // Calculate view offset
            let offsetX = 0;
            let offsetY = 0;
            if (followRobot) {
                offsetX = width / 2 - robotX * MAP_RESOLUTION * scale;
                offsetY = height / 2 - robotY * MAP_RESOLUTION * scale;
            }
            
            mapCtx.save();
            mapCtx.translate(offsetX, offsetY);
            
            // Draw occupancy map
            const imageData = mapCtx.createImageData(MAP_SIZE, MAP_SIZE);
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const idx = y * MAP_SIZE + x;
                    const value = occupancyMap[idx];
                    const pixelIdx = (y * MAP_SIZE + x) * 4;
                    
                    if (value < 0.5) {
                        // Free space - green tint
                        imageData.data[pixelIdx] = 0;
                        imageData.data[pixelIdx + 1] = Math.floor(255 * (0.5 - value) * 2);
                        imageData.data[pixelIdx + 2] = 0;
                    } else if (value > 0.5) {
                        // Obstacle - red tint
                        imageData.data[pixelIdx] = Math.floor(255 * (value - 0.5) * 2);
                        imageData.data[pixelIdx + 1] = 0;
                        imageData.data[pixelIdx + 2] = 0;
                    } else {
                        // Unknown - gray
                        imageData.data[pixelIdx] = 64;
                        imageData.data[pixelIdx + 1] = 64;
                        imageData.data[pixelIdx + 2] = 64;
                    }
                    imageData.data[pixelIdx + 3] = 255;
                }
            }
            
            // Scale and draw map
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = MAP_SIZE;
            tempCanvas.height = MAP_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);
            
            mapCtx.imageSmoothingEnabled = false;
            mapCtx.drawImage(tempCanvas, 0, 0, MAP_SIZE * MAP_RESOLUTION * scale, MAP_SIZE * MAP_RESOLUTION * scale);
            
            // Draw robot path
            if (robotPath.length > 1) {
                mapCtx.strokeStyle = mappingActive ? '#ff00ff66' : '#00ff8866';
                mapCtx.lineWidth = 2;
                mapCtx.beginPath();
                mapCtx.moveTo(robotPath[0].x * MAP_RESOLUTION * scale, robotPath[0].y * MAP_RESOLUTION * scale);
                for (let i = 1; i < robotPath.length; i++) {
                    mapCtx.lineTo(robotPath[i].x * MAP_RESOLUTION * scale, robotPath[i].y * MAP_RESOLUTION * scale);
                }
                mapCtx.stroke();
            }
            
            // Draw robot
            const robotScreenX = robotX * MAP_RESOLUTION * scale;
            const robotScreenY = robotY * MAP_RESOLUTION * scale;
            
            // Robot body
            mapCtx.fillStyle = mappingActive ? '#ff00ff' : '#00aaff';
            mapCtx.beginPath();
            mapCtx.arc(robotScreenX, robotScreenY, 8, 0, 2 * Math.PI);
            mapCtx.fill();
            
            // Robot direction
            mapCtx.strokeStyle = mappingActive ? '#ff00ff' : '#00aaff';
            mapCtx.lineWidth = 3;
            mapCtx.beginPath();
            mapCtx.moveTo(robotScreenX, robotScreenY);
            mapCtx.lineTo(
                robotScreenX + 20 * Math.cos(robotTheta),
                robotScreenY + 20 * Math.sin(robotTheta)
            );
            mapCtx.stroke();
            
            mapCtx.restore();
            
            // Draw scale
            mapCtx.fillStyle = '#fff';
            mapCtx.font = '12px Arial';
            mapCtx.fillText('1m', 10, height - 10);
            mapCtx.strokeStyle = '#fff';
            mapCtx.lineWidth = 2;
            mapCtx.beginPath();
            mapCtx.moveTo(10, height - 20);
            mapCtx.lineTo(10 + scale, height - 20);
            mapCtx.stroke();
            
            // Update FPS
            mapFrameCount++;
            const now = Date.now();
            if (now - lastMapUpdate > 1000) {
                mapFPS = mapFrameCount;
                mapFrameCount = 0;
                lastMapUpdate = now;
                document.getElementById('mapFPS').textContent = `${mapFPS} FPS`;
            }
        }
        
        // Control functions
        function clearMap() {
            occupancyMap.fill(0.5);
            robotPath.length = 0;
            robotX = MAP_SIZE / 2;
            robotY = MAP_SIZE / 2;
            robotTheta = 0;
        }
        
        function saveMap() {
            // Convert map to image and download
            const link = document.createElement('a');
            link.download = `lidar_map_${new Date().toISOString()}.png`;
            link.href = mapCanvas.toDataURL();
            link.click();
        }
        
        function toggleFollowRobot() {
            followRobot = !followRobot;
            document.getElementById('followRobotBtn').classList.toggle('active', followRobot);
        }
        
        function resetView() {
            followRobot = true;
            document.getElementById('followRobotBtn').classList.add('active');
        }
        
        // Robot movement (simulation only when mapping is not active)
        async function moveRobot(direction) {
            if (mappingActive) {
                alert('Manual control disabled during autonomous mapping');
                return;
            }
            
            // Send motor commands for manual control
            try {
                let leftMotor = { direction: 'brake', speed: 0 };
                let rightMotor = { direction: 'brake', speed: 0 };
                
                switch (direction) {
                    case 'forward':
                        leftMotor = { direction: 'forward', speed: 85 };
                        rightMotor = { direction: 'forward', speed: 85 };
                        break;
                    case 'backward':
                        leftMotor = { direction: 'backward', speed: 85 };
                        rightMotor = { direction: 'backward', speed: 85 };
                        break;
                    case 'left':
                        leftMotor = { direction: 'backward', speed: 75 };
                        rightMotor = { direction: 'forward', speed: 75 };
                        break;
                    case 'right':
                        leftMotor = { direction: 'forward', speed: 75 };
                        rightMotor = { direction: 'backward', speed: 75 };
                        break;
                    case 'stop':
                        leftMotor = { direction: 'brake', speed: 0 };
                        rightMotor = { direction: 'brake', speed: 0 };
                        break;
                }
                
                // Send commands to motors (remember they're reversed)
                await fetch('/api/motor/0', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(rightMotor)
                });
                
                await fetch('/api/motor/1', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(leftMotor)
                });
                
            } catch (error) {
                console.error('Failed to control motors:', error);
            }
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!mappingActive) {
                switch (e.key) {
                    case 'ArrowUp':
                    case 'w':
                        moveRobot('forward');
                        break;
                    case 'ArrowDown':
                    case 's':
                        moveRobot('backward');
                        break;
                    case 'ArrowLeft':
                    case 'a':
                        moveRobot('left');
                        break;
                    case 'ArrowRight':
                    case 'd':
                        moveRobot('right');
                        break;
                    case ' ':
                        moveRobot('stop');
                        break;
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (!mappingActive && ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'].includes(e.key)) {
                moveRobot('stop');
            }
        });
        
        // Check automation status periodically
        setInterval(async () => {
            if (mappingActive) {
                try {
                    const response = await fetch('/api/automation/status');
                    const data = await response.json();
                    if (data.success) {
                        updateMappingStatus(data);
                    }
                } catch (error) {
                    console.error('Failed to get automation status:', error);
                }
            }
        }, 1000);
        
        // Load safety parameters on startup
        async function loadSafetyParameters() {
            try {
                const response = await fetch('/api/automation/safety');
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('criticalDistance').value = data.parameters.critical_distance;
                    document.getElementById('safetyDistance').value = data.parameters.safety_distance;
                    document.getElementById('wallFollowDistance').value = data.parameters.wall_follow_distance;
                }
            } catch (error) {
                console.error('Failed to load safety parameters:', error);
            }
        }
        
        // Apply clearance settings
        async function applyClearanceSettings() {
            const critical = parseInt(document.getElementById('criticalDistance').value);
            const safety = parseInt(document.getElementById('safetyDistance').value);
            const wallFollow = parseInt(document.getElementById('wallFollowDistance').value);
            
            try {
                const response = await fetch('/api/automation/safety', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        critical_distance: critical,
                        safety_distance: safety,
                        wall_follow_distance: wallFollow
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    alert('Safety parameters updated successfully!');
                } else {
                    alert('Failed to update parameters: ' + data.error);
                }
            } catch (error) {
                console.error('Failed to update safety parameters:', error);
                alert('Failed to update safety parameters');
            }
        }
        
        // Reset to default values
        function resetClearanceDefaults() {
            document.getElementById('criticalDistance').value = 200;
            document.getElementById('safetyDistance').value = 300;
            document.getElementById('wallFollowDistance').value = 500;
        }
        
        // Background calibration functions
        async function calibrateBackground() {
            const calibrateBtn = document.getElementById('calibrateBtn');
            const statusDiv = document.getElementById('calibrationStatus');
            
            calibrateBtn.disabled = true;
            calibrateBtn.textContent = 'Calibrating...';
            statusDiv.textContent = 'Status: Calibrating...';
            
            try {
                const response = await fetch('/api/automation/calibrate', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    statusDiv.textContent = `Status: Calibrated (${data.static_points} static points)`;
                    statusDiv.style.color = '#00ff88';
                } else {
                    statusDiv.textContent = 'Status: Calibration failed';
                    statusDiv.style.color = '#ff4444';
                }
            } catch (error) {
                console.error('Failed to calibrate background:', error);
                statusDiv.textContent = 'Status: Calibration error';
                statusDiv.style.color = '#ff4444';
            } finally {
                calibrateBtn.disabled = false;
                calibrateBtn.textContent = 'Calibrate Background';
            }
        }
        
        async function toggleBackgroundRemoval() {
            const toggle = document.getElementById('bgRemovalToggle');
            
            try {
                const response = await fetch('/api/automation/background/toggle', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    toggle.checked = data.enabled;
                }
            } catch (error) {
                console.error('Failed to toggle background removal:', error);
            }
        }
        
        async function loadBackgroundStatus() {
            try {
                const response = await fetch('/api/automation/background');
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('bgRemovalToggle').checked = data.enabled;
                    const statusDiv = document.getElementById('calibrationStatus');
                    if (data.calibrated) {
                        statusDiv.textContent = `Status: Calibrated (${data.static_points} static points)`;
                        statusDiv.style.color = '#00ff88';
                    } else {
                        statusDiv.textContent = 'Status: Not calibrated';
                        statusDiv.style.color = '#888';
                    }
                }
            } catch (error) {
                console.error('Failed to load background status:', error);
            }
        }
        
        // Initialize
        loadSafetyParameters();
        loadBackgroundStatus();
        toggleFollowRobot();  // Start with follow robot enabled
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/motor_control.html
Category: Web | Size: 23.4 KB | Lines: 704
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motor Control - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 40px 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin-bottom: 40px;
        }

        .motor-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 350px;
        }

        .motor-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
        }

        .motor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .motor-title {
            font-size: 1.5em;
            font-weight: 500;
            color: #00aaff;
        }

        .motor-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            background: #333;
            color: #888;
            transition: all 0.3s ease;
        }

        .motor-status.active {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .direction-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .direction-btn {
            padding: 12px 8px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .direction-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .direction-btn.active {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .direction-btn.brake.active {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            box-shadow: 0 5px 20px rgba(255, 68, 68, 0.4);
        }

        .speed-control {
            margin-top: auto;
        }

        /* Speed marks container */
        .speed-marks {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            padding: 0 12px;
        }

        .speed-mark {
            font-size: 0.75em;
            color: #666;
            text-align: center;
            position: relative;
        }

        .speed-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: #aaa;
        }

        .speed-value {
            font-size: 2em;
            font-weight: 700;
            color: #00ff88;
            min-width: 80px;
            text-align: right;
        }

        .speed-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            transition: all 0.3s ease;
        }

        /* Add markers for the 5 positions */
        .speed-slider {
            background-image: linear-gradient(to right, 
                #444 0%, #444 1px,
                transparent 1px, transparent 24.5%,
                #444 24.5%, #444 25.5%,
                transparent 25.5%, transparent 49.5%,
                #444 49.5%, #444 50.5%,
                transparent 50.5%, transparent 74.5%,
                #444 74.5%, #444 75.5%,
                transparent 75.5%, transparent 99%,
                #444 99%, #444 100%
            );
            background-size: 100% 100%;
            background-repeat: no-repeat;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .speed-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.7);
        }

        .speed-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .emergency-stop {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff0000, #cc0000);
            border: 3px solid #ff4444;
            color: white;
            font-size: 1.2em;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(255, 0, 0, 0.5);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 1000;
        }

        .emergency-stop:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(255, 0, 0, 0.7);
        }

        .emergency-stop:active {
            transform: scale(0.95);
        }

        .log-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            border: 1px solid #333;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            background: #252525;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #aaa;
            border-left: 3px solid #444;
        }

        .log-entry.error {
            border-left-color: #ff4444;
            color: #ff6666;
        }

        .log-entry.success {
            border-left-color: #00ff88;
            color: #00ff88;
        }

        .mapping-info {
            background: #252525;
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #333;
        }

        .mapping-info.active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }

        /* Responsive design */
        @media (max-width: 900px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .emergency-stop {
                width: 80px;
                height: 80px;
                font-size: 1em;
                bottom: 20px;
                right: 20px;
            }

            .direction-controls {
                grid-template-columns: 1fr;
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ROS 2 Motor Control Panel</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <span>Connection Status:</span>
        <div class="status-indicator" id="connectionStatus"></div>
        <span id="statusText">Disconnected</span>
    </div>

    <div class="main-container">
        <div class="controls-grid">
            <!-- Right Motors (Motor 0 in code = Physical Right) -->
            <div class="motor-card" data-motor="0">
                <div class="motor-header">
                    <h2 class="motor-title">Right Motors</h2>
                    <span class="motor-status">IDLE</span>
                </div>
                <div class="direction-controls">
                    <button class="direction-btn" data-direction="forward">Forward</button>
                    <button class="direction-btn" data-direction="backward">Backward</button>
                    <button class="direction-btn brake" data-direction="brake">Brake</button>
                </div>
                <div class="speed-control">
                    <div class="speed-label">
                        <span>Speed Control</span>
                        <span class="speed-value">0%</span>
                    </div>
                    <input type="range" class="speed-slider" min="0" max="100" value="0" step="25">
                    <div class="speed-marks">
                        <span class="speed-mark">0%</span>
                        <span class="speed-mark">25%</span>
                        <span class="speed-mark">50%</span>
                        <span class="speed-mark">75%</span>
                        <span class="speed-mark">100%</span>
                    </div>
                </div>
            </div>

            <!-- Left Motors (Motor 1 in code = Physical Left) -->
            <div class="motor-card" data-motor="1">
                <div class="motor-header">
                    <h2 class="motor-title">Left Motors</h2>
                    <span class="motor-status">IDLE</span>
                </div>
                <div class="direction-controls">
                    <button class="direction-btn" data-direction="forward">Forward</button>
                    <button class="direction-btn" data-direction="backward">Backward</button>
                    <button class="direction-btn brake" data-direction="brake">Brake</button>
                </div>
                <div class="speed-control">
                    <div class="speed-label">
                        <span>Speed Control</span>
                        <span class="speed-value">0%</span>
                    </div>
                    <input type="range" class="speed-slider" min="0" max="100" value="0" step="25">
                    <div class="speed-marks">
                        <span class="speed-mark">0%</span>
                        <span class="speed-mark">25%</span>
                        <span class="speed-mark">50%</span>
                        <span class="speed-mark">75%</span>
                        <span class="speed-mark">100%</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <h3 style="margin-bottom: 10px; color: #888;">Activity Log</h3>
            <div id="logContainer"></div>
        </div>
    </div>

    <button class="emergency-stop" id="emergencyStop">STOP<br>ALL</button>

    <script>
        // Motor control state
        const motorStates = {
            0: { direction: 'brake', speed: 0 },  // Right motors
            1: { direction: 'brake', speed: 0 }   // Left motors
        };

        // Command throttling
        let commandQueue = [];
        let isProcessing = false;
        const COMMAND_DELAY = 100; // 100ms between commands

        // Add log entry
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // Keep only last 10 entries
            while (logContainer.children.length > 10) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Process command queue
        async function processCommandQueue() {
            if (isProcessing || commandQueue.length === 0) return;
            
            isProcessing = true;
            const command = commandQueue.shift();
            
            try {
                const response = await fetch(`/api/motor/${command.motorId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        direction: command.direction,
                        speed: command.speed
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    const motorSide = command.motorId === 0 ? 'Right' : 'Left';
                    addLog(`${motorSide} motors: ${command.direction} at ${command.speed}%`, 'success');
                } else {
                    addLog(`Motor ${command.motorId} error: ${data.error}`, 'error');
                }
            } catch (error) {
                addLog(`Motor ${command.motorId} error: ${error.message}`, 'error');
            }
            
            // Wait before processing next command
            setTimeout(() => {
                isProcessing = false;
                processCommandQueue();
            }, COMMAND_DELAY);
        }

        // Queue motor command
        function queueMotorCommand(motorId, direction, speed) {
            // Remove any pending commands for this motor
            commandQueue = commandQueue.filter(cmd => cmd.motorId !== motorId);
            
            // Add new command
            commandQueue.push({ motorId, direction, speed });
            
            // Start processing
            processCommandQueue();
        }

        // Send motor command with direction change protection
        async function sendMotorCommand(motorId, direction, speed) {
            const lastDir = motorStates[motorId].direction;
            
            // If changing from forward to backward or vice versa, insert brake command
            if ((lastDir === 'forward' && direction === 'backward') ||
                (lastDir === 'backward' && direction === 'forward')) {
                // Queue brake first
                queueMotorCommand(motorId, 'brake', 0);
                // Then queue the new direction after a delay
                setTimeout(() => {
                    queueMotorCommand(motorId, direction, speed);
                }, 150);
            } else {
                // Direct command
                queueMotorCommand(motorId, direction, speed);
            }
            
            // Update state
            motorStates[motorId].direction = direction;
            motorStates[motorId].speed = speed;
        }

        // Check connection status
        async function checkConnection() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                const indicator = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                
                if (data.connected) {
                    indicator.classList.add('connected');
                    statusText.textContent = 'Connected';
                } else {
                    indicator.classList.remove('connected');
                    statusText.textContent = 'Disconnected';
                }
            } catch (error) {
                const indicator = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                indicator.classList.remove('connected');
                statusText.textContent = 'Error';
            }
        }

        // Update motor UI
        function updateMotorUI(motorId) {
            const motorCard = document.querySelector(`[data-motor="${motorId}"]`);
            const state = motorStates[motorId];
            
            // Update direction buttons
            const directionBtns = motorCard.querySelectorAll('.direction-btn');
            directionBtns.forEach(btn => {
                if (btn.dataset.direction === state.direction) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Update status
            const status = motorCard.querySelector('.motor-status');
            if (state.direction === 'brake') {
                status.textContent = 'BRAKE';
                status.classList.remove('active');
            } else {
                status.textContent = state.direction.toUpperCase();
                status.classList.add('active');
            }
            
            // Update speed display
            const speedValue = motorCard.querySelector('.speed-value');
            speedValue.textContent = `${state.speed}%`;
            
            // Update slider
            const slider = motorCard.querySelector('.speed-slider');
            slider.value = state.speed;
            
            // Update slider background to show progress
            const percentage = state.speed / 100;
            slider.style.background = `linear-gradient(to right, #00ff88 ${percentage * 100}%, #2a2a2a ${percentage * 100}%)`;
        }

        // Initialize motor controls
        document.querySelectorAll('.motor-card').forEach(motorCard => {
            const motorId = parseInt(motorCard.dataset.motor);
            
            // Direction buttons
            motorCard.querySelectorAll('.direction-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const direction = btn.dataset.direction;
                    motorStates[motorId].direction = direction;
                    
                    // If brake, set speed to 0
                    if (direction === 'brake') {
                        motorStates[motorId].speed = 0;
                    }
                    
                    updateMotorUI(motorId);
                    await sendMotorCommand(motorId, direction, motorStates[motorId].speed);
                });
            });
            
            // Speed slider with throttling
            const slider = motorCard.querySelector('.speed-slider');
            let sliderTimeout;
            
            slider.addEventListener('input', (e) => {
                const sliderValue = parseInt(e.target.value);
                motorStates[motorId].speed = sliderValue;
                
                // Update UI immediately
                updateMotorUI(motorId);
                
                // Clear any existing timeout
                clearTimeout(sliderTimeout);
                
                // Only send command on discrete values (0, 25, 50, 75, 100)
                if ([0, 25, 50, 75, 100].includes(sliderValue)) {
                    // Send command immediately for discrete values
                    if (motorStates[motorId].direction !== 'brake') {
                        sendMotorCommand(motorId, motorStates[motorId].direction, sliderValue);
                    }
                }
            });
            
            // Also handle change event for when user releases the slider
            slider.addEventListener('change', (e) => {
                const sliderValue = parseInt(e.target.value);
                if (motorStates[motorId].direction !== 'brake') {
                    sendMotorCommand(motorId, motorStates[motorId].direction, sliderValue);
                }
            });
        });

        // Emergency stop button
        document.getElementById('emergencyStop').addEventListener('click', async () => {
            addLog('EMERGENCY STOP ACTIVATED!', 'error');
            
            // Clear command queue
            commandQueue = [];
            
            try {
                const response = await fetch('/api/motors/stop', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Reset only 2 motors
                    for (let i = 0; i < 2; i++) {
                        motorStates[i] = { direction: 'brake', speed: 0 };
                        updateMotorUI(i);
                    }
                    addLog('All motors stopped', 'success');
                } else {
                    addLog('Emergency stop failed!', 'error');
                }
            } catch (error) {
                addLog(`Emergency stop error: ${error.message}`, 'error');
            }
        });

        // Initial setup
        checkConnection();
        setInterval(checkConnection, 5000); // Check connection every 5 seconds
        
        // Initialize UI
        for (let i = 0; i < 2; i++) {
            updateMotorUI(i);
        }
        
        addLog('Motor control panel initialized', 'success');
        addLog('Note: Motor 0 = Right side, Motor 1 = Left side', 'info');
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/thermal_camera.html
Category: Web | Size: 20.0 KB | Lines: 606
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thermal Camera - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-height: calc(100vh - 200px);
        }

        .visualization-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 1.5em;
            color: #ff6b6b;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #0a0a0a;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
            image-rendering: pixelated;
        }

        .controls {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .control-button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .control-button.active {
            background: linear-gradient(135deg, #ff6b6b, #ff4444);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
        }

        .info-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #333;
            margin-top: 20px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-item {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.3em;
            font-weight: 500;
            color: #ff6b6b;
        }

        .temperature-scale {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            background: #252525;
            border-radius: 10px;
        }

        .scale-gradient {
            flex: 1;
            height: 20px;
            border-radius: 5px;
            background: linear-gradient(to right, 
                #000080, #0000ff, #00ffff, #00ff00, 
                #ffff00, #ff8800, #ff0000, #ffffff);
        }

        .scale-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.8em;
            color: #888;
        }

        .hotspot-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .hotspot-item {
            background: #252525;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #ff6b6b;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>Thermal Camera Visualization</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span>Camera Status:</span>
            <div class="status-indicator" id="thermalStatus"></div>
            <span id="thermalStatusText">Disconnected</span>
        </div>
        <div class="status-item">
            <span>Frame Rate:</span>
            <span id="frameRate">0 FPS</span>
        </div>
        <div class="status-item">
            <span>Frame Count:</span>
            <span id="frameCount">0</span>
        </div>
    </div>

    <div class="main-container">
        <!-- Thermal Heatmap -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Thermal Heatmap</h2>
                <span id="heatmapSize">32x24</span>
            </div>
            <div class="canvas-container">
                <canvas id="thermalCanvas"></canvas>
            </div>
            <div class="temperature-scale">
                <span id="minTempLabel">20°C</span>
                <div class="scale-gradient"></div>
                <span id="maxTempLabel">30°C</span>
            </div>
        </div>

        <!-- Analysis Panel -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Thermal Analysis</h2>
            </div>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Min Temperature</div>
                    <div class="info-value" id="minTemp">-°C</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Max Temperature</div>
                    <div class="info-value" id="maxTemp">-°C</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Average</div>
                    <div class="info-value" id="avgTemp">-°C</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Center</div>
                    <div class="info-value" id="centerTemp">-°C</div>
                </div>
            </div>
            
            <div style="margin-top: 20px;">
                <h3 style="color: #ff6b6b; margin-bottom: 10px;">Hotspot Detection</h3>
                <div class="info-item">
                    <div class="info-label">Hotspots Detected</div>
                    <div class="info-value" id="hotspotCount">0</div>
                </div>
                <div class="hotspot-list" id="hotspotList"></div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="control-button" id="startBtn" onclick="startThermal()">Start Stream</button>
        <button class="control-button" id="stopBtn" onclick="stopThermal()" disabled>Stop Stream</button>
        <button class="control-button" onclick="captureFrame()">Capture Frame</button>
        <button class="control-button" onclick="saveImage()">Save Image</button>
        <button class="control-button" id="autoScaleBtn" onclick="toggleAutoScale()">Auto Scale: ON</button>
        <button class="control-button" onclick="resetView()">Reset View</button>
    </div>

    <script>
        // WebSocket connection
        const socket = io();
        
        // Canvas and context
        const canvas = document.getElementById('thermalCanvas');
        const ctx = canvas.getContext('2d');
        
        // State
        let streaming = false;
        let autoScale = true;
        let latestFrameData = null;
        
        // Performance monitoring
        let frameCount = 0;
        let lastFPSUpdate = Date.now();
        let fps = 0;
        
        // Temperature range for manual scaling
        let manualMinTemp = 20;
        let manualMaxTemp = 35;
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
        });
        
        socket.on('thermal_data', (data) => {
            latestFrameData = data;
            updateVisualization(data);
            
            // Update frame count and FPS
            frameCount++;
            const now = Date.now();
            if (now - lastFPSUpdate > 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFPSUpdate = now;
                document.getElementById('frameRate').textContent = `${fps} FPS`;
            }
        });
        
        // Color mapping function
        function temperatureToColor(temp, minTemp, maxTemp) {
            // Normalize temperature to 0-1 range
            const normalized = (temp - minTemp) / (maxTemp - minTemp);
            const clamped = Math.max(0, Math.min(1, normalized));
            
            // Color gradient: cold (blue) -> warm (red/white)
            let r, g, b;
            
            if (clamped < 0.25) {
                // Blue to cyan
                const t = clamped * 4;
                r = 0;
                g = Math.floor(t * 255);
                b = 255;
            } else if (clamped < 0.5) {
                // Cyan to green
                const t = (clamped - 0.25) * 4;
                r = 0;
                g = 255;
                b = Math.floor((1 - t) * 255);
            } else if (clamped < 0.75) {
                // Green to yellow
                const t = (clamped - 0.5) * 4;
                r = Math.floor(t * 255);
                g = 255;
                b = 0;
            } else {
                // Yellow to red to white
                const t = (clamped - 0.75) * 4;
                if (t < 0.5) {
                    r = 255;
                    g = Math.floor((1 - t * 2) * 255);
                    b = 0;
                } else {
                    r = 255;
                    g = Math.floor((t - 0.5) * 2 * 255);
                    b = Math.floor((t - 0.5) * 2 * 255);
                }
            }
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // Update visualization
        function updateVisualization(data) {
            if (!data || !data.thermal_data) return;
            
            // Update info panel
            document.getElementById('minTemp').textContent = `${data.min_temp.toFixed(1)}°C`;
            document.getElementById('maxTemp').textContent = `${data.max_temp.toFixed(1)}°C`;
            document.getElementById('avgTemp').textContent = `${data.avg_temp.toFixed(1)}°C`;
            document.getElementById('centerTemp').textContent = `${data.center_temp.toFixed(1)}°C`;
            document.getElementById('frameCount').textContent = data.frame_count || 0;
            document.getElementById('hotspotCount').textContent = data.hotspot_count || 0;
            
            // Update temperature scale
            const minTemp = autoScale ? data.min_temp : manualMinTemp;
            const maxTemp = autoScale ? data.max_temp : manualMaxTemp;
            document.getElementById('minTempLabel').textContent = `${minTemp.toFixed(1)}°C`;
            document.getElementById('maxTempLabel').textContent = `${maxTemp.toFixed(1)}°C`;
            
            // Draw heatmap
            drawHeatmap(data.thermal_data, data.width, data.height, minTemp, maxTemp);
            
            // Update hotspot list
            updateHotspotList(data.hotspots || []);
        }
        
        // Draw thermal heatmap
        function drawHeatmap(thermalData, width, height, minTemp, maxTemp) {
            // Set canvas size with scaling
            const scale = 20; // Each pixel becomes 10x10
            canvas.width = width * scale;
            canvas.height = height * scale;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw each temperature pixel
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const temp = thermalData[y][x];
                    const color = temperatureToColor(temp, minTemp, maxTemp);
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x * scale, y * scale, scale, scale);
                }
            }
            
            // Draw grid lines (optional)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= width; x++) {
                ctx.beginPath();
                ctx.moveTo(x * scale, 0);
                ctx.lineTo(x * scale, height * scale);
                ctx.stroke();
            }
            for (let y = 0; y <= height; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * scale);
                ctx.lineTo(width * scale, y * scale);
                ctx.stroke();
            }
            
            // Draw center crosshair
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            const centerX = width * scale / 2;
            const centerY = height * scale / 2;
            
            ctx.beginPath();
            ctx.moveTo(centerX - 20, centerY);
            ctx.lineTo(centerX + 20, centerY);
            ctx.moveTo(centerX, centerY - 20);
            ctx.lineTo(centerX, centerY + 20);
            ctx.stroke();
        }
        
        // Update hotspot list
        function updateHotspotList(hotspots) {
            const listContainer = document.getElementById('hotspotList');
            listContainer.innerHTML = '';
            
            hotspots.slice(0, 10).forEach((hotspot, index) => {
                const item = document.createElement('div');
                item.className = 'hotspot-item';
                item.innerHTML = `
                    <span>Hotspot ${index + 1} (${hotspot.x}, ${hotspot.y})</span>
                    <span>${hotspot.temp.toFixed(1)}°C</span>
                `;
                listContainer.appendChild(item);
            });
        }
        
        // Control functions
        async function startThermal() {
            try {
                const response = await fetch('/api/thermal/subscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    streaming = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('thermalStatus').classList.add('connected');
                    document.getElementById('thermalStatusText').textContent = 'Connected';
                }
            } catch (error) {
                console.error('Failed to start thermal camera:', error);
            }
        }
        
        async function stopThermal() {
            try {
                const response = await fetch('/api/thermal/unsubscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    streaming = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                    document.getElementById('thermalStatus').classList.remove('connected');
                    document.getElementById('thermalStatusText').textContent = 'Disconnected';
                }
            } catch (error) {
                console.error('Failed to stop thermal camera:', error);
            }
        }
        
        async function captureFrame() {
            try {
                const response = await fetch('/api/thermal/frame');
                const result = await response.json();
                
                if (result.success) {
                    updateVisualization(result.data);
                }
            } catch (error) {
                console.error('Failed to capture frame:', error);
            }
        }
        
        function saveImage() {
            const link = document.createElement('a');
            link.download = `thermal_${new Date().toISOString()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }
        
        function toggleAutoScale() {
            autoScale = !autoScale;
            document.getElementById('autoScaleBtn').textContent = `Auto Scale: ${autoScale ? 'ON' : 'OFF'}`;
            if (latestFrameData) {
                updateVisualization(latestFrameData);
            }
        }
        
        function resetView() {
            manualMinTemp = 20;
            manualMaxTemp = 35;
            if (!autoScale && latestFrameData) {
                updateVisualization(latestFrameData);
            }
        }
        
        // Add mouse hover to show temperature
        canvas.addEventListener('mousemove', (e) => {
            if (!latestFrameData || !latestFrameData.thermal_data) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = Math.floor((e.clientX - rect.left) * scaleX / 10);
            const y = Math.floor((e.clientY - rect.top) * scaleY / 10);
            
            if (x >= 0 && x < latestFrameData.width && y >= 0 && y < latestFrameData.height) {
                const temp = latestFrameData.thermal_data[y][x];
                canvas.title = `Temperature: ${temp.toFixed(1)}°C at (${x}, ${y})`;
            }
        });
    </script>
</body>
</html>
================================================================================

