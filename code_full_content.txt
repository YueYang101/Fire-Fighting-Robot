================================================================================
FULL CODE CONTENT DUMP
Directory: /Users/yang/Library/CloudStorage/OneDrive-Personal/UCL/Year 4 UCL/MECH0073/GitHub_Repositories/Fire-fighting-Robot
Time: 2025-06-10 19:30:23
================================================================================

DIRECTORY STRUCTURE:
----------------------------------------
├── Cad Files/
├── fire_fighting_robot_bringup/
│   ├── launch/
│   │   └── robot_bringup.launch.py (2.9 KB)
│   ├── CMakeLists.txt (216.0 B)
│   └── package.xml (738.0 B)
├── Image Processing/
│   └── depth_camera_main.py (2.2 KB)
├── mlx90640_driver/
│   ├── config/
│   │   └── thermal_camera.yaml (360.0 B)
│   ├── launch/
│   │   └── thermal_camera_launch.py (1.2 KB)
│   ├── mlx90640_driver/
│   │   ├── __init__.py (0.0 B)
│   │   └── thermal_camera_node.py (6.3 KB)
│   ├── resource/
│   ├── package.xml (736.0 B)
│   └── setup.py (1.6 KB)
├── mlx90640_interfaces/
│   ├── msg/
│   ├── srv/
│   ├── CMakeLists.txt (630.0 B)
│   └── package.xml (823.0 B)
├── pca9685_interfaces/
│   ├── srv/
│   ├── CMakeLists.txt (482.0 B)
│   └── package.xml (663.0 B)
├── pca9685_motor_driver_py/
│   ├── config/
│   │   └── motor_map.yaml (505.0 B)
│   ├── launch/
│   │   └── motor_driver_launch.py (484.0 B)
│   ├── pca9685_motor_driver_py/
│   │   ├── __init__.py (0.0 B)
│   │   └── motor_driver_node.py (8.2 KB)
│   ├── resource/
│   ├── test/
│   │   ├── test_copyright.py (962.0 B)
│   │   ├── test_flake8.py (884.0 B)
│   │   └── test_pep257.py (803.0 B)
│   ├── package.xml (790.0 B)
│   ├── setup.cfg (120.0 B)
│   └── setup.py (1.0 KB)
├── robot-dashboard/
│   ├── backend/
│   │   ├── motors/
│   │   │   ├── __init__.py (0.0 B)
│   │   │   ├── motor_controller.py (6.3 KB)
│   │   │   ├── motor_routes.py (3.7 KB)
│   │   │   └── servo_control.py (6.7 KB)
│   │   ├── sensors/
│   │   │   ├── __init__.py (280.0 B)
│   │   │   ├── lidar.py (8.0 KB)
│   │   │   └── thermal_camera.py (7.7 KB)
│   │   ├── __init__.py (285.0 B)
│   │   ├── config_manager.py (3.3 KB)
│   │   ├── host_backend.py (17.6 KB)
│   │   └── ros_bridge.py (14.3 KB)
│   ├── frontend/
│   │   └── templates/
│   │       ├── aiming_system.html (24.3 KB)
│   │       ├── dashboard_home.html (25.4 KB)
│   │       ├── lidar_visualization.html (26.8 KB)
│   │       ├── motor_control.html (23.3 KB)
│   │       └── thermal_camera.html (20.0 KB)
│   ├── ui/
│   ├── code_full_content.txt (197.3 KB)
│   ├── code_scan_summary.txt (1.3 KB)
│   ├── code_scanner.py (12.9 KB)
│   ├── requirements.txt (130.0 B)
│   └── run.py (341.0 B)
├── servo_controller_py/
│   ├── config/
│   │   └── servo_config.yaml (300.0 B)
│   ├── launch/
│   │   └── servo_controller_launch.py (1.0 KB)
│   ├── resource/
│   ├── servo_controller_py/
│   │   ├── __init__.py (0.0 B)
│   │   └── servo_controller_node.py (6.7 KB)
│   ├── test/
│   ├── package.xml (839.0 B)
│   ├── setup.cfg (107.0 B)
│   └── setup.py (932.0 B)
├── servo_interfaces/
│   ├── msg/
│   ├── srv/
│   ├── CMakeLists.txt (547.0 B)
│   └── package.xml (737.0 B)
├── Test_folder/
│   ├── Aiming_system/
│   │   └── demo_python.py (3.8 KB)
│   ├── Camera_Test/
│   │   ├── D435/
│   │   │   ├── demo.py (26.6 KB)
│   │   │   ├── power_test.py (18.5 KB)
│   │   │   └── usb_reset.py (11.1 KB)
│   │   └── Thermal_Camera_test/
│   │       ├── save_frame_local.py (5.9 KB)
│   │       ├── short_CRC_test.py (498.0 B)
│   │       ├── thermal_camera_test.py (3.4 KB)
│   ├── lidar/
│   │   └── YDLidar_G2_test.py (4.6 KB)
│   ├── Motor Channel Mapping/
│   │   ├── channel_mapping_client.py (4.8 KB)
│   │   ├── channel_mapping_host.py (2.9 KB)
│   ├── Trigger_system/
│   │   ├── demo.py (9.6 KB)
│   │   └── WS_control.py (10.4 KB)
│   └── system_monitor.py (13.1 KB)
├── code_scanner.py (12.9 KB)
├── create_servo_package.py (16.5 KB)
├── dump_local_repo.py (2.9 KB)
├── Flask_app.py (5.7 KB)
├── Pi_motor_control.py (4.5 KB)
└── README.md (4.0 KB)

================================================================================
STATISTICS:
----------------------------------------
Total code files: 71
Total size: 579.3 KB
Total lines: 17,359

FILES BY CATEGORY:
----------------------------------------
Config: 12 files, 6.6 KB, 210 lines
Documentation: 8 files, 204.5 KB, 6,266 lines
Python: 46 files, 248.3 KB, 7,271 lines
Web: 5 files, 119.9 KB, 3,612 lines

================================================================================
FILE CONTENTS:
================================================================================

================================================================================
FILE: fire_fighting_robot_bringup/package.xml
Category: Config | Size: 738.0 B | Lines: 21
================================================================================
<?xml version="1.0"?>
<package format="3">
  <name>fire_fighting_robot_bringup</name>  <!-- CHANGE THIS -->
  <version>0.0.1</version>
  <description>Fire Fighting Robot Bringup Package</description>  <!-- Optional: update description -->
  <maintainer email="your_email@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>
  
  <exec_depend>rosbridge_server</exec_depend>
  <exec_depend>pca9685_motor_driver_py</exec_depend>
  <exec_depend>ydlidar_ros2_driver</exec_depend>
  <exec_depend>mlx90640_driver</exec_depend>
  <exec_depend>launch</exec_depend>
  <exec_depend>launch_ros</exec_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
================================================================================


================================================================================
FILE: mlx90640_driver/config/thermal_camera.yaml
Category: Config | Size: 360.0 B | Lines: 11
================================================================================
thermal_camera_node:
  ros__parameters:
    # Publishing rate in Hz (how often to publish thermal frames)
    # Note: Camera hardware runs at 1Hz, this controls ROS publishing
    publish_rate: 0.5
    
    # Frame ID for header
    frame_id: "thermal_camera"
    
    # Enable continuous publishing (set false for service-only mode)
    enable_publisher: true
================================================================================


================================================================================
FILE: mlx90640_driver/package.xml
Category: Config | Size: 736.0 B | Lines: 23
================================================================================
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>mlx90640_driver</name>
  <version>0.0.0</version>
  <description>ROS 2 driver for MLX90640 thermal camera</description>
  
  <maintainer email="you@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>
  
  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>
  
  <depend>rclpy</depend>
  <depend>std_msgs</depend>
  <depend>mlx90640_interfaces</depend>
  
  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
================================================================================


================================================================================
FILE: mlx90640_interfaces/package.xml
Category: Config | Size: 823.0 B | Lines: 25
================================================================================
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>mlx90640_interfaces</name>
  <version>0.0.0</version>
  <description>ROS 2 interfaces for MLX90640 thermal camera</description>
  <maintainer email="you@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <buildtool_depend>rosidl_default_generators</buildtool_depend>

  <depend>std_msgs</depend>

  <exec_depend>rosidl_default_runtime</exec_depend>

  <member_of_group>rosidl_interface_packages</member_of_group>

  <test_depend>ament_lint_auto</test_depend>
  <test_depend>ament_lint_common</test_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
================================================================================


================================================================================
FILE: pca9685_interfaces/package.xml
Category: Config | Size: 663.0 B | Lines: 21
================================================================================
<?xml version="1.0"?>
<package format="3">
  <name>pca9685_interfaces</name>
  <version>0.0.0</version>
  <description>Service definitions for the PCA9685 motor driver.</description>

  <maintainer email="zcemuex@ucl.ac.uk">Yang Yue</maintainer>
  <license>MIT</license>

  <!-- build / interface dependencies -->
  <buildtool_depend>ament_cmake</buildtool_depend>
  <build_depend>rosidl_default_generators</build_depend>
  <exec_depend>rosidl_default_runtime</exec_depend>

  <!-- *** THIS is the line that matters *** -->
  <member_of_group>rosidl_interface_packages</member_of_group>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>

================================================================================


================================================================================
FILE: pca9685_motor_driver_py/config/motor_map.yaml
Category: Config | Size: 505.0 B | Lines: 16
================================================================================
motor_driver:
  ros__parameters:
    # Simplified 2-motor configuration
    # Motor 0: Right side (uses PCA channels 0,1)
    # Motor 1: Left side (uses PCA channels 2,3)
    motor_map: [0,1,  2,3]
    
    # PWM frequency for motor control
    pwm_frequency: 100
    
    # Optional: Add these parameters for better control
    # Dead time in milliseconds (only applied on direction change)
    dead_time_ms: 50
    
    # Minimum speed change to trigger update (helps with noise)
    min_speed_change: 5
================================================================================


================================================================================
FILE: pca9685_motor_driver_py/package.xml
Category: Config | Size: 790.0 B | Lines: 26
================================================================================
<?xml version="1.0"?>
<package format="3">
  <name>pca9685_motor_driver_py</name>
  <version>0.0.0</version>
  <description>ROS 2 motor driver for a PCA9685 PWM board</description>
  <maintainer email="ubuntu-robot-pi4@todo.todo">ubuntu-robot-pi4</maintainer>
  <license>MIT</license>

  <!-- build tool -->
  <buildtool_depend>ament_python</buildtool_depend>

  <!-- run-time deps -->
  <exec_depend>rclpy</exec_depend>
  <exec_depend>std_srvs</exec_depend>
  <exec_depend>pca9685_interfaces</exec_depend>

  <!-- (optional) test deps -->
  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>

================================================================================


================================================================================
FILE: pca9685_motor_driver_py/setup.cfg
Category: Config | Size: 120.0 B | Lines: 5
================================================================================
[develop]
script_dir = $base/lib/pca9685_motor_driver_py

[install]
install_scripts = $base/lib/pca9685_motor_driver_py

================================================================================


================================================================================
FILE: servo_controller_py/config/servo_config.yaml
Category: Config | Size: 300.0 B | Lines: 12
================================================================================
servo_controller:
  ros__parameters:
    # GPIO pin numbers (BCM numbering)
    pan_pin: 13    # GPIO 13 for pan servo
    tilt_pin: 12   # GPIO 12 for tilt servo
    
    # PWM settings
    pwm_frequency: 50  # Hz
    
    # Angle limits
    min_angle: 0     # degrees
    max_angle: 270   # degrees
================================================================================


================================================================================
FILE: servo_controller_py/package.xml
Category: Config | Size: 839.0 B | Lines: 24
================================================================================
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>servo_controller_py</name>
  <version>0.0.1</version>
  <description>ROS2 package for controlling pan-tilt servos on Raspberry Pi</description>
  <maintainer email="your_email@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_python</buildtool_depend>

  <exec_depend>rclpy</exec_depend>
  <exec_depend>std_msgs</exec_depend>
  <exec_depend>servo_interfaces</exec_depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>

================================================================================


================================================================================
FILE: servo_controller_py/setup.cfg
Category: Config | Size: 107.0 B | Lines: 4
================================================================================
[develop]
script_dir=$base/lib/servo_controller_py
[install]
install_scripts=$base/lib/servo_controller_py

================================================================================


================================================================================
FILE: servo_interfaces/package.xml
Category: Config | Size: 737.0 B | Lines: 22
================================================================================
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>servo_interfaces</name>
  <version>0.0.1</version>
  <description>Custom messages and services for servo control</description>
  <maintainer email="your_email@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <buildtool_depend>rosidl_default_generators</buildtool_depend>

  <depend>std_msgs</depend>

  <exec_depend>rosidl_default_runtime</exec_depend>

  <member_of_group>rosidl_interface_packages</member_of_group>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>

================================================================================


================================================================================
FILE: README.md
Category: Documentation | Size: 4.0 KB | Lines: 171
================================================================================
# Fire Fighting Robot Operations Guide

## SSH Configuration

### Set up SSH key for passwordless login

```bash
# Generate SSH key (if you don't have one)
ssh-keygen -t rsa -b 4096

# Copy SSH key to Raspberry Pi
ssh-copy-id ubuntu-robot-pi4@ubuntu-robot.local
# Or use IP addresses:
ssh-copy-id ubuntu-robot-pi4@192.168.124.39
ssh-copy-id ubuntu-robot-pi4@192.168.0.121
```

### SSH Connection Options

```bash
# Connect via hostname
ssh ubuntu-robot-pi4@ubuntu-robot.local

# Connect via IP (Option 1)
ssh ubuntu-robot-pi4@192.168.124.39

# Connect via IP (Option 2)
ssh ubuntu-robot-pi4@192.168.0.121
```

**Default Password**: `000000`

## WiFi Configuration

### Scan and List Available Networks

```bash
sudo nmcli device wifi rescan && nmcli device wifi list
```

### Connect to WiFi Networks

```bash
# Connect to robot_connection network
sudo nmcli device wifi connect "robot_connection" password "00000000"

# Connect to H3C_831A87 network
sudo nmcli device wifi connect "H3C_831A87" password "987654321@"
```

## ROS2 Launch Commands

### Option 1: Launch Everything at Once

```bash
ros2 launch fire_fighting_robot_bringup robot_bringup.launch.py
```

### Option 2: Launch Components Individually

#### 1. Launch Rosbridge WebSocket

```bash
ros2 launch rosbridge_server rosbridge_websocket_launch.xml
```

#### 2. Launch Motor Driver Node

```bash
ros2 run pca9685_motor_driver_py motor_driver_node \
  --ros-args --params-file /home/ubuntu-robot-pi4/ros2_ws/src/Fire-Fighting-Robot/pca9685_motor_driver_py/config/motor_map.yaml
```

#### 3. Launch YDLIDAR

```bash
ros2 launch ydlidar_ros2_driver ydlidar_launch.py params_file:=/home/ubuntu-robot-pi4/ros2_ws/src/ydlidar_ros2_driver/params/G2.yaml
```

#### 4. Launch Thermal Camera

```bash
~/ros2_ws/install/mlx90640_driver/bin/thermal_camera_node
```

## Useful Commands

### Navigate to Repository on Raspberry Pi

```bash
cd ~/ros2_ws/src/Fire-Fighting-Robot
```

### Shutdown Raspberry Pi

```bash
sudo shutdown -h now
```

## Dashboard Setup (Mac)

### Navigate to Project Directory

```bash
cd ~/Library/CloudStorage/OneDrive-Personal/UCL/Year\ 4\ UCL/MECH0073/GitHub_Repositories/Fire-fighting-Robot
```

### Activate Virtual Environment and Run Dashboard

```bash
# Activate virtual environment
source venv/bin/activate

# Navigate to dashboard directory
cd robot-dashboard

# Set Flask port
export FLASK_PORT=5001

# Run the dashboard
python run.py
```

### Scan Dashboard Files

```bash
python3 dashboard_scanner.py > dashboard_scan_output.txt
```

## Quick Reference

### Common IP Addresses
- **Hostname**: `ubuntu-robot.local`
- **IP Option 1**: `192.168.124.39`
- **IP Option 2**: `192.168.0.121`

### Default Credentials
- **Username**: `ubuntu-robot-pi4`
- **Password**: `000000`

### WiFi Networks
- **Network 1**: `robot_connection` (Password: `00000000`)
- **Network 2**: `H3C_831A87` (Password: `987654321@`)

### Important Paths
- **ROS2 Workspace**: `/home/ubuntu-robot-pi4/ros2_ws/`
- **Fire Fighting Robot Package**: `/home/ubuntu-robot-pi4/ros2_ws/src/Fire-Fighting-Robot/`
- **Motor Config**: `/home/ubuntu-robot-pi4/ros2_ws/src/Fire-Fighting-Robot/pca9685_motor_driver_py/config/motor_map.yaml`
- **YDLIDAR Config**: `/home/ubuntu-robot-pi4/ros2_ws/src/ydlidar_ros2_driver/params/G2.yaml`

## Troubleshooting Tips

1. **SSH Connection Issues**
   - Ensure Raspberry Pi is powered on and connected to the network
   - Try different IP addresses if hostname doesn't work
   - Check if SSH service is running: `sudo systemctl status ssh`

2. **WiFi Connection Issues**
   - Verify WiFi adapter is enabled: `nmcli radio wifi`
   - Enable if disabled: `nmcli radio wifi on`
   - Check current connection: `nmcli connection show`

3. **ROS2 Launch Issues**
   - Source ROS2 setup: `source /opt/ros/humble/setup.bash`
   - Source workspace: `source ~/ros2_ws/install/setup.bash`
   - Check if all dependencies are installed

4. **Dashboard Connection Issues**
   - Ensure Flask port is not already in use
   - Check firewall settings
   - Verify rosbridge WebSocket is running
================================================================================


================================================================================
FILE: fire_fighting_robot_bringup/CMakeLists.txt
Category: Documentation | Size: 216.0 B | Lines: 12
================================================================================
cmake_minimum_required(VERSION 3.5)
project(fire_fighting_robot_bringup)

find_package(ament_cmake REQUIRED)

# Install launch files
install(DIRECTORY
  launch/
  DESTINATION share/${PROJECT_NAME}/
)

ament_package()
================================================================================


================================================================================
FILE: mlx90640_interfaces/CMakeLists.txt
Category: Documentation | Size: 630.0 B | Lines: 25
================================================================================
cmake_minimum_required(VERSION 3.8)
project(mlx90640_interfaces)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# find dependencies
find_package(ament_cmake REQUIRED)
find_package(std_msgs REQUIRED)
find_package(rosidl_default_generators REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  "msg/ThermalFrame.msg"
  "srv/GetThermalFrame.srv"
  DEPENDENCIES std_msgs
)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  ament_lint_auto_find_test_dependencies()
endif()

ament_export_dependencies(rosidl_default_runtime)
ament_package()

================================================================================


================================================================================
FILE: pca9685_interfaces/CMakeLists.txt
Category: Documentation | Size: 482.0 B | Lines: 20
================================================================================
cmake_minimum_required(VERSION 3.8)
project(pca9685_interfaces)

# 1) find the ROS 2 code-generator framework
find_package(rosidl_default_generators REQUIRED)

# 2) find every interface pkg you listed under DEPENDENCIES
find_package(builtin_interfaces REQUIRED)
find_package(std_msgs REQUIRED)

# 3) now generate your service code
rosidl_generate_interfaces(${PROJECT_NAME}
  "srv/SetMotor.srv"
  DEPENDENCIES
    builtin_interfaces
    std_msgs
)

# 4) boilerplate
ament_package()

================================================================================


================================================================================
FILE: robot-dashboard/code_full_content.txt
Category: Documentation | Size: 197.3 KB | Lines: 5978
================================================================================
================================================================================
FULL CODE CONTENT DUMP
Directory: /Users/yang/Library/CloudStorage/OneDrive-Personal/UCL/Year 4 UCL/MECH0073/GitHub_Repositories/Fire-fighting-Robot/robot-dashboard
Time: 2025-06-10 19:20:32
================================================================================

DIRECTORY STRUCTURE:
----------------------------------------
├── backend/
│   ├── motors/
│   │   ├── __init__.py (0.0 B)
│   │   ├── motor_controller.py (6.3 KB)
│   │   ├── motor_routes.py (3.7 KB)
│   │   └── servo_control.py (6.7 KB)
│   ├── sensors/
│   │   ├── __init__.py (280.0 B)
│   │   ├── lidar.py (8.0 KB)
│   │   └── thermal_camera.py (7.7 KB)
│   ├── __init__.py (285.0 B)
│   ├── config_manager.py (3.3 KB)
│   ├── host_backend.py (17.6 KB)
│   └── ros_bridge.py (14.3 KB)
├── frontend/
│   └── templates/
│       ├── aiming_system.html (23.6 KB)
│       ├── dashboard_home.html (25.4 KB)
│       ├── lidar_visualization.html (26.8 KB)
│       ├── motor_control.html (23.3 KB)
│       └── thermal_camera.html (20.0 KB)
├── ui/
├── code_full_content.txt (196.7 KB)
├── code_scan_summary.txt (1.2 KB)
├── code_scanner.py (12.9 KB)
├── requirements.txt (130.0 B)
└── run.py (341.0 B)

================================================================================
STATISTICS:
----------------------------------------
Total code files: 20
Total size: 385.7 KB
Total lines: 11,748

FILES BY CATEGORY:
----------------------------------------
Documentation: 3 files, 198.1 KB, 6,004 lines
Python: 12 files, 68.4 KB, 2,154 lines
Web: 5 files, 119.1 KB, 3,590 lines

================================================================================
FILE CONTENTS:
================================================================================

================================================================================
FILE: code_full_content.txt
Category: Documentation | Size: 196.7 KB | Lines: 5966
================================================================================

================================================================================


================================================================================
FILE: code_scan_summary.txt
Category: Documentation | Size: 1.2 KB | Lines: 31
================================================================================
Code Scan Summary - 2025-06-10 19:20:32
Directory: /Users/yang/Library/CloudStorage/OneDrive-Personal/UCL/Year 4 UCL/MECH0073/GitHub_Repositories/Fire-fighting-Robot/robot-dashboard
Total files: 20
Total size: 385.7 KB
Total lines: 11,748

Files by category:
  Documentation: 3 files
  Python: 12 files
  Web: 5 files

All code files:
  code_full_content.txt (Documentation, 196.7 KB)
  code_scan_summary.txt (Documentation, 1.2 KB)
  requirements.txt (Documentation, 130.0 B)
  backend/__init__.py (Python, 285.0 B)
  backend/config_manager.py (Python, 3.3 KB)
  backend/host_backend.py (Python, 17.6 KB)
  backend/motors/__init__.py (Python, 0.0 B)
  backend/motors/motor_controller.py (Python, 6.3 KB)
  backend/motors/motor_routes.py (Python, 3.7 KB)
  backend/motors/servo_control.py (Python, 6.7 KB)
  backend/ros_bridge.py (Python, 14.3 KB)
  backend/sensors/__init__.py (Python, 280.0 B)
  backend/sensors/lidar.py (Python, 8.0 KB)
  backend/sensors/thermal_camera.py (Python, 7.7 KB)
  run.py (Python, 341.0 B)
  frontend/templates/aiming_system.html (Web, 23.6 KB)
  frontend/templates/dashboard_home.html (Web, 25.4 KB)
  frontend/templates/lidar_visualization.html (Web, 26.8 KB)
  frontend/templates/motor_control.html (Web, 23.3 KB)
  frontend/templates/thermal_camera.html (Web, 20.0 KB)

================================================================================


================================================================================
FILE: requirements.txt
Category: Documentation | Size: 130.0 B | Lines: 7
================================================================================
Flask==3.0.0
Flask-CORS==4.0.0
Flask-SocketIO==5.3.5
websocket-client==1.7.0
watchdog==3.0.0
numpy==1.26.2
python-socketio==5.10.0
================================================================================


================================================================================
FILE: backend/__init__.py
Category: Python | Size: 285.0 B | Lines: 14
================================================================================
"""
Backend package for ROS 2 Motor Control
"""

from .ros_bridge import ROSBridgeConnection, MotorController, get_ros_bridge, get_motor_controller

__all__ = [
    'ROSBridgeConnection',
    'MotorController', 
    'get_ros_bridge',
    'get_motor_controller'
]

__version__ = '1.0.0'
================================================================================


================================================================================
FILE: backend/config_manager.py
Category: Python | Size: 3.3 KB | Lines: 105
================================================================================
#!/usr/bin/env python3
"""
Configuration manager for persistent settings
Saves and loads configuration from a JSON file
"""

import json
import os
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class ConfigManager:
    """Manages persistent configuration settings"""
    
    def __init__(self, config_file: str = None):
        """
        Initialize configuration manager
        
        Args:
            config_file: Path to configuration file (default: ~/.robot_dashboard_config.json)
        """
        if config_file is None:
            # Use home directory for config file
            self.config_file = Path.home() / ".robot_dashboard_config.json"
        else:
            self.config_file = Path(config_file)
        
        # Default configuration
        self.default_config = {
            "PI_IP": "192.168.2.1",
            "ROS_BRIDGE_PORT": 9090,
            "FLASK_PORT": 5001,
            "FLASK_HOST": "0.0.0.0"
        }
        
        # Load configuration
        self.config = self.load_config()
    
    def load_config(self) -> dict:
        """Load configuration from file or return defaults"""
        try:
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    loaded_config = json.load(f)
                    # Merge with defaults (in case new fields are added)
                    config = self.default_config.copy()
                    config.update(loaded_config)
                    logger.info(f"Loaded configuration from {self.config_file}")
                    return config
            else:
                logger.info("No config file found, using defaults")
                return self.default_config.copy()
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            return self.default_config.copy()
    
    def save_config(self):
        """Save current configuration to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
            logger.info(f"Saved configuration to {self.config_file}")
            return True
        except Exception as e:
            logger.error(f"Error saving config: {e}")
            return False
    
    def update_config(self, updates: dict) -> bool:
        """
        Update configuration values
        
        Args:
            updates: Dictionary of configuration updates
            
        Returns:
            bool: True if successful
        """
        try:
            # Update configuration
            self.config.update(updates)
            # Save to file
            return self.save_config()
        except Exception as e:
            logger.error(f"Error updating config: {e}")
            return False
    
    def get(self, key: str, default=None):
        """Get configuration value"""
        return self.config.get(key, default)
    
    def get_all(self) -> dict:
        """Get all configuration values"""
        return self.config.copy()

# Singleton instance
_config_manager = None

def get_config_manager(config_file: str = None) -> ConfigManager:
    """Get or create ConfigManager instance"""
    global _config_manager
    if _config_manager is None:
        _config_manager = ConfigManager(config_file)
    return _config_manager
================================================================================


================================================================================
FILE: backend/host_backend.py
Category: Python | Size: 17.6 KB | Lines: 571
================================================================================
#!/usr/bin/env python3
"""
Flask backend server for ROS 2 robot control
Main application entry point with multi-component support
"""

import os
import sys
from pathlib import Path

# Add parent directory to path for imports
sys.path.append(str(Path(__file__).parent.parent))

from flask import Flask, render_template, jsonify, request
from flask_cors import CORS
from flask_socketio import SocketIO, emit
import logging

# Import configuration manager
from backend.config_manager import get_config_manager

# Import ROS bridge components
from backend.ros_bridge import get_ros_bridge, get_motor_controller
from backend.sensors.lidar import get_lidar_sensor
from backend.sensors.thermal_camera import get_thermal_camera_sensor
from backend.motors.servo_control import ServoController

# Create Flask app
app = Flask(__name__, 
            template_folder='../frontend/templates',
            static_folder='../frontend/static')
CORS(app)  # Enable CORS for API requests
socketio = SocketIO(app, cors_allowed_origins="*")  # For real-time data

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Load configuration from persistent storage
config_manager = get_config_manager()
CONFIG = config_manager.get_all()

# Initialize ROS components with saved configuration
ros_bridge = get_ros_bridge(CONFIG["PI_IP"], CONFIG["ROS_BRIDGE_PORT"])
motor_controller = get_motor_controller()
lidar_sensor = get_lidar_sensor()
thermal_camera_sensor = get_thermal_camera_sensor()
servo_controller = ServoController()

# Set ROS bridge for servo controller
servo_controller.set_ros_bridge(ros_bridge)

# Data streaming states
lidar_streaming = False
servo_streaming = False

# =============================================================================
# MAIN DASHBOARD ROUTES
# =============================================================================

@app.route('/')
def index():
    """Serve the main dashboard home page"""
    return render_template('dashboard_home.html')

@app.route('/motors')
def motors_page():
    """Serve the motor control interface"""
    return render_template('motor_control.html')

@app.route('/lidar')
def lidar_page():
    """Serve the lidar visualization interface"""
    return render_template('lidar_visualization.html')

@app.route('/thermal')
def thermal_page():
    """Serve the thermal camera interface"""
    return render_template('thermal_camera.html')

@app.route('/aiming')
def aiming_system():
    """Serve the aiming system control interface"""
    return render_template('aiming_system.html')

# =============================================================================
# MOTOR CONTROL API ROUTES
# =============================================================================

@app.route('/api/motor/<int:motor_id>', methods=['POST'])
def control_motor(motor_id):
    """Control a specific motor"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        # Use motor controller
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in control_motor: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/motor/<int:motor_id>', methods=['GET'])
def get_motor_status(motor_id):
    """Get current status of a specific motor"""
    state = motor_controller.get_motor_state(motor_id)
    
    if state:
        return jsonify({
            "success": True,
            "motor_id": motor_id,
            "state": state
        })
    else:
        return jsonify({
            "success": False,
            "error": "Invalid motor ID"
        }), 404

@app.route('/api/motors', methods=['GET'])
def get_all_motors_status():
    """Get current status of all motors"""
    states = motor_controller.get_all_motor_states()
    
    return jsonify({
        "success": True,
        "motors": states
    })

@app.route('/api/motors/stop', methods=['POST'])
def stop_all_motors():
    """Emergency stop - brake all motors"""
    result = motor_controller.stop_all_motors()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

# =============================================================================
# SERVO/AIMING SYSTEM API ROUTES
# =============================================================================

@app.route('/api/servo/position', methods=['POST'])
def set_servo_position():
    """Set servo position for pan/tilt"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        pan_angle = data.get('pan_angle', servo_controller.pan_angle)
        tilt_angle = data.get('tilt_angle', servo_controller.tilt_angle)
        
        # Move servos
        result = servo_controller.move_to_position(pan_angle, tilt_angle)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in set_servo_position: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/servo/position', methods=['GET'])
def get_servo_position():
    """Get current servo position"""
    state = servo_controller.get_state()
    
    return jsonify({
        "success": True,
        "state": state
    })

@app.route('/api/servo/center', methods=['POST'])
def center_servos():
    """Move servos to center position"""
    result = servo_controller.center_position()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 400

@app.route('/api/servo/preset/<string:position>', methods=['POST'])
def move_to_preset(position):
    """Move servos to preset position (left, right, up, down)"""
    preset_functions = {
        'left': servo_controller.move_left,
        'right': servo_controller.move_right,
        'up': servo_controller.move_up,
        'down': servo_controller.move_down,
        'center': servo_controller.center_position
    }
    
    if position not in preset_functions:
        return jsonify({
            "success": False,
            "error": f"Invalid preset position: {position}"
        }), 400
    
    result = preset_functions[position]()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 400

# =============================================================================
# LIDAR API ROUTES
# =============================================================================

@app.route('/api/lidar/status', methods=['GET'])
def get_lidar_status():
    """Get lidar sensor status"""
    latest_scan = lidar_sensor.get_latest_scan()
    
    return jsonify({
        "connected": lidar_sensor.subscription_active,
        "has_data": latest_scan is not None,
        "timestamp": latest_scan["timestamp"] if latest_scan else None
    })

@app.route('/api/lidar/latest', methods=['GET'])
def get_latest_lidar_scan():
    """Get the most recent lidar scan data"""
    scan_data = lidar_sensor.get_latest_scan()
    
    if scan_data:
        return jsonify({
            "success": True,
            "data": scan_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "No scan data available"
        }), 404

@app.route('/api/lidar/subscribe', methods=['POST'])
def subscribe_lidar():
    """Start lidar data subscription"""
    global lidar_streaming
    
    def lidar_callback(scan_data):
        """Emit lidar data through WebSocket"""
        if lidar_streaming:
            socketio.emit('lidar_data', scan_data)
    
    success = lidar_sensor.subscribe(callback=lidar_callback, processed_data=True)
    
    if success:
        lidar_streaming = True
        return jsonify({"success": True, "message": "Lidar subscription started"})
    else:
        return jsonify({"success": False, "error": "Failed to subscribe to lidar"}), 500

@app.route('/api/lidar/unsubscribe', methods=['POST'])
def unsubscribe_lidar():
    """Stop lidar data subscription"""
    global lidar_streaming
    
    lidar_streaming = False
    lidar_sensor.unsubscribe()
    
    return jsonify({"success": True, "message": "Lidar subscription stopped"})

# =============================================================================
# THERMAL CAMERA API ROUTES
# =============================================================================

@app.route('/api/thermal/status', methods=['GET'])
def get_thermal_status():
    """Get thermal camera sensor status"""
    latest_frame = thermal_camera_sensor.get_latest_frame()
    
    return jsonify({
        "connected": thermal_camera_sensor.subscription_active,
        "has_data": latest_frame is not None,
        "timestamp": latest_frame["timestamp"] if latest_frame else None
    })

@app.route('/api/thermal/latest', methods=['GET'])
def get_latest_thermal_frame():
    """Get the most recent thermal frame data"""
    frame_data = thermal_camera_sensor.get_latest_frame()
    
    if frame_data:
        return jsonify({
            "success": True,
            "data": frame_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "No thermal data available"
        }), 404

@app.route('/api/thermal/frame', methods=['GET'])
def get_thermal_frame():
    """Get a single thermal frame via service call"""
    frame_data = thermal_camera_sensor.get_thermal_frame_once()
    
    if frame_data:
        return jsonify({
            "success": True,
            "data": frame_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "Failed to capture thermal frame"
        }), 500

@app.route('/api/thermal/subscribe', methods=['POST'])
def subscribe_thermal():
    """Start thermal camera data subscription"""
    def thermal_callback(frame_data):
        """Emit thermal data through WebSocket"""
        socketio.emit('thermal_data', frame_data)
    
    success = thermal_camera_sensor.subscribe(callback=thermal_callback)
    
    if success:
        return jsonify({"success": True, "message": "Thermal camera subscription started"})
    else:
        return jsonify({"success": False, "error": "Failed to subscribe to thermal camera"}), 500

@app.route('/api/thermal/unsubscribe', methods=['POST'])
def unsubscribe_thermal():
    """Stop thermal camera data subscription"""
    thermal_camera_sensor.unsubscribe()
    
    return jsonify({"success": True, "message": "Thermal camera subscription stopped"})

# =============================================================================
# SYSTEM STATUS ROUTES
# =============================================================================

@app.route('/api/status', methods=['GET'])
def get_system_status():
    """Check connection status to ROS bridge and system info"""
    ros_connected = ros_bridge.test_connection()
    
    return jsonify({
        "connected": ros_connected,
        "rosbridge_url": ros_bridge.url,
        "config": {
            "robot_ip": CONFIG["PI_IP"],
            "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"]
        },
        "components": {
            "motors": True,
            "lidar": lidar_sensor.subscription_active,
            "thermal": thermal_camera_sensor.subscription_active,
            "servo": servo_controller.connected
        }
    }), 200 if ros_connected else 503

@app.route('/api/config', methods=['GET'])
def get_config():
    """Get current configuration"""
    return jsonify({
        "robot_ip": CONFIG["PI_IP"],
        "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"],
        "flask_port": CONFIG["FLASK_PORT"],
        "flask_host": CONFIG["FLASK_HOST"]
    })

@app.route('/api/config', methods=['POST'])
def update_config():
    """Update configuration with new connection settings"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        # Get new settings
        new_ip = data.get('robot_ip')
        new_port = data.get('rosbridge_port')
        
        if not new_ip or not new_port:
            return jsonify({"error": "Missing robot_ip or rosbridge_port"}), 400
        
        # Update configuration in memory
        CONFIG["PI_IP"] = new_ip
        CONFIG["ROS_BRIDGE_PORT"] = int(new_port)
        
        # Save to persistent storage
        config_updates = {
            "PI_IP": new_ip,
            "ROS_BRIDGE_PORT": int(new_port)
        }
        config_manager.update_config(config_updates)
        
        # Update ROS bridge connection
        global ros_bridge, motor_controller, lidar_sensor, thermal_camera_sensor, servo_controller
        ros_bridge = get_ros_bridge(CONFIG["PI_IP"], CONFIG["ROS_BRIDGE_PORT"])
        motor_controller = get_motor_controller()
        lidar_sensor = get_lidar_sensor()
        thermal_camera_sensor = get_thermal_camera_sensor()
        
        # Update servo controller with new ROS bridge
        servo_controller.set_ros_bridge(ros_bridge)
        
        logger.info(f"Configuration updated and saved: IP={new_ip}, Port={new_port}")
        
        return jsonify({
            "success": True,
            "message": "Configuration updated successfully",
            "config": {
                "robot_ip": CONFIG["PI_IP"],
                "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"]
            }
        })
        
    except Exception as e:
        logger.error(f"Error updating configuration: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

# =============================================================================
# WEBSOCKET EVENTS
# =============================================================================

@socketio.on('connect')
def handle_connect():
    """Handle WebSocket connection"""
    logger.info("Client connected to WebSocket")
    emit('connected', {'data': 'Connected to robot dashboard'})

@socketio.on('disconnect')
def handle_disconnect():
    """Handle WebSocket disconnection"""
    logger.info("Client disconnected from WebSocket")

# Servo WebSocket events
@socketio.on('servo_command')
def handle_servo_command(data):
    """Handle servo commands via WebSocket"""
    global servo_streaming
    
    try:
        command_type = data.get('type', 'servo_command')
        
        if command_type == 'servo_command':
            result = servo_controller.handle_websocket_command(data)
            
            # Send response
            emit('servo_response', {
                'type': 'command_result',
                'result': result
            })
            
            # Send updated state to all clients
            state = servo_controller.get_state()
            socketio.emit('servo_state', {
                'type': 'servo_state',
                **state
            })
            
    except Exception as e:
        logger.error(f"Error handling servo command: {e}")
        emit('servo_error', {
            'type': 'error',
            'error': str(e)
        })

@socketio.on('request_servo_state')
def handle_servo_state_request():
    """Send current servo state via WebSocket"""
    state = servo_controller.get_state()
    emit('servo_state', {
        'type': 'servo_state',
        **state
    })

# =============================================================================
# ERROR HANDLERS
# =============================================================================

@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Not found"}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Internal server error"}), 500

# Health check endpoint
@app.route('/health', methods=['GET'])
def health_check():
    """Simple health check endpoint"""
    return jsonify({
        "status": "healthy",
        "service": "robot-dashboard-backend"
    })

# =============================================================================
# INITIALIZATION
# =============================================================================

def initialize_system():
    """Initialize all system components"""
    logger.info("Initializing system components...")
    
    # Set WebSocket handler for servo updates
    def servo_websocket_handler(data):
        """Handle servo state updates"""
        socketio.emit('servo_state', data)
    
    servo_controller.set_websocket_handler(servo_websocket_handler)
    
    # Initialize servo to center position
    logger.info("Moving servos to center position...")
    servo_controller.center_position()
    
    logger.info("System initialization complete")

def main():
    """Main entry point"""
    logger.info("=" * 50)
    logger.info("ROS 2 Robot Dashboard Backend")
    logger.info(f"Robot IP: {CONFIG['PI_IP']}")
    logger.info(f"ROS Bridge Port: {CONFIG['ROS_BRIDGE_PORT']}")
    logger.info(f"Flask Server: {CONFIG['FLASK_HOST']}:{CONFIG['FLASK_PORT']}")
    logger.info(f"Config file: {config_manager.config_file}")
    logger.info("=" * 50)
    
    # Initialize system
    initialize_system()
    
    # Run Flask app with SocketIO
    debug_mode = os.environ.get('FLASK_ENV', 'development') == 'development'
    
    socketio.run(
        app,
        debug=debug_mode,
        host=CONFIG['FLASK_HOST'],
        port=CONFIG['FLASK_PORT'],
        use_reloader=False  # Disable auto-reloader to prevent numpy reload issues
    )

if __name__ == '__main__':
    main()
================================================================================


================================================================================
FILE: backend/motors/__init__.py
Category: Python | Size: 0.0 B | Lines: 0
================================================================================

================================================================================


================================================================================
FILE: backend/motors/motor_controller.py
Category: Python | Size: 6.3 KB | Lines: 192
================================================================================
"""
Motor Controller Module
Handles motor control logic and ROS communication
"""

import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

class MotorController:
    """Motor controller for 4-motor robot using L298N drivers"""
    
    def __init__(self, ros_bridge=None):
        self.ros_bridge = ros_bridge
        
        # Motor state tracking
        self.motor_states = {
            1: {"direction": "brake", "speed": 0},
            2: {"direction": "brake", "speed": 0},
            3: {"direction": "brake", "speed": 0},
            4: {"direction": "brake", "speed": 0}
        }
        
        # Motor channel mapping (2 motors per L298N channel)
        self.motor_to_channel = {
            1: 'A',  # Front-left
            2: 'A',  # Front-right
            3: 'B',  # Rear-left
            4: 'B'   # Rear-right
        }
        
        logger.info("Motor controller initialized")
    
    def set_ros_bridge(self, ros_bridge):
        """Set or update the ROS bridge instance"""
        self.ros_bridge = ros_bridge
        logger.info("ROS bridge connected to motor controller")
    
    def set_motor(self, motor_id: int, direction: str, speed: int) -> Dict[str, Any]:
        """
        Control a specific motor
        
        Args:
            motor_id: Motor number (1-4)
            direction: 'forward', 'backward', or 'brake'
            speed: Speed value (0-100)
        
        Returns:
            Result dictionary with success status
        """
        # Validate inputs
        if motor_id not in range(1, 5):
            return {
                "success": False,
                "error": f"Invalid motor ID: {motor_id}. Must be 1-4."
            }
        
        if direction not in ['forward', 'backward', 'brake']:
            return {
                "success": False,
                "error": f"Invalid direction: {direction}"
            }
        
        # Clamp speed to valid range
        speed = max(0, min(100, speed))
        
        # Update motor state
        self.motor_states[motor_id] = {
            "direction": direction,
            "speed": speed
        }
        
        # Get channel for this motor
        channel = self.motor_to_channel[motor_id]
        
        # Send command via ROS bridge if available
        if self.ros_bridge:
            try:
                # For motors sharing a channel, we need to consider both motors
                channel_motors = [m for m, ch in self.motor_to_channel.items() if ch == channel]
                
                # If both motors on the channel have the same direction, use that
                # Otherwise, handle mixed directions appropriately
                channel_direction = direction
                channel_speed = speed
                
                # Send motor command
                self.ros_bridge.send_motor_command(channel, channel_direction, channel_speed)
                
                logger.info(f"Motor {motor_id} set to {direction} at speed {speed}")
                
                return {
                    "success": True,
                    "motor_id": motor_id,
                    "direction": direction,
                    "speed": speed,
                    "channel": channel
                }
                
            except Exception as e:
                logger.error(f"Failed to send motor command: {e}")
                return {
                    "success": False,
                    "error": str(e)
                }
        else:
            # No ROS bridge - just update local state
            return {
                "success": True,
                "motor_id": motor_id,
                "direction": direction,
                "speed": speed,
                "message": "Motor state updated (no ROS bridge connected)"
            }
    
    def get_motor_state(self, motor_id: int) -> Optional[Dict[str, Any]]:
        """Get current state of a specific motor"""
        if motor_id in self.motor_states:
            return self.motor_states[motor_id]
        return None
    
    def get_all_motor_states(self) -> Dict[int, Dict[str, Any]]:
        """Get current state of all motors"""
        return self.motor_states.copy()
    
    def stop_all_motors(self) -> Dict[str, Any]:
        """Emergency stop - brake all motors"""
        try:
            for motor_id in range(1, 5):
                self.set_motor(motor_id, "brake", 0)
            
            logger.warning("Emergency stop - all motors braked")
            
            return {
                "success": True,
                "message": "All motors stopped"
            }
            
        except Exception as e:
            logger.error(f"Failed to stop all motors: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def set_channel_motors(self, channel: str, direction: str, speed: int) -> Dict[str, Any]:
        """
        Control all motors on a specific channel
        Used for coordinated movement (e.g., both left motors for turning)
        
        Args:
            channel: 'A' or 'B'
            direction: 'forward', 'backward', or 'brake'
            speed: Speed value (0-100)
        """
        if channel not in ['A', 'B']:
            return {
                "success": False,
                "error": f"Invalid channel: {channel}"
            }
        
        # Find motors on this channel
        channel_motors = [m for m, ch in self.motor_to_channel.items() if ch == channel]
        
        # Set all motors on the channel
        for motor_id in channel_motors:
            result = self.set_motor(motor_id, direction, speed)
            if not result['success']:
                return result
        
        return {
            "success": True,
            "channel": channel,
            "motors": channel_motors,
            "direction": direction,
            "speed": speed
        }

# Singleton instance
_motor_controller_instance = None

def get_motor_controller(ros_bridge=None):
    """Get or create motor controller instance"""
    global _motor_controller_instance
    
    if _motor_controller_instance is None:
        _motor_controller_instance = MotorController(ros_bridge)
    elif ros_bridge is not None:
        _motor_controller_instance.set_ros_bridge(ros_bridge)
    
    return _motor_controller_instance
================================================================================


================================================================================
FILE: backend/motors/motor_routes.py
Category: Python | Size: 3.7 KB | Lines: 121
================================================================================
"""
Motor Control Routes Module
Handles all motor-related API endpoints
"""

from flask import Blueprint, jsonify, request, render_template
import logging
from backend.motor.motor_controller import get_motor_controller

# Create Blueprint
motor_bp = Blueprint('motors', __name__)

# Setup logging
logger = logging.getLogger(__name__)

# =============================================================================
# MOTOR PAGE ROUTE
# =============================================================================

@motor_bp.route('/motors')
def motors_page():
    """Serve the motor control interface"""
    return render_template('motor_control.html')

# =============================================================================
# MOTOR CONTROL API ROUTES
# =============================================================================

@motor_bp.route('/api/motor/<int:motor_id>', methods=['POST'])
def control_motor(motor_id):
    """Control a specific motor"""
    try:
        motor_controller = get_motor_controller()
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        # Use motor controller
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in control_motor: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@motor_bp.route('/api/motor/<int:motor_id>', methods=['GET'])
def get_motor_status(motor_id):
    """Get current status of a specific motor"""
    motor_controller = get_motor_controller()
    state = motor_controller.get_motor_state(motor_id)
    
    if state:
        return jsonify({
            "success": True,
            "motor_id": motor_id,
            "state": state
        })
    else:
        return jsonify({
            "success": False,
            "error": "Invalid motor ID"
        }), 404

@motor_bp.route('/api/motors', methods=['GET'])
def get_all_motors_status():
    """Get current status of all motors"""
    motor_controller = get_motor_controller()
    states = motor_controller.get_all_motor_states()
    
    return jsonify({
        "success": True,
        "motors": states
    })

@motor_bp.route('/api/motors/stop', methods=['POST'])
def stop_all_motors():
    """Emergency stop - brake all motors"""
    motor_controller = get_motor_controller()
    result = motor_controller.stop_all_motors()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

# Optional: WebSocket support for real-time motor control
def init_motor_websocket(socketio):
    """Initialize WebSocket handlers for motor control"""
    
    @socketio.on('motor_command')
    def handle_motor_command(data):
        """Handle real-time motor commands via WebSocket"""
        motor_controller = get_motor_controller()
        motor_id = data.get('motor_id')
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        socketio.emit('motor_response', {
            'motor_id': motor_id,
            'result': result
        })
    
    @socketio.on('request_motor_states')
    def handle_motor_states_request():
        """Send current motor states via WebSocket"""
        motor_controller = get_motor_controller()
        states = motor_controller.get_all_motor_states()
        socketio.emit('motor_states', states)
================================================================================


================================================================================
FILE: backend/motors/servo_control.py
Category: Python | Size: 6.7 KB | Lines: 199
================================================================================
"""
Servo Control Interface for Aiming System
Controls pan and tilt servos through ROS2 topics
"""

import json
import logging
from typing import Dict, Any, Optional, Callable
from datetime import datetime
import asyncio

logger = logging.getLogger(__name__)

class ServoController:
    def __init__(self):
        self.pan_angle = 135.0  # Default center position
        self.tilt_angle = 135.0  # Default center position
        self.pan_moving = False
        self.tilt_moving = False
        self.connected = False
        self.ros_bridge = None
        self.websocket_handler = None
        self.last_command_time = None
        
        # Servo limits
        self.pan_min = 75.0
        self.pan_max = 195.0
        self.tilt_min = 75.0
        self.tilt_max = 195.0
        
        # Movement tracking
        self.target_pan = 135.0
        self.target_tilt = 135.0
        self.movement_speed = 60.0  # degrees per second
        
        logger.info("Servo controller initialized")
    
    def set_ros_bridge(self, ros_bridge):
        """Set the ROS bridge instance for publishing commands"""
        self.ros_bridge = ros_bridge
        self.connected = True
        logger.info("ROS bridge connected to servo controller")
    
    def set_websocket_handler(self, handler: Callable):
        """Set the WebSocket handler for sending updates"""
        self.websocket_handler = handler
    
    def move_to_position(self, pan: float, tilt: float) -> Dict[str, Any]:
        """
        Move servos to specified position (synchronous version)
        
        Args:
            pan: Pan angle (75-195 degrees)
            tilt: Tilt angle (75-195 degrees)
            
        Returns:
            Status dictionary
        """
        # Run async version in sync context
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        result = loop.run_until_complete(self._async_move_to_position(pan, tilt))
        loop.close()
        return result
    
    async def _async_move_to_position(self, pan: float, tilt: float) -> Dict[str, Any]:
        """
        Move servos to specified position (async version)
        
        Args:
            pan: Pan angle (75-195 degrees)
            tilt: Tilt angle (75-195 degrees)
            
        Returns:
            Status dictionary
        """
        # Validate angles
        pan = max(self.pan_min, min(self.pan_max, pan))
        tilt = max(self.tilt_min, min(self.tilt_max, tilt))
        
        self.target_pan = pan
        self.target_tilt = tilt
        self.last_command_time = datetime.now()
        
        # Check if movement needed
        if abs(self.pan_angle - pan) > 0.5:
            self.pan_moving = True
        if abs(self.tilt_angle - tilt) > 0.5:
            self.tilt_moving = True
        
        # Send ROS command if bridge available
        if self.ros_bridge:
            try:
                from backend.ros_bridge import get_servo_publisher
                servo_pub = get_servo_publisher()
                success = servo_pub.publish_position(pan, tilt)
                if success:
                    logger.info(f"Servo command sent: pan={pan}, tilt={tilt}")
                else:
                    logger.error("Failed to publish servo command")
                    return {
                        'success': False,
                        'error': 'Failed to publish servo command'
                    }
            except Exception as e:
                logger.error(f"Failed to send servo command: {e}")
                return {
                    'success': False,
                    'error': str(e)
                }
        
        # Update positions immediately for UI feedback
        self.pan_angle = pan
        self.tilt_angle = tilt
        self.pan_moving = False
        self.tilt_moving = False
        
        return {
            'success': True,
            'pan_angle': pan,
            'tilt_angle': tilt,
            'message': f"Moving to pan={pan}°, tilt={tilt}°"
        }
    
    def get_state(self) -> Dict[str, Any]:
        """Get current servo state"""
        return {
            'pan_angle': round(self.pan_angle, 1),
            'tilt_angle': round(self.tilt_angle, 1),
            'pan_moving': self.pan_moving,
            'tilt_moving': self.tilt_moving,
            'connected': self.connected,
            'target_pan': self.target_pan,
            'target_tilt': self.target_tilt,
            'timestamp': datetime.now().isoformat()
        }
    
    def center_position(self) -> Dict[str, Any]:
        """Move servos to center position (135, 135)"""
        return self.move_to_position(135.0, 135.0)
    
    def move_left(self) -> Dict[str, Any]:
        """Move to left position"""
        return self.move_to_position(75.0, 135.0)
    
    def move_right(self) -> Dict[str, Any]:
        """Move to right position"""
        return self.move_to_position(195.0, 135.0)
    
    def move_up(self) -> Dict[str, Any]:
        """Move to up position"""
        return self.move_to_position(135.0, 195.0)
    
    def move_down(self) -> Dict[str, Any]:
        """Move to down position"""
        return self.move_to_position(135.0, 75.0)
    
    def emergency_stop(self):
        """Stop all servo movement"""
        self.pan_moving = False
        self.tilt_moving = False
        self.target_pan = self.pan_angle
        self.target_tilt = self.tilt_angle
        logger.warning("Emergency stop activated for servos")
    
    def process_ros_feedback(self, data: Dict[str, Any]):
        """Process feedback from ROS about actual servo positions"""
        if 'pan_angle' in data:
            self.pan_angle = data['pan_angle']
        if 'tilt_angle' in data:
            self.tilt_angle = data['tilt_angle']
        
        # Check if reached target
        if abs(self.pan_angle - self.target_pan) < 1.0:
            self.pan_moving = False
        if abs(self.tilt_angle - self.target_tilt) < 1.0:
            self.tilt_moving = False
    
    def handle_websocket_command(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle commands from WebSocket (synchronous)"""
        action = data.get('action')
        
        if action == 'move':
            pan = data.get('pan_angle', self.pan_angle)
            tilt = data.get('tilt_angle', self.tilt_angle)
            return self.move_to_position(pan, tilt)
        
        elif action == 'center':
            return self.center_position()
        
        elif action == 'get_state':
            return self.get_state()
        
        elif action == 'emergency_stop':
            self.emergency_stop()
            return {'success': True, 'message': 'Emergency stop activated'}
        
        else:
            return {'success': False, 'error': f'Unknown action: {action}'}
================================================================================


================================================================================
FILE: backend/ros_bridge.py
Category: Python | Size: 14.3 KB | Lines: 458
================================================================================
#!/usr/bin/env python3
"""
ROS Bridge WebSocket communication module
Handles all ROS 2 communication via rosbridge
"""

import json
import logging
from websocket import create_connection
from typing import Dict, Any, Optional, Tuple

# Setup logging
logger = logging.getLogger(__name__)

class ROSBridgeConnection:
    """Manages WebSocket connection to ROS 2 via rosbridge"""
    
    def __init__(self, host: str = "192.168.2.4", port: int = 9090):
        """
        Initialize ROS Bridge connection parameters
        
        Args:
            host: IP address of the ROS 2 robot
            port: rosbridge websocket port (default: 9090)
        """
        self.host = host
        self.port = port
        self.url = f"ws://{host}:{port}"
        self._connection = None
    
    def connect(self) -> bool:
        """
        Establish connection to rosbridge
        
        Returns:
            bool: True if connection successful, False otherwise
        """
        try:
            self._connection = create_connection(self.url, timeout=5)
            logger.info(f"Connected to rosbridge at {self.url}")
            return True
        except Exception as e:
            logger.error(f"Failed to connect to rosbridge: {e}")
            return False
    
    def disconnect(self):
        """Close the websocket connection"""
        if self._connection:
            self._connection.close()
            self._connection = None
            logger.info("Disconnected from rosbridge")
    
    def is_connected(self) -> bool:
        """Check if connection is active"""
        return self._connection is not None
    
    def call_service(self, service_name: str, args: Dict[str, Any], 
                    service_id: Optional[str] = None) -> Tuple[bool, Dict[str, Any]]:
        """
        Call a ROS service through rosbridge
        
        Args:
            service_name: Name of the ROS service (e.g., "/set_motor")
            args: Service arguments as dictionary
            service_id: Optional ID for the service call
        
        Returns:
            Tuple[bool, Dict]: (success, response_data)
        """
        try:
            # Try to create a new connection for each call to avoid broken pipe
            ws = create_connection(self.url, timeout=5)
            
            # Prepare service call message
            request = {
                "op": "call_service",
                "service": service_name,
                "args": args
            }
            
            if service_id:
                request["id"] = service_id
            
            # Send request
            ws.send(json.dumps(request))
            
            # Get response
            response = ws.recv()
            response_data = json.loads(response)
            
            # Close connection
            ws.close()
            
            logger.debug(f"Service call response: {response_data}")
            return True, response_data
            
        except Exception as e:
            logger.error(f"Service call failed: {e}")
            return False, {"error": str(e)}
    
    def publish_topic(self, topic_name: str, msg_type: str, msg_data: Dict[str, Any]) -> bool:
        """
        Publish a message to a ROS topic
        
        Args:
            topic_name: Name of the ROS topic (e.g., "/servo_position_cmd")
            msg_type: ROS message type (e.g., "servo_interfaces/msg/ServoPosition")
            msg_data: Message data as dictionary
        
        Returns:
            bool: True if publish successful, False otherwise
        """
        try:
            # Create a new connection for publishing
            ws = create_connection(self.url, timeout=5)
            
            # First advertise the topic
            advertise_msg = {
                "op": "advertise",
                "topic": topic_name,
                "type": msg_type
            }
            ws.send(json.dumps(advertise_msg))
            
            # Then publish the message
            publish_msg = {
                "op": "publish",
                "topic": topic_name,
                "msg": msg_data
            }
            ws.send(json.dumps(publish_msg))
            
            # Close connection
            ws.close()
            
            logger.debug(f"Published to {topic_name}: {msg_data}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to publish to topic {topic_name}: {e}")
            return False
    
    def subscribe_topic(self, topic_name: str, callback=None) -> bool:
        """
        Subscribe to a ROS topic
        
        Args:
            topic_name: Name of the ROS topic
            callback: Function to call when message received
        
        Returns:
            bool: True if subscription successful
        """
        try:
            if not self._connection:
                self.connect()
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": topic_name
            }
            self._connection.send(json.dumps(subscribe_msg))
            
            logger.info(f"Subscribed to topic: {topic_name}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to topic {topic_name}: {e}")
            return False
    
    def test_connection(self) -> bool:
        """
        Test if rosbridge connection is working
        
        Returns:
            bool: True if connection is working
        """
        try:
            temp_conn = create_connection(self.url, timeout=2)
            temp_conn.close()
            return True
        except Exception:
            return False

class MotorController:
    """High-level motor control interface using ROSBridge"""
    
    def __init__(self, ros_bridge: ROSBridgeConnection):
        """
        Initialize motor controller
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.motor_states = {
            0: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            1: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            2: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            3: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0}
        }
    
    @staticmethod
    def percent_to_pwm(percent: float) -> int:
        """
        Convert percentage (0-100) to PWM value (0-65535)
        
        For dual-PWM motor drivers, use NORMAL mapping:
        - 0% speed → PWM 0 (motor stopped)
        - 100% speed → PWM 65535 (motor full speed)
        
        Note: The previous INVERTED mapping was for different motor drivers
        """
        # Ensure percent is within bounds
        percent = max(0, min(100, percent))
        
        # NORMAL PWM calculation (not inverted)
        # 0% → 0, 100% → 65535
        pwm = int((percent / 100.0) * 65535)
        
        logger.debug(f"Converting {percent}% to PWM: {pwm}")
        return pwm
    
    @staticmethod
    def pwm_to_percent(pwm: int) -> float:
        """
        Convert PWM value (0-65535) to percentage (0-100)
        
        Using NORMAL mapping:
        - PWM 0 = 0% speed
        - PWM 65535 = 100% speed
        """
        # NORMAL calculation (not inverted)
        return round((pwm / 65535.0) * 100, 1)
    
    def set_motor(self, motor_id: int, direction: str, speed_percent: float) -> Dict[str, Any]:
        """
        Set motor speed and direction
        
        Args:
            motor_id: Motor ID (0-3)
            direction: Direction ("forward", "backward", "brake")
            speed_percent: Speed in percentage (0-100)
        
        Returns:
            Dict containing operation result
        """
        # Validate inputs
        if motor_id < 0 or motor_id > 3:
            return {
                "success": False,
                "error": "Invalid motor ID. Must be 0-3"
            }
        
        if direction not in ["forward", "backward", "brake"]:
            return {
                "success": False,
                "error": "Invalid direction. Must be 'forward', 'backward', or 'brake'"
            }
        
        if not isinstance(speed_percent, (int, float)) or speed_percent < 0 or speed_percent > 100:
            return {
                "success": False,
                "error": "Invalid speed. Must be 0-100"
            }
        
        # Convert to PWM with NORMAL mapping
        if direction == "brake":
            # Brake always uses PWM 0
            speed_pwm = 0
        else:
            # Use normal PWM mapping: 0% = PWM 0, 100% = PWM 65535
            speed_pwm = self.percent_to_pwm(speed_percent)
        
        # Call ROS service (connection is handled in call_service)
        service_args = {
            "motor_id": motor_id,
            "direction": direction,
            "speed": speed_pwm
        }
        
        logger.info(f"Sending to ROS - Motor: {motor_id}, Direction: {direction}, Speed: {speed_percent}% (PWM: {speed_pwm})")
        
        success, response = self.ros_bridge.call_service(
            "/set_motor", 
            service_args,
            f"motor_cmd_{motor_id}"
        )
        
        if success:
            # Update internal state
            self.motor_states[motor_id] = {
                "direction": direction,
                "speed_percent": speed_percent,
                "speed_pwm": speed_pwm
            }
            
            logger.info(f"Motor {motor_id} set to {direction} at {speed_percent}% (PWM: {speed_pwm})")
            
            return {
                "success": True,
                "motor_id": motor_id,
                "direction": direction,
                "speed_percent": speed_percent,
                "speed_pwm": speed_pwm,
                "response": response
            }
        else:
            return {
                "success": False,
                "error": response.get("error", "Unknown error"),
                "motor_id": motor_id
            }
    
    def stop_all_motors(self) -> Dict[str, Any]:
        """
        Emergency stop - brake all motors
        
        Returns:
            Dict containing results for all motors
        """
        results = []
        
        for motor_id in range(4):
            # Brake with speed 0
            result = self.set_motor(motor_id, "brake", 0)
            results.append(result)
        
        all_success = all(r["success"] for r in results)
        
        return {
            "success": all_success,
            "results": results
        }
    
    def get_motor_state(self, motor_id: int) -> Optional[Dict[str, Any]]:
        """
        Get current state of a motor
        
        Args:
            motor_id: Motor ID (0-3)
        
        Returns:
            Dict with motor state or None if invalid ID
        """
        if motor_id in self.motor_states:
            return self.motor_states[motor_id].copy()
        return None
    
    def get_all_motor_states(self) -> Dict[int, Dict[str, Any]]:
        """Get current state of all motors"""
        return self.motor_states.copy()

class ServoPublisher:
    """High-level servo control interface using ROSBridge"""
    
    def __init__(self, ros_bridge: ROSBridgeConnection):
        """
        Initialize servo publisher
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.topic_name = "/servo_position_cmd"
        self.msg_type = "servo_interfaces/msg/ServoPosition"
    
    def publish_position(self, pan_angle: float, tilt_angle: float) -> bool:
        """
        Publish servo position command
        
        Args:
            pan_angle: Pan servo angle (75-195 degrees)
            tilt_angle: Tilt servo angle (75-195 degrees)
        
        Returns:
            bool: True if successful
        """
        # Prepare message
        msg_data = {
            "pan_angle": pan_angle,
            "tilt_angle": tilt_angle
        }
        
        # Publish to topic
        success = self.ros_bridge.publish_topic(
            self.topic_name,
            self.msg_type,
            msg_data
        )
        
        if success:
            logger.info(f"Published servo position: pan={pan_angle}, tilt={tilt_angle}")
        else:
            logger.error(f"Failed to publish servo position")
        
        return success

# Create singleton instances for easy import
_ros_bridge = None
_motor_controller = None
_servo_publisher = None

def get_ros_bridge(host: str = None, port: int = None) -> ROSBridgeConnection:
    """Get or create ROSBridge connection instance"""
    global _ros_bridge
    
    # If host/port provided, update or create new connection
    if host is not None or port is not None:
        if _ros_bridge:
            # Update existing connection
            if host:
                _ros_bridge.host = host
                _ros_bridge.url = f"ws://{host}:{_ros_bridge.port}"
            if port:
                _ros_bridge.port = port
                _ros_bridge.url = f"ws://{_ros_bridge.host}:{port}"
        else:
            # Create new connection with provided settings
            _ros_bridge = ROSBridgeConnection(
                host or "192.168.2.4", 
                port or 9090
            )
    elif _ros_bridge is None:
        # Create with defaults if not exists
        _ros_bridge = ROSBridgeConnection()
    
    return _ros_bridge

def get_motor_controller() -> MotorController:
    """Get or create MotorController instance"""
    global _motor_controller
    if _motor_controller is None:
        _motor_controller = MotorController(get_ros_bridge())
    return _motor_controller

def get_servo_publisher() -> ServoPublisher:
    """Get or create ServoPublisher instance"""
    global _servo_publisher
    if _servo_publisher is None:
        _servo_publisher = ServoPublisher(get_ros_bridge())
    return _servo_publisher

# Convenience function for servo control to match the expected interface
async def publish_servo_position(pan_angle: float, tilt_angle: float) -> bool:
    """
    Publish servo position (async wrapper for compatibility)
    
    Args:
        pan_angle: Pan servo angle
        tilt_angle: Tilt servo angle
    
    Returns:
        bool: Success status
    """
    servo_pub = get_servo_publisher()
    return servo_pub.publish_position(pan_angle, tilt_angle)
================================================================================


================================================================================
FILE: backend/sensors/__init__.py
Category: Python | Size: 280.0 B | Lines: 13
================================================================================
"""
Sensor modules for ROS 2 robot
"""

from .lidar import LidarSensor, get_lidar_sensor
from .thermal_camera import ThermalCameraSensor, get_thermal_camera_sensor

__all__ = [
    'LidarSensor',
    'get_lidar_sensor',
    'ThermalCameraSensor',
    'get_thermal_camera_sensor'
]
================================================================================


================================================================================
FILE: backend/sensors/lidar.py
Category: Python | Size: 8.0 KB | Lines: 243
================================================================================
#!/usr/bin/env python3
"""
Lidar sensor module for ROS 2
Handles lidar data subscription and processing
"""

import json
import logging
import threading
import time
from typing import Dict, Any, Optional, Callable, List
import numpy as np
from websocket import create_connection

logger = logging.getLogger(__name__)

class LidarSensor:
    """Subscribe to and process lidar scan data via ROSBridge"""
    
    def __init__(self, ros_bridge):
        """
        Initialize lidar sensor
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.scan_callback = None
        self.latest_scan = None
        self.subscription_active = False
        self._ws = None
        self._ws_thread = None
        self._stop_thread = False
        
    def subscribe(self, callback: Optional[Callable] = None, 
                 processed_data: bool = True) -> bool:
        """
        Subscribe to /scan topic
        
        Args:
            callback: Optional callback function for new scan data
            processed_data: If True, return processed data; if False, return raw
        
        Returns:
            bool: Success status
        """
        try:
            # Create a dedicated connection for subscription
            self._ws = create_connection(self.ros_bridge.url, timeout=5)
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": "/scan",
                "type": "sensor_msgs/LaserScan"
            }
            
            self._ws.send(json.dumps(subscribe_msg))
            logger.info("Subscribed to /scan topic")
            
            # Start receiving thread
            self.subscription_active = True
            self._stop_thread = False
            self._ws_thread = threading.Thread(
                target=self._receive_scan_data, 
                args=(callback, processed_data)
            )
            self._ws_thread.daemon = True
            self._ws_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to scan: {e}")
            return False
    
    def _receive_scan_data(self, callback, processed_data):
        """Receive scan data in separate thread"""
        while self.subscription_active and not self._stop_thread:
            try:
                response = self._ws.recv()
                data = json.loads(response)
                
                if data.get("op") == "publish" and data.get("topic") == "/scan":
                    msg = data["msg"]
                    
                    if processed_data:
                        # Process the data for easier use
                        processed = self._process_scan_data(msg)
                        self.latest_scan = processed
                        
                        if callback:
                            callback(processed)
                    else:
                        # Return raw data
                        self.latest_scan = msg
                        
                        if callback:
                            callback(msg)
                            
            except Exception as e:
                if self.subscription_active:
                    logger.error(f"Error receiving scan data: {e}")
                break
        
        if self._ws:
            self._ws.close()
        logger.info("Scan subscription thread ended")
    
    def _process_scan_data(self, scan_msg: Dict) -> Dict[str, Any]:
        """
        Process raw scan data into more useful format
        
        Args:
            scan_msg: Raw LaserScan message
            
        Returns:
            Dict with processed data including points for visualization
        """
        ranges = scan_msg["ranges"]
        angle_min = scan_msg["angle_min"]
        angle_increment = scan_msg["angle_increment"]
        
        # Filter out invalid readings (0.0 or inf)
        valid_ranges = [(i, r) for i, r in enumerate(ranges) 
                       if r > 0.1 and r < 10.0]
        
        if not valid_ranges:
            return {
                "min_distance": float('inf'),
                "min_angle": 0,
                "obstacles": [],
                "safe_directions": ["all"],
                "points": [],
                "timestamp": time.time(),
                "point_count": 0
            }
        
        # Find minimum distance
        min_idx, min_dist = min(valid_ranges, key=lambda x: x[1])
        min_angle = angle_min + min_idx * angle_increment
        
        # Convert to cartesian coordinates for visualization
        points = []
        obstacles = []
        
        for idx, dist in valid_ranges:
            angle = angle_min + idx * angle_increment
            x = dist * np.cos(angle)
            y = dist * np.sin(angle)
            
            points.append({
                "x": float(x),
                "y": float(y),
                "r": float(dist),
                "theta": float(angle),
                "theta_deg": float(np.degrees(angle))
            })
            
            # Detect obstacles (anything closer than 0.5m)
            if dist < 0.5:
                obstacles.append({
                    "angle": float(angle),
                    "angle_deg": float(np.degrees(angle)),
                    "distance": float(dist),
                    "x": float(x),
                    "y": float(y)
                })
        
        # Determine safe directions
        safe_directions = self._calculate_safe_directions(valid_ranges, angle_min, angle_increment)
        
        return {
            "min_distance": float(min_dist),
            "min_angle": float(min_angle),
            "min_angle_deg": float(np.degrees(min_angle)),
            "obstacles": obstacles,
            "safe_directions": safe_directions,
            "obstacle_count": len(obstacles),
            "points": points,
            "point_count": len(points),
            "timestamp": time.time()
        }
    
    def _calculate_safe_directions(self, valid_ranges, angle_min, angle_increment):
        """Calculate safe movement directions based on scan data"""
        safe_directions = []
        
        # Check sectors (front, left, right, back)
        sectors = {
            "front": (-30, 30),
            "left": (60, 120),
            "right": (-120, -60),
            "back": (150, 180)  # and (-180, -150)
        }
        
        for direction, (start_deg, end_deg) in sectors.items():
            start_rad = np.radians(start_deg)
            end_rad = np.radians(end_deg)
            
            # Check if sector is clear
            sector_clear = True
            for idx, dist in valid_ranges:
                angle = angle_min + idx * angle_increment
                
                # Handle back sector wraparound
                if direction == "back":
                    if (angle > np.radians(150) or angle < np.radians(-150)):
                        if dist < 0.5:
                            sector_clear = False
                            break
                else:
                    if start_rad <= angle <= end_rad and dist < 0.5:
                        sector_clear = False
                        break
            
            if sector_clear:
                safe_directions.append(direction)
        
        return safe_directions
    
    def get_latest_scan(self) -> Optional[Dict[str, Any]]:
        """Get the most recent scan data"""
        return self.latest_scan
    
    def unsubscribe(self):
        """Stop subscription"""
        self.subscription_active = False
        self._stop_thread = True
        if self._ws_thread:
            self._ws_thread.join(timeout=2)
        logger.info("Unsubscribed from scan topic")

# Singleton instance
_lidar_sensor = None

def get_lidar_sensor():
    """Get or create LidarSensor instance"""
    global _lidar_sensor
    if _lidar_sensor is None:
        from backend.ros_bridge import get_ros_bridge
        _lidar_sensor = LidarSensor(get_ros_bridge())
    return _lidar_sensor
================================================================================


================================================================================
FILE: backend/sensors/thermal_camera.py
Category: Python | Size: 7.7 KB | Lines: 222
================================================================================
#!/usr/bin/env python3
"""
Thermal camera sensor module for MLX90640
Handles thermal data subscription and processing
"""

import json
import logging
import threading
import time
from typing import Dict, Any, Optional, Callable
import numpy as np
from websocket import create_connection

logger = logging.getLogger(__name__)

class ThermalCameraSensor:
    """Subscribe to and process thermal camera data via ROSBridge"""
    
    def __init__(self, ros_bridge):
        """
        Initialize thermal camera sensor
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.thermal_callback = None
        self.latest_frame = None
        self.subscription_active = False
        self._ws = None
        self._ws_thread = None
        self._stop_thread = False
        
    def subscribe(self, callback: Optional[Callable] = None) -> bool:
        """
        Subscribe to /thermal_frame topic
        
        Args:
            callback: Optional callback function for new thermal data
        
        Returns:
            bool: Success status
        """
        try:
            # Create a dedicated connection for subscription
            self._ws = create_connection(self.ros_bridge.url, timeout=5)
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": "/thermal_frame",
                "type": "mlx90640_interfaces/ThermalFrame"
            }
            
            self._ws.send(json.dumps(subscribe_msg))
            logger.info("Subscribed to /thermal_frame topic")
            
            # Start receiving thread
            self.subscription_active = True
            self._stop_thread = False
            self._ws_thread = threading.Thread(
                target=self._receive_thermal_data, 
                args=(callback,)
            )
            self._ws_thread.daemon = True
            self._ws_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to thermal camera: {e}")
            return False
    
    def _receive_thermal_data(self, callback):
        """Receive thermal data in separate thread"""
        while self.subscription_active and not self._stop_thread:
            try:
                response = self._ws.recv()
                data = json.loads(response)
                
                if data.get("op") == "publish" and data.get("topic") == "/thermal_frame":
                    msg = data["msg"]
                    
                    # Process the thermal frame data
                    processed = self._process_thermal_data(msg)
                    self.latest_frame = processed
                    
                    if callback:
                        callback(processed)
                        
            except Exception as e:
                if self.subscription_active:
                    logger.error(f"Error receiving thermal data: {e}")
                break
        
        if self._ws:
            self._ws.close()
        logger.info("Thermal camera subscription thread ended")
    
    def _process_thermal_data(self, frame_msg: Dict) -> Dict[str, Any]:
        """
        Process raw thermal frame data for visualization
        
        Args:
            frame_msg: Raw ThermalFrame message
            
        Returns:
            Dict with processed data including heatmap
        """
        try:
            # Extract frame data
            width = frame_msg.get("width", 32)
            height = frame_msg.get("height", 24)
            data = frame_msg.get("data", [])
            
            # Reshape to 2D array
            thermal_array = np.array(data).reshape((height, width))
            
            # Calculate temperature ranges for better visualization
            min_temp = frame_msg.get("min_temp", 20.0)
            max_temp = frame_msg.get("max_temp", 30.0)
            avg_temp = frame_msg.get("avg_temp", 25.0)
            center_temp = frame_msg.get("center_temp", 25.0)
            
            # Normalize data to 0-255 for color mapping
            if max_temp > min_temp:
                normalized = ((thermal_array - min_temp) / (max_temp - min_temp) * 255).astype(np.uint8)
            else:
                normalized = np.full((height, width), 128, dtype=np.uint8)
            
            # Find hotspots (temperatures above average + threshold)
            threshold = (max_temp - min_temp) * 0.7 + min_temp
            hotspots = []
            for y in range(height):
                for x in range(width):
                    if thermal_array[y, x] > threshold:
                        hotspots.append({
                            "x": x,
                            "y": y,
                            "temp": float(thermal_array[y, x])
                        })
            
            # Convert to list for JSON serialization
            thermal_list = thermal_array.tolist()
            normalized_list = normalized.tolist()
            
            return {
                "width": width,
                "height": height,
                "thermal_data": thermal_list,
                "normalized_data": normalized_list,
                "min_temp": min_temp,
                "max_temp": max_temp,
                "avg_temp": avg_temp,
                "center_temp": center_temp,
                "frame_count": frame_msg.get("frame_count", 0),
                "hotspots": hotspots,
                "hotspot_count": len(hotspots),
                "timestamp": time.time()
            }
            
        except Exception as e:
            logger.error(f"Error processing thermal data: {e}")
            return {
                "width": 32,
                "height": 24,
                "thermal_data": [[20.0] * 32 for _ in range(24)],
                "normalized_data": [[128] * 32 for _ in range(24)],
                "min_temp": 20.0,
                "max_temp": 30.0,
                "avg_temp": 25.0,
                "center_temp": 25.0,
                "frame_count": 0,
                "hotspots": [],
                "hotspot_count": 0,
                "timestamp": time.time()
            }
    
    def get_latest_frame(self) -> Optional[Dict[str, Any]]:
        """Get the most recent thermal frame data"""
        return self.latest_frame
    
    def get_thermal_frame_once(self) -> Optional[Dict[str, Any]]:
        """Request a single thermal frame via service call"""
        try:
            # Call the get_thermal_frame service
            success, response = self.ros_bridge.call_service(
                "/get_thermal_frame",
                {},
                "get_thermal_frame"
            )
            
            if success and response.get("values", {}).get("success"):
                frame_data = response["values"]["frame"]
                return self._process_thermal_data(frame_data)
            else:
                logger.error("Failed to get thermal frame via service")
                return None
                
        except Exception as e:
            logger.error(f"Error calling thermal frame service: {e}")
            return None
    
    def unsubscribe(self):
        """Stop subscription"""
        self.subscription_active = False
        self._stop_thread = True
        if self._ws_thread:
            self._ws_thread.join(timeout=2)
        logger.info("Unsubscribed from thermal camera topic")

# Singleton instance
_thermal_camera_sensor = None

def get_thermal_camera_sensor():
    """Get or create ThermalCameraSensor instance"""
    global _thermal_camera_sensor
    if _thermal_camera_sensor is None:
        from backend.ros_bridge import get_ros_bridge
        _thermal_camera_sensor = ThermalCameraSensor(get_ros_bridge())
    return _thermal_camera_sensor
================================================================================


================================================================================
FILE: run.py
Category: Python | Size: 341.0 B | Lines: 16
================================================================================
#!/usr/bin/env python3
"""
Main entry point for the ROS 2 Motor Control application
Run this file to start the Flask backend server
"""

import sys
from pathlib import Path

# Add the current directory to Python path
sys.path.insert(0, str(Path(__file__).parent))

from backend.host_backend import main

if __name__ == '__main__':
    main()
================================================================================


================================================================================
FILE: frontend/templates/aiming_system.html
Category: Web | Size: 23.6 KB | Lines: 725
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aiming System - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 40px 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin-bottom: 40px;
        }

        .servo-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 400px;
        }

        .servo-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
        }

        .servo-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .servo-title {
            font-size: 1.5em;
            font-weight: 500;
            color: #00aaff;
        }

        .servo-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            background: #333;
            color: #888;
            transition: all 0.3s ease;
        }

        .servo-status.active {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .angle-control {
            margin-top: auto;
        }

        .angle-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            color: #aaa;
        }

        .angle-value {
            font-size: 2.5em;
            font-weight: 700;
            color: #00ff88;
            min-width: 120px;
            text-align: right;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .angle-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            transition: all 0.3s ease;
        }

        /* Add tick marks for discrete positions */
        .angle-slider {
            background-image: linear-gradient(to right, 
                #444 0%, #444 1px,
                transparent 1px, transparent 20%,
                #444 20%, #444 21%,
                transparent 21%, transparent 40%,
                #444 40%, #444 41%,
                transparent 41%, transparent 60%,
                #444 60%, #444 61%,
                transparent 61%, transparent 80%,
                #444 80%, #444 81%,
                transparent 81%, transparent 99%,
                #444 99%, #444 100%
            );
            background-size: 100% 100%;
            background-repeat: no-repeat;
        }

        .angle-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .angle-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.7);
        }

        .angle-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .angle-marks {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            padding: 0 12px;
        }

        .angle-mark {
            font-size: 0.75em;
            color: #666;
            text-align: center;
            position: relative;
        }

        .preset-panel {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            text-align: center;
        }

        .preset-title {
            font-size: 1.5em;
            font-weight: 500;
            color: #00aaff;
            margin-bottom: 30px;
        }

        .preset-btn {
            padding: 15px 25px;
            margin: 8px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 120px;
        }

        .preset-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .center-btn {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            font-size: 1.2em;
            padding: 20px 40px;
            min-width: 150px;
        }

        .center-btn:hover {
            background: linear-gradient(135deg, #ff5555, #dd1111);
            box-shadow: 0 5px 20px rgba(255, 68, 68, 0.4);
        }

        .visualization-panel {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
        }

        .servo-visual {
            width: 300px;
            height: 300px;
            margin: 0 auto 20px;
            position: relative;
            background: radial-gradient(circle at center, #1a1a1a 0%, #0a0a0a 100%);
            border: 2px solid #333;
            border-radius: 15px;
            overflow: hidden;
        }

        .grid-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .safe-zone {
            position: absolute;
            border: 2px dashed #00ff88;
            border-radius: 10px;
            top: 16.67%;
            left: 16.67%;
            width: 66.66%;
            height: 66.66%;
            opacity: 0.3;
        }

        .crosshair {
            position: absolute;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }

        .crosshair::before {
            width: 100%;
            height: 2px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        .crosshair::after {
            width: 2px;
            height: 100%;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair-center {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #00ff88;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        .log-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            border: 1px solid #333;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            background: #252525;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #aaa;
            border-left: 3px solid #444;
        }

        .log-entry.success {
            border-left-color: #00ff88;
            color: #00ff88;
        }

        .log-entry.error {
            border-left-color: #ff4444;
            color: #ff6666;
        }

        @media (max-width: 1200px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .servo-visual {
                width: 250px;
                height: 250px;
            }
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>Aiming System Control Panel</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <span>Connection Status:</span>
        <div class="status-indicator" id="connectionStatus"></div>
        <span id="statusText">Disconnected</span>
    </div>

    <div class="main-container">
        <div class="controls-grid">
            <!-- Pan Control -->
            <div class="servo-card">
                <div class="servo-header">
                    <h2 class="servo-title">Pan Control (Horizontal)</h2>
                    <span class="servo-status" id="panStatus">IDLE</span>
                </div>
                <div class="angle-control">
                    <div class="angle-label">
                        <span>Angle Control</span>
                        <span class="angle-value" id="panValue">135°</span>
                    </div>
                    <input type="range" class="angle-slider" id="panSlider" 
                           min="75" max="195" value="135" step="30">
                    <div class="angle-marks">
                        <span class="angle-mark">75°<br>Left</span>
                        <span class="angle-mark">105°</span>
                        <span class="angle-mark">135°<br>Center</span>
                        <span class="angle-mark">165°</span>
                        <span class="angle-mark">195°<br>Right</span>
                    </div>
                </div>
            </div>

            <!-- Tilt Control -->
            <div class="servo-card">
                <div class="servo-header">
                    <h2 class="servo-title">Tilt Control (Vertical)</h2>
                    <span class="servo-status" id="tiltStatus">IDLE</span>
                </div>
                <div class="angle-control">
                    <div class="angle-label">
                        <span>Angle Control</span>
                        <span class="angle-value" id="tiltValue">135°</span>
                    </div>
                    <input type="range" class="angle-slider" id="tiltSlider" 
                           min="75" max="195" value="135" step="30">
                    <div class="angle-marks">
                        <span class="angle-mark">75°<br>Down</span>
                        <span class="angle-mark">105°</span>
                        <span class="angle-mark">135°<br>Center</span>
                        <span class="angle-mark">165°</span>
                        <span class="angle-mark">195°<br>Up</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Preset Controls -->
        <div class="preset-panel">
            <h2 class="preset-title">Quick Position Presets</h2>
            <div style="margin-bottom: 20px;">
                <button class="preset-btn" onclick="moveToPreset(135, 195)">↑ UP</button>
            </div>
            <div style="margin-bottom: 20px;">
                <button class="preset-btn" onclick="moveToPreset(75, 135)">← LEFT</button>
                <button class="preset-btn center-btn" onclick="moveToCenter()">CENTER</button>
                <button class="preset-btn" onclick="moveToPreset(195, 135)">RIGHT →</button>
            </div>
            <div>
                <button class="preset-btn" onclick="moveToPreset(135, 75)">↓ DOWN</button>
            </div>
        </div>

        <!-- Visualization -->
        <div class="visualization-panel" style="margin-top: 30px;">
            <h2 class="servo-title" style="text-align: center; margin-bottom: 20px;">Position Visualization</h2>
            <div class="servo-visual">
                <div class="grid-lines"></div>
                <div class="safe-zone"></div>
                <div class="crosshair" id="crosshair" style="left: 50%; top: 50%;">
                    <div class="crosshair-center"></div>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <h3 style="margin-bottom: 10px; color: #888;">Activity Log</h3>
            <div id="logContainer"></div>
        </div>
    </div>

    <script>
        let socket = null;
        let isConnected = false;

        // Add log entry
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // Keep only last 10 entries
            while (logContainer.children.length > 10) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Initialize Socket.IO connection
        function connectWebSocket() {
            socket = io();

            socket.on('connect', function() {
                console.log('Socket.IO connected');
                isConnected = true;
                updateConnectionStatus(true);
                addLog('Connected to servo controller', 'success');
                
                // Request initial servo state
                socket.emit('request_servo_state');
            });

            socket.on('servo_state', function(data) {
                updateServoState(data);
            });

            socket.on('servo_response', function(data) {
                console.log('Servo response:', data);
                if (data.result && !data.result.success) {
                    addLog(`Error: ${data.result.error}`, 'error');
                }
            });

            socket.on('servo_error', function(data) {
                console.error('Servo error:', data);
                addLog(`Error: ${data.error}`, 'error');
            });

            socket.on('disconnect', function() {
                console.log('Socket.IO disconnected');
                isConnected = false;
                updateConnectionStatus(false);
                addLog('Connection lost - Reconnecting...', 'error');
            });

            socket.on('connect_error', function(error) {
                console.error('Socket.IO connection error:', error);
                updateConnectionStatus(false);
            });
        }

        // Update connection status display
        function updateConnectionStatus(connected) {
            const statusIndicator = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                statusIndicator.classList.add('connected');
                statusText.textContent = 'Connected';
            } else {
                statusIndicator.classList.remove('connected');
                statusText.textContent = 'Disconnected';
            }
        }

        // Update servo state from WebSocket data
        function updateServoState(data) {
            // Update displays
            document.getElementById('panValue').textContent = `${Math.round(data.pan_angle)}°`;
            document.getElementById('tiltValue').textContent = `${Math.round(data.tilt_angle)}°`;
            
            // Update status
            const panStatus = document.getElementById('panStatus');
            const tiltStatus = document.getElementById('tiltStatus');
            
            if (data.pan_moving) {
                panStatus.textContent = 'MOVING';
                panStatus.classList.add('active');
            } else {
                panStatus.textContent = 'IDLE';
                panStatus.classList.remove('active');
            }
            
            if (data.tilt_moving) {
                tiltStatus.textContent = 'MOVING';
                tiltStatus.classList.add('active');
            } else {
                tiltStatus.textContent = 'IDLE';
                tiltStatus.classList.remove('active');
            }
            
            // Update sliders if not being dragged
            if (!document.getElementById('panSlider').matches(':active')) {
                // Snap to nearest discrete value
                const panSnapped = Math.round(data.pan_angle / 30) * 30;
                document.getElementById('panSlider').value = panSnapped;
                updateSliderBackground('panSlider', panSnapped);
            }
            
            if (!document.getElementById('tiltSlider').matches(':active')) {
                // Snap to nearest discrete value
                const tiltSnapped = Math.round(data.tilt_angle / 30) * 30;
                document.getElementById('tiltSlider').value = tiltSnapped;
                updateSliderBackground('tiltSlider', tiltSnapped);
            }
            
            // Update visualization
            updateCrosshair(data.pan_angle, data.tilt_angle);
        }

        // Update slider background
        function updateSliderBackground(sliderId, value) {
            const slider = document.getElementById(sliderId);
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const percentage = ((value - min) / (max - min)) * 100;
            slider.style.background = `linear-gradient(to right, #00ff88 ${percentage}%, #2a2a2a ${percentage}%)`;
        }

        // Update crosshair position
        function updateCrosshair(pan, tilt) {
            const crosshair = document.getElementById('crosshair');
            
            // Map angles to percentages (75-195 degrees to 0-100%)
            const panPercent = ((pan - 75) / 120) * 100;
            const tiltPercent = 100 - ((tilt - 75) / 120) * 100; // Invert for visual
            
            crosshair.style.left = `${panPercent}%`;
            crosshair.style.top = `${tiltPercent}%`;
        }

        // Send servo command
        function sendServoCommand(pan, tilt) {
            if (!isConnected || !socket) return;
            
            socket.emit('servo_command', {
                type: 'servo_command',
                action: 'move',
                pan_angle: parseFloat(pan),
                tilt_angle: parseFloat(tilt)
            });
            
            addLog(`Command sent: Pan ${pan}°, Tilt ${tilt}°`, 'success');
        }

        // Preset movements
        function moveToPreset(pan, tilt) {
            document.getElementById('panSlider').value = pan;
            document.getElementById('tiltSlider').value = tilt;
            updateSliderBackground('panSlider', pan);
            updateSliderBackground('tiltSlider', tilt);
            sendServoCommand(pan, tilt);
        }

        function moveToCenter() {
            moveToPreset(135, 135);
        }

        // Slider event handlers - only send on change (discrete values)
        document.getElementById('panSlider').addEventListener('input', function(e) {
            const value = parseInt(e.target.value);
            document.getElementById('panValue').textContent = `${value}°`;
            updateSliderBackground('panSlider', value);
        });

        document.getElementById('panSlider').addEventListener('change', function(e) {
            const value = parseInt(e.target.value);
            sendServoCommand(value, document.getElementById('tiltSlider').value);
        });

        document.getElementById('tiltSlider').addEventListener('input', function(e) {
            const value = parseInt(e.target.value);
            document.getElementById('tiltValue').textContent = `${value}°`;
            updateSliderBackground('tiltSlider', value);
        });

        document.getElementById('tiltSlider').addEventListener('change', function(e) {
            const value = parseInt(e.target.value);
            sendServoCommand(document.getElementById('panSlider').value, value);
        });

        // Initialize on page load
        window.addEventListener('load', function() {
            connectWebSocket();
            moveToCenter(); // Start at center position
            updateSliderBackground('panSlider', 135);
            updateSliderBackground('tiltSlider', 135);
            addLog('Aiming system initialized', 'success');
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (socket) {
                socket.disconnect();
            }
        });
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/dashboard_home.html
Category: Web | Size: 25.4 KB | Lines: 776
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Fighting Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 30px;
            text-align: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 3em;
            font-weight: 300;
            letter-spacing: 3px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: gradient 3s ease infinite;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .subtitle {
            color: #888;
            font-size: 1.2em;
            font-weight: 300;
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 60px 20px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .components-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 40px;
            margin-bottom: 60px;
        }

        .component-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .component-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.05) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .component-card:hover::before {
            opacity: 1;
        }

        .component-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7);
            border-color: #555;
        }

        .component-icon {
            font-size: 4em;
            margin-bottom: 20px;
            display: block;
            text-align: center;
        }

        .motor-icon {
            background: linear-gradient(45deg, #00aaff, #0088cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .lidar-icon {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .camera-icon {
            background: linear-gradient(45deg, #ff6b6b, #ff4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .aiming-icon {
            background: linear-gradient(45deg, #ff00ff, #aa00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .sensor-icon {
            background: linear-gradient(45deg, #ffd93d, #ffb300);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .component-title {
            font-size: 2em;
            font-weight: 500;
            margin-bottom: 15px;
            text-align: center;
        }

        .component-description {
            color: #aaa;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .component-status {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .component-status.active {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .component-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .component-card.disabled:hover {
            transform: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .info-section {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 30px;
            margin-top: 40px;
            border: 1px solid #333;
        }

        .info-title {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #00aaff;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .info-item {
            padding: 15px;
            background: #252525;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.2em;
            font-weight: 500;
        }

        .header-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .settings-btn {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        .settings-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: #1a1a1a;
            margin: 10% auto;
            padding: 30px;
            border: 1px solid #333;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .modal-title {
            font-size: 1.8em;
            color: #00aaff;
        }

        .close-btn {
            font-size: 2em;
            color: #888;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-btn:hover {
            color: #fff;
        }

        .settings-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-label {
            color: #aaa;
            font-size: 1.1em;
        }

        .form-input {
            padding: 12px;
            background: #252525;
            border: 1px solid #444;
            border-radius: 8px;
            color: #fff;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #00aaff;
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.3);
        }

        .form-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .btn-secondary {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
        }

        .btn-secondary:hover {
            background: #3a3a3a;
        }

        .connection-info {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid #333;
        }

        .connection-info p {
            margin: 5px 0;
            color: #888;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .components-grid {
                grid-template-columns: 1fr;
            }
            
            .component-icon {
                font-size: 3em;
            }
            
            .modal-content {
                margin: 20% auto;
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Fire Fighting Robot</h1>
        <p class="subtitle">Control & Monitoring Dashboard</p>
        <div class="status-bar">
            <div class="header-controls">
                <div class="status-item">
                    <span>ROS Bridge:</span>
                    <div class="status-indicator" id="rosStatus"></div>
                    <span id="rosStatusText">Disconnected</span>
                </div>
                <button class="settings-btn" onclick="openSettings()">⚙️ Connection Settings</button>
            </div>
            <div class="status-item">
                <span>System:</span>
                <div class="status-indicator connected"></div>
                <span>Online</span>
            </div>
        </div>
    </div>

    <!-- Connection Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Connection Settings</h2>
                <span class="close-btn" onclick="closeSettings()">&times;</span>
            </div>
            <form class="settings-form" onsubmit="saveSettings(event)">
                <div class="form-group">
                    <label class="form-label">Robot IP Address</label>
                    <input type="text" 
                           id="robotIP" 
                           class="form-input" 
                           placeholder="192.168.x.x" 
                           pattern="^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
                           required>
                </div>
                <div class="form-group">
                    <label class="form-label">ROS Bridge Port</label>
                    <input type="number" 
                           id="bridgePort" 
                           class="form-input" 
                           placeholder="9090" 
                           min="1" 
                           max="65535"
                           required>
                </div>
                <div class="connection-info">
                    <p>Current Connection: <span id="currentConnection">Not configured</span></p>
                    <p>Last Connected: <span id="lastConnected">Never</span></p>
                </div>
                <div class="form-buttons">
                    <button type="submit" class="btn btn-primary">Connect</button>
                    <button type="button" class="btn btn-secondary" onclick="closeSettings()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <div class="main-container">
        <div class="components-grid">
            <!-- Motor Control -->
            <div class="component-card" onclick="navigateTo('/motors')">
                <span class="component-icon motor-icon">⚙️</span>
                <h2 class="component-title">Motor Control</h2>
                <p class="component-description">
                    Control all 4 motors independently with forward, backward, and brake modes. 
                    Real-time speed adjustment and emergency stop.
                </p>
                <div class="component-status active">
                    <div class="status-indicator connected"></div>
                    <span>2 Motor Channels Ready</span>
                </div>
            </div>

            <!-- Aiming System -->
            <div class="component-card" onclick="navigateTo('/aiming')">
                <span class="component-icon aiming-icon">🎯</span>
                <h2 class="component-title">Aiming System</h2>
                <p class="component-description">
                    Precision pan/tilt control for targeting system. 
                    Real-time servo positioning with visual feedback.
                </p>
                <div class="component-status" id="aimingStatus">
                    <div class="status-indicator"></div>
                    <span>Click to Activate</span>
                </div>
            </div>

            <!-- Lidar Sensor -->
            <div class="component-card" onclick="navigateTo('/lidar')">
                <span class="component-icon lidar-icon">📡</span>
                <h2 class="component-title">Lidar Sensor</h2>
                <p class="component-description">
                    Real-time 360° environment scanning and obstacle detection. 
                    Visualize surroundings and safe navigation paths.
                </p>
                <div class="component-status" id="lidarStatus">
                    <div class="status-indicator"></div>
                    <span>Click to Activate</span>
                </div>
            </div>

            <!-- Thermal Camera -->
            <div class="component-card" onclick="navigateTo('/thermal')">
                <span class="component-icon camera-icon">🌡️</span>
                <h2 class="component-title">Thermal Camera</h2>
                <p class="component-description">
                    MLX90640 thermal imaging with real-time heatmap visualization. 
                    Monitor temperatures and detect heat signatures.
                </p>
                <div class="component-status" id="thermalStatus">
                    <div class="status-indicator"></div>
                    <span>Click to Activate</span>
                </div>
            </div>

            <!-- Sensors (Future) -->
            <div class="component-card disabled">
                <span class="component-icon sensor-icon">🔥</span>
                <h2 class="component-title">Fire Sensors</h2>
                <p class="component-description">
                    Smoke, flame, and gas sensors for comprehensive fire detection. 
                    Coming soon...
                </p>
                <div class="component-status">
                    <div class="status-indicator"></div>
                    <span>Not Available</span>
                </div>
            </div>
        </div>

        <div class="info-section">
            <h3 class="info-title">System Information</h3>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Robot IP</div>
                    <div class="info-value" id="robotIPInfo">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">ROS Bridge Port</div>
                    <div class="info-value" id="bridgePortInfo">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Active Components</div>
                    <div class="info-value" id="activeComponents">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">System Uptime</div>
                    <div class="info-value" id="uptime">00:00:00</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Navigation function
        function navigateTo(path) {
            window.location.href = path;
        }

        // Connection settings management
        let connectionSettings = {
            robotIP: localStorage.getItem('robotIP') || '192.168.2.1',
            bridgePort: localStorage.getItem('bridgePort') || '9090'
        };

        // Initialize settings on page load
        function initializeSettings() {
            document.getElementById('robotIP').value = connectionSettings.robotIP;
            document.getElementById('bridgePort').value = connectionSettings.bridgePort;
            updateConnectionInfo();
        }

        // Open settings modal
        function openSettings() {
            document.getElementById('settingsModal').style.display = 'block';
            initializeSettings();
        }

        // Close settings modal
        function closeSettings() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        // Save settings and update connection
        async function saveSettings(event) {
            event.preventDefault();
            
            const newIP = document.getElementById('robotIP').value;
            const newPort = document.getElementById('bridgePort').value;
            
            // Save to localStorage
            localStorage.setItem('robotIP', newIP);
            localStorage.setItem('bridgePort', newPort);
            localStorage.setItem('lastConnectAttempt', new Date().toLocaleString());
            
            // Update backend configuration
            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        robot_ip: newIP,
                        rosbridge_port: parseInt(newPort)
                    })
                });
                
                if (response.ok) {
                    connectionSettings.robotIP = newIP;
                    connectionSettings.bridgePort = newPort;
                    
                    // Test the new connection
                    await checkSystemStatus();
                    
                    // Close modal and show success
                    closeSettings();
                    updateConnectionInfo();
                    
                    // Inform user that pages need to be refreshed
                    if (confirm('Connection settings updated. Refresh all open dashboard pages to apply changes?')) {
                        window.location.reload();
                    }
                } else {
                    alert('Failed to update connection settings');
                }
            } catch (error) {
                alert('Error updating settings: ' + error.message);
            }
        }

        // Update connection info display
        function updateConnectionInfo() {
            const currentConn = document.getElementById('currentConnection');
            const lastConn = document.getElementById('lastConnected');
            
            currentConn.textContent = `${connectionSettings.robotIP}:${connectionSettings.bridgePort}`;
            lastConn.textContent = localStorage.getItem('lastConnectAttempt') || 'Never';
        }

        // Check system status with current settings
        async function checkSystemStatus() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                
                // Update ROS connection status
                const rosIndicator = document.getElementById('rosStatus');
                const rosStatusText = document.getElementById('rosStatusText');
                
                if (data.connected) {
                    rosIndicator.classList.add('connected');
                    rosStatusText.textContent = 'Connected';
                    localStorage.setItem('lastSuccessfulConnection', new Date().toLocaleString());
                } else {
                    rosIndicator.classList.remove('connected');
                    rosStatusText.textContent = 'Disconnected';
                }
                
                // Update system info
                if (data.config) {
                    document.getElementById('robotIPInfo').textContent = data.config.robot_ip;
                    document.getElementById('bridgePortInfo').textContent = data.config.rosbridge_port;
                }
                
                // Update component status
                let activeCount = 0;
                if (data.components) {
                    if (data.components.motors) activeCount++;
                    
                    if (data.components.servo) {
                        activeCount++;
                        const aimingStatus = document.getElementById('aimingStatus');
                        aimingStatus.classList.add('active');
                        aimingStatus.innerHTML = '<div class="status-indicator connected"></div><span>Active</span>';
                    }
                    
                    if (data.components.lidar) {
                        activeCount++;
                        const lidarStatus = document.getElementById('lidarStatus');
                        lidarStatus.classList.add('active');
                        lidarStatus.innerHTML = '<div class="status-indicator connected"></div><span>Active</span>';
                    }
                    
                    if (data.components.thermal) {
                        activeCount++;
                        const thermalStatus = document.getElementById('thermalStatus');
                        thermalStatus.classList.add('active');
                        thermalStatus.innerHTML = '<div class="status-indicator connected"></div><span>Active</span>';
                    }
                }
                document.getElementById('activeComponents').textContent = activeCount;
                
            } catch (error) {
                console.error('Error checking status:', error);
                // If the backend isn't responding, show disconnected
                const rosIndicator = document.getElementById('rosStatus');
                const rosStatusText = document.getElementById('rosStatusText');
                rosIndicator.classList.remove('connected');
                rosStatusText.textContent = 'Error';
            }
        }

        // Update uptime
        let startTime = Date.now();
        function updateUptime() {
            const elapsed = Date.now() - startTime;
            const hours = Math.floor(elapsed / 3600000);
            const minutes = Math.floor((elapsed % 3600000) / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            
            document.getElementById('uptime').textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('settingsModal');
            if (event.target == modal) {
                closeSettings();
            }
        }

        // Initialize on page load
        window.onload = function() {
            // Check if this is first time or if settings are missing
            if (!localStorage.getItem('robotIP')) {
                openSettings();
            }
            
            checkSystemStatus();
            setInterval(checkSystemStatus, 5000);
            setInterval(updateUptime, 1000);
        }
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/lidar_visualization.html
Category: Web | Size: 26.8 KB | Lines: 777
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lidar Sensor - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-height: calc(100vh - 200px);
        }

        .visualization-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 1.5em;
            color: #00ff88;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #0a0a0a;
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .control-button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .control-button.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }

        .control-button.danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .info-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-item {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.3em;
            font-weight: 500;
            color: #00ff88;
        }

        .movement-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 200px;
            margin: 20px auto;
        }

        .move-btn {
            padding: 15px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-size: 1.5em;
            transition: all 0.2s ease;
        }

        .move-btn:hover {
            background: #3a3a3a;
            transform: scale(1.1);
        }

        .move-btn:active {
            background: #00ff88;
            transform: scale(0.95);
        }

        .move-btn:nth-child(2) { grid-column: 2; }
        .move-btn:nth-child(4) { grid-column: 1; }
        .move-btn:nth-child(5) { grid-column: 2; }
        .move-btn:nth-child(6) { grid-column: 3; }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>Lidar Sensor Visualization</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span>Lidar Status:</span>
            <div class="status-indicator" id="lidarStatus"></div>
            <span id="lidarStatusText">Disconnected</span>
        </div>
        <div class="status-item">
            <span>Data Rate:</span>
            <span id="dataRate">0 Hz</span>
        </div>
        <div class="status-item">
            <span>Points:</span>
            <span id="pointCount">0</span>
        </div>
    </div>

    <div class="main-container">
        <!-- Polar View -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Live Scan - Polar View</h2>
                <span id="polarFPS">0 FPS</span>
            </div>
            <div class="canvas-container">
                <canvas id="polarCanvas"></canvas>
            </div>
        </div>

        <!-- Occupancy Map -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Occupancy Map</h2>
                <span id="mapFPS">0 FPS</span>
            </div>
            <div class="canvas-container">
                <canvas id="mapCanvas"></canvas>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="control-button" id="startBtn" onclick="startLidar()">Start Scan</button>
        <button class="control-button danger" id="stopBtn" onclick="stopLidar()" disabled>Stop Scan</button>
        <button class="control-button" onclick="clearMap()">Clear Map</button>
        <button class="control-button" onclick="saveMap()">Save Map</button>
        <button class="control-button" id="followRobotBtn" onclick="toggleFollowRobot()">Follow Robot</button>
        <button class="control-button" onclick="resetView()">Reset View</button>
    </div>

    <div class="info-panel">
        <h3 style="color: #00ff88; margin-bottom: 15px;">Scan Information</h3>
        <div class="info-grid">
            <div class="info-item">
                <div class="info-label">Min Distance</div>
                <div class="info-value" id="minDistance">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Min Angle</div>
                <div class="info-value" id="minAngle">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Obstacles</div>
                <div class="info-value" id="obstacleCount">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">Safe Directions</div>
                <div class="info-value" id="safeDirections" style="font-size: 1em;">-</div>
            </div>
        </div>
    </div>

    <div class="controls">
        <h3 style="color: #00ff88; margin-bottom: 15px; text-align: center;">Robot Movement (Simulation)</h3>
        <div class="movement-controls">
            <button class="move-btn" onclick="moveRobot('forward')">↑</button>
            <button class="move-btn" onclick="moveRobot('left')">←</button>
            <button class="move-btn" onclick="moveRobot('stop')">●</button>
            <button class="move-btn" onclick="moveRobot('right')">→</button>
            <button class="move-btn" onclick="moveRobot('backward')">↓</button>
        </div>
    </div>

    <script>
        // WebSocket connection
        const socket = io();
        
        // Canvas contexts
        const polarCanvas = document.getElementById('polarCanvas');
        const polarCtx = polarCanvas.getContext('2d');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');
        
        // State
        let scanning = false;
        let followRobot = true;
        let latestScanData = null;
        
        // Map parameters
        const MAP_SIZE = 100;  // 10m x 10m with 10cm resolution
        const MAP_RESOLUTION = 0.1;  // meters per pixel
        const occupancyMap = new Array(MAP_SIZE * MAP_SIZE).fill(0.5);  // Unknown = 0.5
        
        // Robot state
        let robotX = MAP_SIZE / 2;
        let robotY = MAP_SIZE / 2;
        let robotTheta = 0;
        const robotPath = [];
        
        // Performance monitoring
        let polarFPS = 0;
        let mapFPS = 0;
        let lastPolarUpdate = Date.now();
        let lastMapUpdate = Date.now();
        let polarFrameCount = 0;
        let mapFrameCount = 0;
        let dataRate = 0;
        let lastDataTime = Date.now();
        let dataCount = 0;
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
        });
        
        socket.on('lidar_data', (data) => {
            latestScanData = data;
            updateVisualization(data);
            
            // Update data rate
            dataCount++;
            const now = Date.now();
            if (now - lastDataTime > 1000) {
                dataRate = dataCount;
                dataCount = 0;
                lastDataTime = now;
                document.getElementById('dataRate').textContent = `${dataRate} Hz`;
            }
        });
        
        // Resize canvases
        function resizeCanvases() {
            const containers = document.querySelectorAll('.canvas-container');
            containers.forEach((container, index) => {
                const canvas = container.querySelector('canvas');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            });
        }
        
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();
        
        // Start/Stop lidar
        async function startLidar() {
            try {
                const response = await fetch('/api/lidar/subscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    scanning = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('lidarStatus').classList.add('connected');
                    document.getElementById('lidarStatusText').textContent = 'Connected';
                }
            } catch (error) {
                console.error('Failed to start lidar:', error);
            }
        }
        
        async function stopLidar() {
            try {
                const response = await fetch('/api/lidar/unsubscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    scanning = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                    document.getElementById('lidarStatus').classList.remove('connected');
                    document.getElementById('lidarStatusText').textContent = 'Disconnected';
                }
            } catch (error) {
                console.error('Failed to stop lidar:', error);
            }
        }
        
        // Visualization functions
        function updateVisualization(scanData) {
            // Update info panel
            document.getElementById('minDistance').textContent = `${scanData.min_distance.toFixed(2)}m`;
            document.getElementById('minAngle').textContent = `${scanData.min_angle_deg.toFixed(1)}°`;
            document.getElementById('obstacleCount').textContent = scanData.obstacle_count;
            document.getElementById('safeDirections').textContent = scanData.safe_directions.join(', ') || 'None';
            document.getElementById('pointCount').textContent = scanData.point_count;
            
            // Draw polar view
            drawPolarView(scanData);
            
            // Update occupancy map
            updateOccupancyMap(scanData);
            drawMapView();
        }
        
        function drawPolarView(scanData) {
            const width = polarCanvas.width;
            const height = polarCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) / 2 - 20;
            
            // Clear canvas
            polarCtx.fillStyle = '#0a0a0a';
            polarCtx.fillRect(0, 0, width, height);
            
            // Draw grid
            polarCtx.strokeStyle = '#333';
            polarCtx.lineWidth = 1;
            
            // Concentric circles
            for (let r = 1; r <= 4; r++) {
                polarCtx.beginPath();
                polarCtx.arc(centerX, centerY, (r / 4) * maxRadius, 0, 2 * Math.PI);
                polarCtx.stroke();
                
                // Distance labels
                polarCtx.fillStyle = '#666';
                polarCtx.font = '12px Arial';
                polarCtx.fillText(`${r}m`, centerX + 5, centerY - (r / 4) * maxRadius + 5);
            }
            
            // Radial lines
            for (let angle = 0; angle < 360; angle += 30) {
                const rad = angle * Math.PI / 180;
                polarCtx.beginPath();
                polarCtx.moveTo(centerX, centerY);
                polarCtx.lineTo(
                    centerX + maxRadius * Math.cos(rad),
                    centerY - maxRadius * Math.sin(rad)
                );
                polarCtx.stroke();
            }
            
            // Draw scan points
            if (scanData.points) {
                polarCtx.fillStyle = '#00ff88';
                scanData.points.forEach(point => {
                    if (point.r < 4.0) {  // Only show points within 4m
                        const x = centerX + (point.r / 4) * maxRadius * Math.cos(point.theta);
                        const y = centerY - (point.r / 4) * maxRadius * Math.sin(point.theta);
                        
                        polarCtx.beginPath();
                        polarCtx.arc(x, y, 2, 0, 2 * Math.PI);
                        polarCtx.fill();
                    }
                });
            }
            
            // Draw obstacles
            polarCtx.fillStyle = '#ff4444';
            scanData.obstacles.forEach(obstacle => {
                const x = centerX + (obstacle.distance / 4) * maxRadius * Math.cos(obstacle.angle);
                const y = centerY - (obstacle.distance / 4) * maxRadius * Math.sin(obstacle.angle);
                
                polarCtx.beginPath();
                polarCtx.arc(x, y, 4, 0, 2 * Math.PI);
                polarCtx.fill();
            });
            
            // Draw robot center
            polarCtx.fillStyle = '#00aaff';
            polarCtx.beginPath();
            polarCtx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            polarCtx.fill();
            
            // Update FPS
            polarFrameCount++;
            const now = Date.now();
            if (now - lastPolarUpdate > 1000) {
                polarFPS = polarFrameCount;
                polarFrameCount = 0;
                lastPolarUpdate = now;
                document.getElementById('polarFPS').textContent = `${polarFPS} FPS`;
            }
        }
        
        function updateOccupancyMap(scanData) {
            if (!scanData.points) return;
            
            // Update map with new scan data
            scanData.points.forEach(point => {
                if (point.r > 0 && point.r < 10) {
                    // Ray tracing - mark free space
                    const steps = Math.floor(point.r / MAP_RESOLUTION);
                    for (let step = 0; step < steps; step++) {
                        const r = step * MAP_RESOLUTION;
                        const x = Math.floor(robotX + r * Math.cos(point.theta + robotTheta) / MAP_RESOLUTION);
                        const y = Math.floor(robotY + r * Math.sin(point.theta + robotTheta) / MAP_RESOLUTION);
                        
                        if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
                            const idx = y * MAP_SIZE + x;
                            occupancyMap[idx] = Math.max(0.0, occupancyMap[idx] - 0.02);
                        }
                    }
                    
                    // Mark obstacle
                    if (point.r < 4.0) {
                        const obsX = Math.floor(robotX + point.r * Math.cos(point.theta + robotTheta) / MAP_RESOLUTION);
                        const obsY = Math.floor(robotY + point.r * Math.sin(point.theta + robotTheta) / MAP_RESOLUTION);
                        
                        if (obsX >= 0 && obsX < MAP_SIZE && obsY >= 0 && obsY < MAP_SIZE) {
                            const idx = obsY * MAP_SIZE + obsX;
                            occupancyMap[idx] = Math.min(1.0, occupancyMap[idx] + 0.1);
                        }
                    }
                }
            });
        }
        
        function drawMapView() {
            const width = mapCanvas.width;
            const height = mapCanvas.height;
            const scale = Math.min(width, height) / (MAP_SIZE * MAP_RESOLUTION);
            
            // Clear canvas
            mapCtx.fillStyle = '#0a0a0a';
            mapCtx.fillRect(0, 0, width, height);
            
            // Calculate view offset
            let offsetX = 0;
            let offsetY = 0;
            if (followRobot) {
                offsetX = width / 2 - robotX * MAP_RESOLUTION * scale;
                offsetY = height / 2 - robotY * MAP_RESOLUTION * scale;
            }
            
            mapCtx.save();
            mapCtx.translate(offsetX, offsetY);
            
            // Draw occupancy map
            const imageData = mapCtx.createImageData(MAP_SIZE, MAP_SIZE);
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const idx = y * MAP_SIZE + x;
                    const value = occupancyMap[idx];
                    const pixelIdx = (y * MAP_SIZE + x) * 4;
                    
                    if (value < 0.5) {
                        // Free space - green tint
                        imageData.data[pixelIdx] = 0;
                        imageData.data[pixelIdx + 1] = Math.floor(255 * (0.5 - value) * 2);
                        imageData.data[pixelIdx + 2] = 0;
                    } else if (value > 0.5) {
                        // Obstacle - red tint
                        imageData.data[pixelIdx] = Math.floor(255 * (value - 0.5) * 2);
                        imageData.data[pixelIdx + 1] = 0;
                        imageData.data[pixelIdx + 2] = 0;
                    } else {
                        // Unknown - gray
                        imageData.data[pixelIdx] = 64;
                        imageData.data[pixelIdx + 1] = 64;
                        imageData.data[pixelIdx + 2] = 64;
                    }
                    imageData.data[pixelIdx + 3] = 255;
                }
            }
            
            // Scale and draw map
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = MAP_SIZE;
            tempCanvas.height = MAP_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);
            
            mapCtx.imageSmoothingEnabled = false;
            mapCtx.drawImage(tempCanvas, 0, 0, MAP_SIZE * MAP_RESOLUTION * scale, MAP_SIZE * MAP_RESOLUTION * scale);
            
            // Draw robot path
            if (robotPath.length > 1) {
                mapCtx.strokeStyle = '#00ff8866';
                mapCtx.lineWidth = 2;
                mapCtx.beginPath();
                mapCtx.moveTo(robotPath[0].x * MAP_RESOLUTION * scale, robotPath[0].y * MAP_RESOLUTION * scale);
                for (let i = 1; i < robotPath.length; i++) {
                    mapCtx.lineTo(robotPath[i].x * MAP_RESOLUTION * scale, robotPath[i].y * MAP_RESOLUTION * scale);
                }
                mapCtx.stroke();
            }
            
            // Draw robot
            const robotScreenX = robotX * MAP_RESOLUTION * scale;
            const robotScreenY = robotY * MAP_RESOLUTION * scale;
            
            // Robot body
            mapCtx.fillStyle = '#00aaff';
            mapCtx.beginPath();
            mapCtx.arc(robotScreenX, robotScreenY, 8, 0, 2 * Math.PI);
            mapCtx.fill();
            
            // Robot direction
            mapCtx.strokeStyle = '#00aaff';
            mapCtx.lineWidth = 3;
            mapCtx.beginPath();
            mapCtx.moveTo(robotScreenX, robotScreenY);
            mapCtx.lineTo(
                robotScreenX + 20 * Math.cos(robotTheta),
                robotScreenY + 20 * Math.sin(robotTheta)
            );
            mapCtx.stroke();
            
            mapCtx.restore();
            
            // Draw scale
            mapCtx.fillStyle = '#fff';
            mapCtx.font = '12px Arial';
            mapCtx.fillText('1m', 10, height - 10);
            mapCtx.strokeStyle = '#fff';
            mapCtx.lineWidth = 2;
            mapCtx.beginPath();
            mapCtx.moveTo(10, height - 20);
            mapCtx.lineTo(10 + scale, height - 20);
            mapCtx.stroke();
            
            // Update FPS
            mapFrameCount++;
            const now = Date.now();
            if (now - lastMapUpdate > 1000) {
                mapFPS = mapFrameCount;
                mapFrameCount = 0;
                lastMapUpdate = now;
                document.getElementById('mapFPS').textContent = `${mapFPS} FPS`;
            }
        }
        
        // Control functions
        function clearMap() {
            occupancyMap.fill(0.5);
            robotPath.length = 0;
            robotX = MAP_SIZE / 2;
            robotY = MAP_SIZE / 2;
            robotTheta = 0;
        }
        
        function saveMap() {
            // Convert map to image and download
            const link = document.createElement('a');
            link.download = `lidar_map_${new Date().toISOString()}.png`;
            link.href = mapCanvas.toDataURL();
            link.click();
        }
        
        function toggleFollowRobot() {
            followRobot = !followRobot;
            document.getElementById('followRobotBtn').classList.toggle('active', followRobot);
        }
        
        function resetView() {
            followRobot = true;
            document.getElementById('followRobotBtn').classList.add('active');
        }
        
        // Robot movement (simulation)
        function moveRobot(direction) {
            const moveSpeed = 0.2;  // meters
            const turnSpeed = 0.1;  // radians
            
            switch (direction) {
                case 'forward':
                    robotX += moveSpeed * Math.cos(robotTheta) / MAP_RESOLUTION;
                    robotY += moveSpeed * Math.sin(robotTheta) / MAP_RESOLUTION;
                    break;
                case 'backward':
                    robotX -= moveSpeed * Math.cos(robotTheta) / MAP_RESOLUTION;
                    robotY -= moveSpeed * Math.sin(robotTheta) / MAP_RESOLUTION;
                    break;
                case 'left':
                    robotTheta -= turnSpeed;
                    break;
                case 'right':
                    robotTheta += turnSpeed;
                    break;
            }
            
            // Keep robot in bounds
            robotX = Math.max(0, Math.min(MAP_SIZE - 1, robotX));
            robotY = Math.max(0, Math.min(MAP_SIZE - 1, robotY));
            
            // Add to path
            robotPath.push({ x: robotX, y: robotY });
            if (robotPath.length > 1000) {
                robotPath.shift();
            }
            
            // Redraw if we have scan data
            if (latestScanData) {
                updateVisualization(latestScanData);
            }
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    moveRobot('forward');
                    break;
                case 'ArrowDown':
                case 's':
                    moveRobot('backward');
                    break;
                case 'ArrowLeft':
                case 'a':
                    moveRobot('left');
                    break;
                case 'ArrowRight':
                case 'd':
                    moveRobot('right');
                    break;
            }
        });
        
        // Initialize
        toggleFollowRobot();  // Start with follow robot enabled
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/motor_control.html
Category: Web | Size: 23.3 KB | Lines: 706
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motor Control - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 40px 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 30px;
            margin-bottom: 40px;
        }

        .motor-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 350px;
        }

        .motor-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
        }

        .motor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .motor-title {
            font-size: 1.5em;
            font-weight: 500;
            color: #00aaff;
        }

        .motor-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            background: #333;
            color: #888;
            transition: all 0.3s ease;
        }

        .motor-status.active {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .direction-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .direction-btn {
            padding: 12px 8px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .direction-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .direction-btn.active {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .direction-btn.brake.active {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            box-shadow: 0 5px 20px rgba(255, 68, 68, 0.4);
        }

        .speed-control {
            margin-top: auto;
        }

        /* Speed marks container */
        .speed-marks {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            padding: 0 12px;
        }

        .speed-mark {
            font-size: 0.75em;
            color: #666;
            text-align: center;
            position: relative;
        }

        .speed-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: #aaa;
        }

        .speed-value {
            font-size: 2em;
            font-weight: 700;
            color: #00ff88;
            min-width: 80px;
            text-align: right;
        }

        .speed-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            transition: all 0.3s ease;
        }

        /* Add markers for the 5 positions */
        .speed-slider {
            background-image: linear-gradient(to right, 
                #444 0%, #444 1px,
                transparent 1px, transparent 24.5%,
                #444 24.5%, #444 25.5%,
                transparent 25.5%, transparent 49.5%,
                #444 49.5%, #444 50.5%,
                transparent 50.5%, transparent 74.5%,
                #444 74.5%, #444 75.5%,
                transparent 75.5%, transparent 99%,
                #444 99%, #444 100%
            );
            background-size: 100% 100%;
            background-repeat: no-repeat;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .speed-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.7);
        }

        .speed-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .emergency-stop {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff0000, #cc0000);
            border: 3px solid #ff4444;
            color: white;
            font-size: 1.2em;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(255, 0, 0, 0.5);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 1000;
        }

        .emergency-stop:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(255, 0, 0, 0.7);
        }

        .emergency-stop:active {
            transform: scale(0.95);
        }

        .log-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            border: 1px solid #333;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            background: #252525;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #aaa;
            border-left: 3px solid #444;
        }

        .log-entry.error {
            border-left-color: #ff4444;
            color: #ff6666;
        }

        .log-entry.success {
            border-left-color: #00ff88;
            color: #00ff88;
        }

        /* Responsive design */
        @media (max-width: 1600px) {
            .controls-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 900px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .emergency-stop {
                width: 80px;
                height: 80px;
                font-size: 1em;
                bottom: 20px;
                right: 20px;
            }

            .direction-controls {
                grid-template-columns: 1fr;
                gap: 8px;
            }
        }

        /* For ultra-wide displays */
        @media (min-width: 2000px) {
            .main-container {
                max-width: 1900px;
            }
            
            .motor-card {
                padding: 35px;
                min-height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ROS 2 Motor Control Panel</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <span>Connection Status:</span>
        <div class="status-indicator" id="connectionStatus"></div>
        <span id="statusText">Disconnected</span>
    </div>

    <div class="main-container">
        <div class="controls-grid">
            <!-- Left Motors -->
            <div class="motor-card" data-motor="0">
                <div class="motor-header">
                    <h2 class="motor-title">Left Motors</h2>
                    <span class="motor-status">IDLE</span>
                </div>
                <div class="direction-controls">
                    <button class="direction-btn" data-direction="forward">Forward</button>
                    <button class="direction-btn" data-direction="backward">Backward</button>
                    <button class="direction-btn brake" data-direction="brake">Brake</button>
                </div>
                <div class="speed-control">
                    <div class="speed-label">
                        <span>Speed Control</span>
                        <span class="speed-value">0%</span>
                    </div>
                    <input type="range" class="speed-slider" min="0" max="100" value="0" step="25">
                    <div class="speed-marks">
                        <span class="speed-mark">0%</span>
                        <span class="speed-mark">25%</span>
                        <span class="speed-mark">50%</span>
                        <span class="speed-mark">75%</span>
                        <span class="speed-mark">100%</span>
                    </div>
                </div>
            </div>

            <!-- Right Motors -->
            <div class="motor-card" data-motor="1">
                <div class="motor-header">
                    <h2 class="motor-title">Right Motors</h2>
                    <span class="motor-status">IDLE</span>
                </div>
                <div class="direction-controls">
                    <button class="direction-btn" data-direction="forward">Forward</button>
                    <button class="direction-btn" data-direction="backward">Backward</button>
                    <button class="direction-btn brake" data-direction="brake">Brake</button>
                </div>
                <div class="speed-control">
                    <div class="speed-label">
                        <span>Speed Control</span>
                        <span class="speed-value">0%</span>
                    </div>
                    <input type="range" class="speed-slider" min="0" max="100" value="0" step="25">
                    <div class="speed-marks">
                        <span class="speed-mark">0%</span>
                        <span class="speed-mark">25%</span>
                        <span class="speed-mark">50%</span>
                        <span class="speed-mark">75%</span>
                        <span class="speed-mark">100%</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <h3 style="margin-bottom: 10px; color: #888;">Activity Log</h3>
            <div id="logContainer"></div>
        </div>
    </div>

    <button class="emergency-stop" id="emergencyStop">STOP<br>ALL</button>

    <script>
        // Motor control state
        const motorStates = {
            0: { direction: 'brake', speed: 0 },  // Left motors
            1: { direction: 'brake', speed: 0 }   // Right motors
        };

        // Command throttling
        let commandQueue = [];
        let isProcessing = false;
        const COMMAND_DELAY = 100; // 100ms between commands

        // Add log entry
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // Keep only last 10 entries
            while (logContainer.children.length > 10) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Process command queue
        async function processCommandQueue() {
            if (isProcessing || commandQueue.length === 0) return;
            
            isProcessing = true;
            const command = commandQueue.shift();
            
            try {
                const response = await fetch(`/api/motor/${command.motorId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        direction: command.direction,
                        speed: command.speed
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    addLog(`Motor ${command.motorId}: ${command.direction} at ${command.speed}%`, 'success');
                } else {
                    addLog(`Motor ${command.motorId} error: ${data.error}`, 'error');
                }
            } catch (error) {
                addLog(`Motor ${command.motorId} error: ${error.message}`, 'error');
            }
            
            // Wait before processing next command
            setTimeout(() => {
                isProcessing = false;
                processCommandQueue();
            }, COMMAND_DELAY);
        }

        // Queue motor command
        function queueMotorCommand(motorId, direction, speed) {
            // Remove any pending commands for this motor
            commandQueue = commandQueue.filter(cmd => cmd.motorId !== motorId);
            
            // Add new command
            commandQueue.push({ motorId, direction, speed });
            
            // Start processing
            processCommandQueue();
        }

        // Send motor command with direction change protection
        async function sendMotorCommand(motorId, direction, speed) {
            const lastDir = motorStates[motorId].direction;
            
            // If changing from forward to backward or vice versa, insert brake command
            if ((lastDir === 'forward' && direction === 'backward') ||
                (lastDir === 'backward' && direction === 'forward')) {
                // Queue brake first
                queueMotorCommand(motorId, 'brake', 0);
                // Then queue the new direction after a delay
                setTimeout(() => {
                    queueMotorCommand(motorId, direction, speed);
                }, 150);
            } else {
                // Direct command
                queueMotorCommand(motorId, direction, speed);
            }
            
            // Update state
            motorStates[motorId].direction = direction;
            motorStates[motorId].speed = speed;
        }

        // Check connection status
        async function checkConnection() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                const indicator = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                
                if (data.connected) {
                    indicator.classList.add('connected');
                    statusText.textContent = 'Connected';
                } else {
                    indicator.classList.remove('connected');
                    statusText.textContent = 'Disconnected';
                }
            } catch (error) {
                const indicator = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                indicator.classList.remove('connected');
                statusText.textContent = 'Error';
            }
        }

        // Update motor UI
        function updateMotorUI(motorId) {
            const motorCard = document.querySelector(`[data-motor="${motorId}"]`);
            const state = motorStates[motorId];
            
            // Update direction buttons
            const directionBtns = motorCard.querySelectorAll('.direction-btn');
            directionBtns.forEach(btn => {
                if (btn.dataset.direction === state.direction) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Update status
            const status = motorCard.querySelector('.motor-status');
            if (state.direction === 'brake') {
                status.textContent = 'BRAKE';
                status.classList.remove('active');
            } else {
                status.textContent = state.direction.toUpperCase();
                status.classList.add('active');
            }
            
            // Update speed display
            const speedValue = motorCard.querySelector('.speed-value');
            speedValue.textContent = `${state.speed}%`;
            
            // Update slider
            const slider = motorCard.querySelector('.speed-slider');
            slider.value = state.speed;
            
            // Update slider background to show progress
            const percentage = state.speed / 100;
            slider.style.background = `linear-gradient(to right, #00ff88 ${percentage * 100}%, #2a2a2a ${percentage * 100}%)`;
        }

        // Initialize motor controls
        document.querySelectorAll('.motor-card').forEach(motorCard => {
            const motorId = parseInt(motorCard.dataset.motor);
            
            // Direction buttons
            motorCard.querySelectorAll('.direction-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const direction = btn.dataset.direction;
                    motorStates[motorId].direction = direction;
                    
                    // If brake, set speed to 0
                    if (direction === 'brake') {
                        motorStates[motorId].speed = 0;
                    }
                    
                    updateMotorUI(motorId);
                    await sendMotorCommand(motorId, direction, motorStates[motorId].speed);
                });
            });
            
            // Speed slider with throttling
            const slider = motorCard.querySelector('.speed-slider');
            let sliderTimeout;
            
            slider.addEventListener('input', (e) => {
                // IMPORTANT: Invert the slider value
                // Slider shows 0-100 left to right, but we need to send inverted values
                const sliderValue = parseInt(e.target.value);
                motorStates[motorId].speed = sliderValue;
                
                // Update UI immediately
                updateMotorUI(motorId);
                
                // Clear any existing timeout
                clearTimeout(sliderTimeout);
                
                // Only send command on discrete values (0, 25, 50, 75, 100)
                if ([0, 25, 50, 75, 100].includes(sliderValue)) {
                    // Send command immediately for discrete values
                    if (motorStates[motorId].direction !== 'brake') {
                        sendMotorCommand(motorId, motorStates[motorId].direction, sliderValue);
                    }
                }
            });
            
            // Also handle change event for when user releases the slider
            slider.addEventListener('change', (e) => {
                const sliderValue = parseInt(e.target.value);
                if (motorStates[motorId].direction !== 'brake') {
                    sendMotorCommand(motorId, motorStates[motorId].direction, sliderValue);
                }
            });
        });

        // Emergency stop button
        document.getElementById('emergencyStop').addEventListener('click', async () => {
            addLog('EMERGENCY STOP ACTIVATED!', 'error');
            
            // Clear command queue
            commandQueue = [];
            
            try {
                const response = await fetch('/api/motors/stop', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Reset only 2 motors
                    for (let i = 0; i < 2; i++) {
                        motorStates[i] = { direction: 'brake', speed: 0 };
                        updateMotorUI(i);
                    }
                    addLog('All motors stopped', 'success');
                } else {
                    addLog('Emergency stop failed!', 'error');
                }
            } catch (error) {
                addLog(`Emergency stop error: ${error.message}`, 'error');
            }
        });

        // Initial setup
        checkConnection();
        setInterval(checkConnection, 5000); // Check connection every 5 seconds
        
        // Initialize UI
        for (let i = 0; i < 2; i++) {
            updateMotorUI(i);
        }
        
        addLog('Motor control panel initialized', 'success');
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: frontend/templates/thermal_camera.html
Category: Web | Size: 20.0 KB | Lines: 606
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thermal Camera - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-height: calc(100vh - 200px);
        }

        .visualization-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 1.5em;
            color: #ff6b6b;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #0a0a0a;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
            image-rendering: pixelated;
        }

        .controls {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .control-button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .control-button.active {
            background: linear-gradient(135deg, #ff6b6b, #ff4444);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
        }

        .info-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #333;
            margin-top: 20px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-item {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.3em;
            font-weight: 500;
            color: #ff6b6b;
        }

        .temperature-scale {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            background: #252525;
            border-radius: 10px;
        }

        .scale-gradient {
            flex: 1;
            height: 20px;
            border-radius: 5px;
            background: linear-gradient(to right, 
                #000080, #0000ff, #00ffff, #00ff00, 
                #ffff00, #ff8800, #ff0000, #ffffff);
        }

        .scale-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.8em;
            color: #888;
        }

        .hotspot-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .hotspot-item {
            background: #252525;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #ff6b6b;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>Thermal Camera Visualization</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span>Camera Status:</span>
            <div class="status-indicator" id="thermalStatus"></div>
            <span id="thermalStatusText">Disconnected</span>
        </div>
        <div class="status-item">
            <span>Frame Rate:</span>
            <span id="frameRate">0 FPS</span>
        </div>
        <div class="status-item">
            <span>Frame Count:</span>
            <span id="frameCount">0</span>
        </div>
    </div>

    <div class="main-container">
        <!-- Thermal Heatmap -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Thermal Heatmap</h2>
                <span id="heatmapSize">32x24</span>
            </div>
            <div class="canvas-container">
                <canvas id="thermalCanvas"></canvas>
            </div>
            <div class="temperature-scale">
                <span id="minTempLabel">20°C</span>
                <div class="scale-gradient"></div>
                <span id="maxTempLabel">30°C</span>
            </div>
        </div>

        <!-- Analysis Panel -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Thermal Analysis</h2>
            </div>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Min Temperature</div>
                    <div class="info-value" id="minTemp">-°C</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Max Temperature</div>
                    <div class="info-value" id="maxTemp">-°C</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Average</div>
                    <div class="info-value" id="avgTemp">-°C</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Center</div>
                    <div class="info-value" id="centerTemp">-°C</div>
                </div>
            </div>
            
            <div style="margin-top: 20px;">
                <h3 style="color: #ff6b6b; margin-bottom: 10px;">Hotspot Detection</h3>
                <div class="info-item">
                    <div class="info-label">Hotspots Detected</div>
                    <div class="info-value" id="hotspotCount">0</div>
                </div>
                <div class="hotspot-list" id="hotspotList"></div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="control-button" id="startBtn" onclick="startThermal()">Start Stream</button>
        <button class="control-button" id="stopBtn" onclick="stopThermal()" disabled>Stop Stream</button>
        <button class="control-button" onclick="captureFrame()">Capture Frame</button>
        <button class="control-button" onclick="saveImage()">Save Image</button>
        <button class="control-button" id="autoScaleBtn" onclick="toggleAutoScale()">Auto Scale: ON</button>
        <button class="control-button" onclick="resetView()">Reset View</button>
    </div>

    <script>
        // WebSocket connection
        const socket = io();
        
        // Canvas and context
        const canvas = document.getElementById('thermalCanvas');
        const ctx = canvas.getContext('2d');
        
        // State
        let streaming = false;
        let autoScale = true;
        let latestFrameData = null;
        
        // Performance monitoring
        let frameCount = 0;
        let lastFPSUpdate = Date.now();
        let fps = 0;
        
        // Temperature range for manual scaling
        let manualMinTemp = 20;
        let manualMaxTemp = 35;
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
        });
        
        socket.on('thermal_data', (data) => {
            latestFrameData = data;
            updateVisualization(data);
            
            // Update frame count and FPS
            frameCount++;
            const now = Date.now();
            if (now - lastFPSUpdate > 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFPSUpdate = now;
                document.getElementById('frameRate').textContent = `${fps} FPS`;
            }
        });
        
        // Color mapping function
        function temperatureToColor(temp, minTemp, maxTemp) {
            // Normalize temperature to 0-1 range
            const normalized = (temp - minTemp) / (maxTemp - minTemp);
            const clamped = Math.max(0, Math.min(1, normalized));
            
            // Color gradient: cold (blue) -> warm (red/white)
            let r, g, b;
            
            if (clamped < 0.25) {
                // Blue to cyan
                const t = clamped * 4;
                r = 0;
                g = Math.floor(t * 255);
                b = 255;
            } else if (clamped < 0.5) {
                // Cyan to green
                const t = (clamped - 0.25) * 4;
                r = 0;
                g = 255;
                b = Math.floor((1 - t) * 255);
            } else if (clamped < 0.75) {
                // Green to yellow
                const t = (clamped - 0.5) * 4;
                r = Math.floor(t * 255);
                g = 255;
                b = 0;
            } else {
                // Yellow to red to white
                const t = (clamped - 0.75) * 4;
                if (t < 0.5) {
                    r = 255;
                    g = Math.floor((1 - t * 2) * 255);
                    b = 0;
                } else {
                    r = 255;
                    g = Math.floor((t - 0.5) * 2 * 255);
                    b = Math.floor((t - 0.5) * 2 * 255);
                }
            }
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // Update visualization
        function updateVisualization(data) {
            if (!data || !data.thermal_data) return;
            
            // Update info panel
            document.getElementById('minTemp').textContent = `${data.min_temp.toFixed(1)}°C`;
            document.getElementById('maxTemp').textContent = `${data.max_temp.toFixed(1)}°C`;
            document.getElementById('avgTemp').textContent = `${data.avg_temp.toFixed(1)}°C`;
            document.getElementById('centerTemp').textContent = `${data.center_temp.toFixed(1)}°C`;
            document.getElementById('frameCount').textContent = data.frame_count || 0;
            document.getElementById('hotspotCount').textContent = data.hotspot_count || 0;
            
            // Update temperature scale
            const minTemp = autoScale ? data.min_temp : manualMinTemp;
            const maxTemp = autoScale ? data.max_temp : manualMaxTemp;
            document.getElementById('minTempLabel').textContent = `${minTemp.toFixed(1)}°C`;
            document.getElementById('maxTempLabel').textContent = `${maxTemp.toFixed(1)}°C`;
            
            // Draw heatmap
            drawHeatmap(data.thermal_data, data.width, data.height, minTemp, maxTemp);
            
            // Update hotspot list
            updateHotspotList(data.hotspots || []);
        }
        
        // Draw thermal heatmap
        function drawHeatmap(thermalData, width, height, minTemp, maxTemp) {
            // Set canvas size with scaling
            const scale = 20; // Each pixel becomes 10x10
            canvas.width = width * scale;
            canvas.height = height * scale;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw each temperature pixel
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const temp = thermalData[y][x];
                    const color = temperatureToColor(temp, minTemp, maxTemp);
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x * scale, y * scale, scale, scale);
                }
            }
            
            // Draw grid lines (optional)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= width; x++) {
                ctx.beginPath();
                ctx.moveTo(x * scale, 0);
                ctx.lineTo(x * scale, height * scale);
                ctx.stroke();
            }
            for (let y = 0; y <= height; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * scale);
                ctx.lineTo(width * scale, y * scale);
                ctx.stroke();
            }
            
            // Draw center crosshair
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            const centerX = width * scale / 2;
            const centerY = height * scale / 2;
            
            ctx.beginPath();
            ctx.moveTo(centerX - 20, centerY);
            ctx.lineTo(centerX + 20, centerY);
            ctx.moveTo(centerX, centerY - 20);
            ctx.lineTo(centerX, centerY + 20);
            ctx.stroke();
        }
        
        // Update hotspot list
        function updateHotspotList(hotspots) {
            const listContainer = document.getElementById('hotspotList');
            listContainer.innerHTML = '';
            
            hotspots.slice(0, 10).forEach((hotspot, index) => {
                const item = document.createElement('div');
                item.className = 'hotspot-item';
                item.innerHTML = `
                    <span>Hotspot ${index + 1} (${hotspot.x}, ${hotspot.y})</span>
                    <span>${hotspot.temp.toFixed(1)}°C</span>
                `;
                listContainer.appendChild(item);
            });
        }
        
        // Control functions
        async function startThermal() {
            try {
                const response = await fetch('/api/thermal/subscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    streaming = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('thermalStatus').classList.add('connected');
                    document.getElementById('thermalStatusText').textContent = 'Connected';
                }
            } catch (error) {
                console.error('Failed to start thermal camera:', error);
            }
        }
        
        async function stopThermal() {
            try {
                const response = await fetch('/api/thermal/unsubscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    streaming = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                    document.getElementById('thermalStatus').classList.remove('connected');
                    document.getElementById('thermalStatusText').textContent = 'Disconnected';
                }
            } catch (error) {
                console.error('Failed to stop thermal camera:', error);
            }
        }
        
        async function captureFrame() {
            try {
                const response = await fetch('/api/thermal/frame');
                const result = await response.json();
                
                if (result.success) {
                    updateVisualization(result.data);
                }
            } catch (error) {
                console.error('Failed to capture frame:', error);
            }
        }
        
        function saveImage() {
            const link = document.createElement('a');
            link.download = `thermal_${new Date().toISOString()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }
        
        function toggleAutoScale() {
            autoScale = !autoScale;
            document.getElementById('autoScaleBtn').textContent = `Auto Scale: ${autoScale ? 'ON' : 'OFF'}`;
            if (latestFrameData) {
                updateVisualization(latestFrameData);
            }
        }
        
        function resetView() {
            manualMinTemp = 20;
            manualMaxTemp = 35;
            if (!autoScale && latestFrameData) {
                updateVisualization(latestFrameData);
            }
        }
        
        // Add mouse hover to show temperature
        canvas.addEventListener('mousemove', (e) => {
            if (!latestFrameData || !latestFrameData.thermal_data) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = Math.floor((e.clientX - rect.left) * scaleX / 10);
            const y = Math.floor((e.clientY - rect.top) * scaleY / 10);
            
            if (x >= 0 && x < latestFrameData.width && y >= 0 && y < latestFrameData.height) {
                const temp = latestFrameData.thermal_data[y][x];
                canvas.title = `Temperature: ${temp.toFixed(1)}°C at (${x}, ${y})`;
            }
        });
    </script>
</body>
</html>
================================================================================


================================================================================


================================================================================
FILE: robot-dashboard/code_scan_summary.txt
Category: Documentation | Size: 1.3 KB | Lines: 32
================================================================================
Code Scan Summary - 2025-06-10 19:20:32
Directory: /Users/yang/Library/CloudStorage/OneDrive-Personal/UCL/Year 4 UCL/MECH0073/GitHub_Repositories/Fire-fighting-Robot/robot-dashboard
Total files: 20
Total size: 385.7 KB
Total lines: 11,748

Files by category:
  Documentation: 3 files
  Python: 12 files
  Web: 5 files

All code files:
  code_full_content.txt (Documentation, 196.7 KB)
  code_scan_summary.txt (Documentation, 1.2 KB)
  requirements.txt (Documentation, 130.0 B)
  backend/__init__.py (Python, 285.0 B)
  backend/config_manager.py (Python, 3.3 KB)
  backend/host_backend.py (Python, 17.6 KB)
  backend/motors/__init__.py (Python, 0.0 B)
  backend/motors/motor_controller.py (Python, 6.3 KB)
  backend/motors/motor_routes.py (Python, 3.7 KB)
  backend/motors/servo_control.py (Python, 6.7 KB)
  backend/ros_bridge.py (Python, 14.3 KB)
  backend/sensors/__init__.py (Python, 280.0 B)
  backend/sensors/lidar.py (Python, 8.0 KB)
  backend/sensors/thermal_camera.py (Python, 7.7 KB)
  run.py (Python, 341.0 B)
  frontend/templates/aiming_system.html (Web, 23.6 KB)
  frontend/templates/dashboard_home.html (Web, 25.4 KB)
  frontend/templates/lidar_visualization.html (Web, 26.8 KB)
  frontend/templates/motor_control.html (Web, 23.3 KB)
  frontend/templates/thermal_camera.html (Web, 20.0 KB)

================================================================================


================================================================================
FILE: robot-dashboard/requirements.txt
Category: Documentation | Size: 130.0 B | Lines: 7
================================================================================
Flask==3.0.0
Flask-CORS==4.0.0
Flask-SocketIO==5.3.5
websocket-client==1.7.0
watchdog==3.0.0
numpy==1.26.2
python-socketio==5.10.0
================================================================================


================================================================================
FILE: servo_interfaces/CMakeLists.txt
Category: Documentation | Size: 547.0 B | Lines: 21
================================================================================
cmake_minimum_required(VERSION 3.8)
project(servo_interfaces)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

find_package(ament_cmake REQUIRED)
find_package(std_msgs REQUIRED)
find_package(rosidl_default_generators REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  "msg/ServoPosition.msg"
  "msg/ServoState.msg"
  "srv/SetServoPosition.srv"
  "srv/SetServoSpeed.srv"
  DEPENDENCIES std_msgs
)

ament_export_dependencies(rosidl_default_runtime)
ament_package()

================================================================================


================================================================================
FILE: Flask_app.py
Category: Python | Size: 5.7 KB | Lines: 183
================================================================================
#!/usr/bin/env python3
import socket
import json
from flask import Flask, request, jsonify, render_template_string

app = Flask(__name__)

# -------------------
# ADJUST THESE
# -------------------
PI_IP = "192.168.2.3"  # Replace with your Pi's IP
PI_PORT = 12345

HTML_TEMPLATE = r"""
<!DOCTYPE html>
<html>
<head>
  <title>Robot Motor Control (Dynamic)</title>
</head>
<body>
  <h1>Robot Motor Control (Hosted on Mac)</h1>
  <p>This page will stay visible, and commands are sent via JavaScript so it doesn't navigate away.</p>
  
  <hr/>
  <p><strong>Pi Connection Status:</strong> <span id="status_span">Checking...</span></p>
  
  <div id="motors_container">
    {% for m in motors %}
      <h2>Motor {{m}}</h2>
      <div>
        <label>Direction:</label>
        <select id="dir_{{m}}">
          <option value="forward">Forward</option>
          <option value="backward">Backward</option>
        </select>
        <br/><br/>
        <label>Speed (%):</label>
        <!-- Slider for percentage speed -->
        <input type="range" id="speed_{{m}}" value="50" min="0" max="100" oninput="updateSpeedLabel({{m}})">
        <span id="speed_label_{{m}}">50%</span>
        <br/><br/>
        <button onclick="sendCommand({{m}})">Update</button>
        <button onclick="brakeMotor({{m}})">Brake</button>
      </div>
      <p>Response: <span id="resp_{{m}}"></span></p>
      <hr/>
    {% endfor %}
  </div>
  
  <script>
    // Update the speed label to show the current percentage value
    function updateSpeedLabel(motorId) {
      let speedSlider = document.getElementById("speed_" + motorId);
      let speedLabel = document.getElementById("speed_label_" + motorId);
      speedLabel.textContent = speedSlider.value + "%";
    }
    
    // Periodically ping the Pi to update the status text
    function checkPiStatus() {
      fetch("/ping_status")
        .then(response => response.json())
        .then(data => {
          if (data.connected === true) {
            document.getElementById("status_span").textContent = "Connected";
          } else {
            document.getElementById("status_span").textContent = "Not connected";
          }
        })
        .catch(err => {
          document.getElementById("status_span").textContent = "Error checking status";
          console.error(err);
        });
    }
    
    // Call checkPiStatus every 2 seconds and immediately on load
    setInterval(checkPiStatus, 2000);
    checkPiStatus();
    
    // Send command to Pi (motor_id, direction, speed) without reloading the page
    function sendCommand(motorId) {
      let directionSel = document.getElementById("dir_" + motorId);
      // Get slider value as a percentage
      let percent = parseInt(document.getElementById("speed_" + motorId).value);
      // Convert percentage (0-100) to raw value (0-65535)
      let speed = Math.round((percent / 100) * 65535);
      
      let payload = {
        motor_id: motorId,
        direction: directionSel.value,
        speed: speed
      };
      
      fetch("/send_command", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      })
      .then(response => response.json())
      .then(data => {
        document.getElementById("resp_" + motorId).textContent = data.result;
      })
      .catch(err => {
        document.getElementById("resp_" + motorId).textContent = "Error: " + err;
      });
    }
    
    // Brake motor by sending { direction:"brake", speed:0 }
    function brakeMotor(motorId) {
      let payload = {
        motor_id: motorId,
        direction: "brake",
        speed: 0
      };
      
      fetch("/send_command", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      })
      .then(response => response.json())
      .then(data => {
        document.getElementById("resp_" + motorId).textContent = data.result;
      })
      .catch(err => {
        document.getElementById("resp_" + motorId).textContent = "Error: " + err;
      });
    }
  </script>
</body>
</html>
"""

@app.route("/")
def index():
    # Render the template with motor IDs 1 through 4
    return render_template_string(HTML_TEMPLATE, motors=[1, 2, 3, 4])

@app.route("/ping_status", methods=["GET"])
def ping_status():
    """
    Returns JSON indicating whether the Pi responded to 'ping' or not.
    """
    resp = send_to_pi(PI_IP, PI_PORT, "ping")
    if resp == "pong":
        return jsonify({"connected": True})
    else:
        return jsonify({"connected": False})

@app.route("/send_command", methods=["POST"])
def send_command():
    """
    Expects JSON: { "motor_id": int, "direction": str, "speed": int }
    Sends that to the Pi as "motor_id,direction,speed" and returns the Pi's response.
    """
    try:
        data = request.get_json()
        motor_id = data.get("motor_id", 1)
        direction = data.get("direction", "forward")
        speed = data.get("speed", 30000)
        
        command_str = f"{motor_id},{direction},{speed}"
        pi_resp = send_to_pi(PI_IP, PI_PORT, command_str)
        return jsonify({"result": pi_resp})
    except Exception as e:
        return jsonify({"result": f"ERROR: {e}"}), 400

def send_to_pi(ip, port, command_str):
    """
    Opens a TCP socket to the Pi, sends command_str, and returns the Pi's response.
    """
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(2.0)
            s.connect((ip, port))
            s.sendall(command_str.encode("utf-8"))
            data = s.recv(1024).decode("utf-8")
        return data
    except Exception as e:
        return f"ERROR contacting Pi: {e}"

if __name__ == "__main__":
    # Launch Flask on Mac
    app.run(host="127.0.0.1", port=5000, debug=True)

================================================================================


================================================================================
FILE: Image Processing/depth_camera_main.py
Category: Python | Size: 2.2 KB | Lines: 62
================================================================================
import pyrealsense2 as rs
import numpy as np
import cv2

def main():
    # 1. Configure depth & color streams
    pipeline = rs.pipeline()
    config   = rs.config()
    config.enable_stream(rs.stream.depth, 640, 480, rs.format.z16, 30)
    config.enable_stream(rs.stream.color, 640, 480, rs.format.bgr8, 30)

    # 2. Start streaming
    profile = pipeline.start(config)

    # 3. Get depth sensor’s scale (to convert from raw units to meters)
    depth_sensor = profile.get_device().first_depth_sensor()
    depth_scale  = depth_sensor.get_depth_scale()
    print(f"[INFO] Depth scale is {depth_scale:.4f} meters per unit")

    # 4. Create an align object to align depth frames to color frames
    align_to = rs.stream.color
    align    = rs.align(align_to)

    try:
        while True:
            # 5. Wait for a coherent pair of frames: depth + color
            frames        = pipeline.wait_for_frames()
            aligned_frames = align.process(frames)

            # 6. Extract aligned frames
            depth_frame = aligned_frames.get_depth_frame()
            color_frame = aligned_frames.get_color_frame()
            if not depth_frame or not color_frame:
                continue

            # 7. Convert images to numpy arrays
            depth_image = np.asanyarray(depth_frame.get_data())
            color_image = np.asanyarray(color_frame.get_data())

            # 8. Normalize depth to 0–255 for display and apply a colormap
            #    alpha controls contrast; tweak if it’s too dark/bright.
            depth_display = cv2.convertScaleAbs(depth_image, alpha=0.03)
            depth_colormap = cv2.applyColorMap(depth_display, cv2.COLORMAP_JET)

            # 9. Stack both images horizontally
            combined = np.hstack((color_image, depth_colormap))

            # 10. Show in a window
            cv2.namedWindow('RealSense (RGB | Depth)', cv2.WINDOW_AUTOSIZE)
            cv2.imshow('RealSense (RGB | Depth)', combined)

            # 11. Exit on ESC key
            if cv2.waitKey(1) & 0xFF == 27:
                break

    finally:
        # 12. Clean up
        pipeline.stop()
        cv2.destroyAllWindows()

if __name__ == '__main__':
    main()

================================================================================


================================================================================
FILE: Pi_motor_control.py
Category: Python | Size: 4.5 KB | Lines: 128
================================================================================
#!/usr/bin/env python3
import board
import busio
import adafruit_pca9685
import socket
import signal
import sys

# Global server socket variable for cleanup
server_socket = None

# ------------------------------------------------------------------------------
# Motor channel mapping
# ------------------------------------------------------------------------------
motor_map = {
    1: (0, 1),
    2: (2, 3),
    3: (4, 5),
    4: (6, 7)
}

# ------------------------------------------------------------------------------
# Polarity definitions
# ------------------------------------------------------------------------------
FORWARD_POLARITY = (0, 0xFFFF)
BACKWARD_POLARITY = (0xFFFF, 0)

# ------------------------------------------------------------------------------
# Initialize PCA9685 on the Pi's I2C
# ------------------------------------------------------------------------------
i2c = busio.I2C(board.SCL, board.SDA)
pca = adafruit_pca9685.PCA9685(i2c)
pca.frequency = 100  # Hz

# ------------------------------------------------------------------------------
# Set motor function
# ------------------------------------------------------------------------------
def set_motor(motor_id, direction, speed):
    speed_channel, dir_channel = motor_map[motor_id]
    if direction == "forward":
        pca.channels[dir_channel].duty_cycle = FORWARD_POLARITY[1]
        pca.channels[speed_channel].duty_cycle = speed
    elif direction == "backward":
        pca.channels[dir_channel].duty_cycle = BACKWARD_POLARITY[1]
        pca.channels[speed_channel].duty_cycle = speed
    elif direction == "brake":
        # Example brake: set both channels to 0 (adjust per your hardware requirements)
        pca.channels[speed_channel].duty_cycle = 0
        pca.channels[dir_channel].duty_cycle = 0

# ------------------------------------------------------------------------------
# Parse and execute command function
# ------------------------------------------------------------------------------
def parse_and_execute(command_str):
    command_str = command_str.strip()
    if command_str == "ping":
        return "pong"
    
    parts = command_str.split(",")
    if len(parts) != 3:
        return "ERROR: invalid command format (expected motor_id,direction,speed)"
    
    try:
        motor_id = int(parts[0])
        direction = parts[1].lower()
        speed = int(parts[2])
        
        if motor_id not in motor_map:
            return f"ERROR: motor_id must be 1..4, got {motor_id}"
        if direction not in ["forward", "backward", "brake"]:
            return "ERROR: direction must be forward, backward, or brake"
        
        # Clamp speed
        speed = max(0, min(speed, 65535))
        
        set_motor(motor_id, direction, speed)
        return f"OK: motor={motor_id}, dir={direction}, speed={speed}"
    except ValueError:
        return "ERROR: could not parse motor_id or speed"

# ------------------------------------------------------------------------------
# Signal handler for graceful exit
# ------------------------------------------------------------------------------
def clean_exit(signum, frame):
    global server_socket
    print("\nReceived signal to terminate. Cleaning up...")
    if server_socket:
        server_socket.close()
        print("Socket closed.")
    sys.exit(0)

# Register signal handlers for SIGINT and SIGTERM
signal.signal(signal.SIGINT, clean_exit)
signal.signal(signal.SIGTERM, clean_exit)

# ------------------------------------------------------------------------------
# Main server loop
# ------------------------------------------------------------------------------
def main():
    global server_socket
    HOST = "0.0.0.0"
    PORT = 12345
    print(f"Starting motor server on {HOST}:{PORT}")

    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Allow immediate reuse of the address after the server stops.
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    
    try:
        server_socket.bind((HOST, PORT))
        server_socket.listen(5)
        
        while True:
            client, address = server_socket.accept()
            data = client.recv(1024).decode("utf-8")
            if data:
                response = parse_and_execute(data)
                client.sendall(response.encode("utf-8"))
            client.close()
    except Exception as e:
        print(f"Server error: {e}")
    finally:
        if server_socket:
            server_socket.close()
            print("Socket closed in finally block.")

if __name__ == "__main__":
    main()

================================================================================


================================================================================
FILE: Test_folder/Aiming_system/demo_python.py
Category: Python | Size: 3.8 KB | Lines: 121
================================================================================
#!/usr/bin/env python3
"""
Servo Control for Raspberry Pi
Controls two servo motors (pan and tilt) with 0-270 degree range
"""

import RPi.GPIO as GPIO
import time

class ServoController:
    def __init__(self, servo1_pin=12, servo2_pin=13):
        """
        Initialize servo controller
        servo1_pin: GPIO pin for tilt servo (default: GPIO 12, physical pin 32)
        servo2_pin: GPIO pin for pan servo (default: GPIO 13, physical pin 33)
        """
        # Use BCM pin numbering
        GPIO.setmode(GPIO.BCM)
        
        # Store pin numbers
        self.servo1_pin = servo1_pin  # Tilt
        self.servo2_pin = servo2_pin  # Pan
        
        # Setup GPIO pins as outputs
        GPIO.setup(self.servo1_pin, GPIO.OUT)
        GPIO.setup(self.servo2_pin, GPIO.OUT)
        
        # Create PWM instances (50Hz is standard for servos)
        self.servo1_pwm = GPIO.PWM(self.servo1_pin, 50)
        self.servo2_pwm = GPIO.PWM(self.servo2_pin, 50)
        
        # Start PWM with 0% duty cycle
        self.servo1_pwm.start(0)
        self.servo2_pwm.start(0)
        
        # Small delay to let servos initialize
        time.sleep(0.5)
    
    def angle_to_duty_cycle(self, angle):
        """
        Convert angle (0-270 degrees) to duty cycle percentage
        
        For 50Hz PWM:
        - 0.5ms pulse (2.5% duty cycle) = 0 degrees
        - 2.5ms pulse (12.5% duty cycle) = 270 degrees
        """
        # Map angle (0-270) to duty cycle (2.5-12.5)
        duty_cycle = 2.5 + (angle / 270.0) * 10.0
        return duty_cycle
    
    def move_servo(self, servo_pwm, angle):
        """
        Move a servo to specified angle
        """
        if 0 <= angle <= 270:
            duty_cycle = self.angle_to_duty_cycle(angle)
            servo_pwm.ChangeDutyCycle(duty_cycle)
            time.sleep(0.5)  # Give servo time to move
            # Stop sending signal to reduce jitter
            servo_pwm.ChangeDutyCycle(0)
            return True
        return False
    
    def cleanup(self):
        """
        Clean up GPIO resources
        """
        self.servo1_pwm.stop()
        self.servo2_pwm.stop()
        GPIO.cleanup()

def main():
    # Create servo controller instance
    controller = ServoController(servo1_pin=12, servo2_pin=13)
    
    print("Servo Control Program")
    print("Enter angles for Servo 1 (Tilt) and Servo 2 (Pan) (0-270°)")
    print("Type 'quit' to exit")
    
    try:
        while True:
            # Get pan angle
            pan_input = input("\nEnter angle for pan (0-270): ")
            
            if pan_input.lower() == 'quit':
                break
            
            try:
                pan_angle = int(pan_input)
                if controller.move_servo(controller.servo2_pwm, pan_angle):
                    print(f"Servo 2 (Pan) moved to {pan_angle} degrees.")
                else:
                    print("Invalid input. Enter a value between 0 and 270.")
            except ValueError:
                print("Invalid input. Please enter a number.")
            
            # Get tilt angle
            tilt_input = input("Enter angle for tilt (0-270): ")
            
            if tilt_input.lower() == 'quit':
                break
            
            try:
                tilt_angle = int(tilt_input)
                if controller.move_servo(controller.servo1_pwm, tilt_angle):
                    print(f"Servo 1 (Tilt) moved to {tilt_angle} degrees.")
                else:
                    print("Invalid input. Enter a value between 0 and 270.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    except KeyboardInterrupt:
        print("\nProgram interrupted by user")
    
    finally:
        # Always clean up GPIO on exit
        controller.cleanup()
        print("GPIO cleaned up. Exiting...")

if __name__ == "__main__":
    main()
================================================================================


================================================================================
FILE: Test_folder/Camera_Test/D435/demo.py
Category: Python | Size: 26.6 KB | Lines: 726
================================================================================
#!/usr/bin/env python3
"""
Intel RealSense D435 Headless Test Scripts for Raspberry Pi (Ubuntu Server)
Test different features without GUI: Depth, RGB, and Infrared
"""

import pyrealsense2 as rs
import numpy as np
import time
import json
import os
from datetime import datetime

# ==============================================================================
# Test 1: Basic Connection and Device Info
# ==============================================================================

def test_connection():
    """Test basic connection and display device information"""
    print("\n" + "="*60)
    print("TEST 1: Device Connection and Information")
    print("="*60)
    
    try:
        # Create context
        ctx = rs.context()
        devices = ctx.query_devices()
        
        if len(devices) == 0:
            print("ERROR: No RealSense devices found!")
            return False
            
        print(f"Found {len(devices)} RealSense device(s)")
        
        for i, dev in enumerate(devices):
            print(f"\nDevice {i}:")
            print(f"  Name: {dev.get_info(rs.camera_info.name)}")
            print(f"  Serial Number: {dev.get_info(rs.camera_info.serial_number)}")
            print(f"  Firmware Version: {dev.get_info(rs.camera_info.firmware_version)}")
            print(f"  USB Type: {dev.get_info(rs.camera_info.usb_type_descriptor)}")
            print(f"  Product ID: {dev.get_info(rs.camera_info.product_id)}")
            
            # Check sensors
            print(f"\n  Available Sensors:")
            for sensor in dev.sensors:
                print(f"    - {sensor.get_info(rs.camera_info.name)}")
                
        return True
        
    except Exception as e:
        print(f"ERROR: {str(e)}")
        return False


# ==============================================================================
# Test 2: Stream Capabilities
# ==============================================================================

def test_stream_capabilities():
    """Test and list all supported stream configurations"""
    print("\n" + "="*60)
    print("TEST 2: Stream Capabilities")
    print("="*60)
    
    try:
        ctx = rs.context()
        devices = ctx.query_devices()
        
        if len(devices) == 0:
            print("ERROR: No devices found")
            return
            
        dev = devices[0]
        
        # Dictionary to store capabilities
        capabilities = {
            'depth': [],
            'color': [],
            'infrared': []
        }
        
        for sensor in dev.sensors:
            print(f"\nSensor: {sensor.get_info(rs.camera_info.name)}")
            profiles = sensor.get_stream_profiles()
            
            for profile in profiles:
                if hasattr(profile, 'stream_type'):
                    stream_type = str(profile.stream_type())
                    
                    if profile.stream_type() in [rs.stream.depth, rs.stream.color, rs.stream.infrared]:
                        vp = profile.as_video_stream_profile()
                        
                        mode = {
                            'width': vp.width(),
                            'height': vp.height(),
                            'fps': profile.fps(),
                            'format': str(profile.format())
                        }
                        
                        # Categorize by stream type
                        if profile.stream_type() == rs.stream.depth:
                            if mode not in capabilities['depth']:
                                capabilities['depth'].append(mode)
                        elif profile.stream_type() == rs.stream.color:
                            if mode not in capabilities['color']:
                                capabilities['color'].append(mode)
                        elif profile.stream_type() == rs.stream.infrared:
                            if mode not in capabilities['infrared']:
                                capabilities['infrared'].append(mode)
        
        # Display sorted capabilities
        for stream_type, modes in capabilities.items():
            print(f"\n{stream_type.upper()} Stream Capabilities:")
            # Sort by resolution and fps
            sorted_modes = sorted(modes, key=lambda x: (x['width'], x['height'], x['fps']))
            for mode in sorted_modes[:10]:  # Show first 10 to avoid clutter
                print(f"  {mode['width']}x{mode['height']} @ {mode['fps']}fps ({mode['format']})")
                
        # Save capabilities to file
        with open('camera_capabilities.json', 'w') as f:
            json.dump(capabilities, f, indent=2)
        print("\nCapabilities saved to 'camera_capabilities.json'")
        
    except Exception as e:
        print(f"ERROR: {str(e)}")


# ==============================================================================
# Test 3: RGB Stream Data Collection
# ==============================================================================

def test_rgb_data():
    """Test RGB stream and collect raw data statistics"""
    print("\n" + "="*60)
    print("TEST 3: RGB Stream Raw Data Analysis")
    print("="*60)
    
    pipeline = rs.pipeline()
    config = rs.config()
    
    # Configure color stream (lower resolution for RPi)
    config.enable_stream(rs.stream.color, 640, 480, rs.format.bgr8, 30)
    
    try:
        # Start streaming
        pipeline.start(config)
        print("RGB stream started successfully")
        print("Collecting 100 frames for analysis...")
        
        frame_count = 0
        frame_times = []
        rgb_stats = []
        
        start_time = time.time()
        
        while frame_count < 100:
            # Wait for frames
            frames = pipeline.wait_for_frames()
            color_frame = frames.get_color_frame()
            
            if not color_frame:
                continue
                
            frame_time = time.time()
            frame_times.append(frame_time)
            
            # Convert to numpy array
            color_image = np.asanyarray(color_frame.get_data())
            
            # Calculate statistics
            stats = {
                'frame': frame_count,
                'timestamp': color_frame.get_timestamp(),
                'shape': color_image.shape,
                'dtype': str(color_image.dtype),
                'mean_r': float(np.mean(color_image[:,:,2])),
                'mean_g': float(np.mean(color_image[:,:,1])),
                'mean_b': float(np.mean(color_image[:,:,0])),
                'std_r': float(np.std(color_image[:,:,2])),
                'std_g': float(np.std(color_image[:,:,1])),
                'std_b': float(np.std(color_image[:,:,0])),
                'min': int(np.min(color_image)),
                'max': int(np.max(color_image))
            }
            rgb_stats.append(stats)
            
            # Save first and last frame as raw numpy arrays
            if frame_count == 0:
                np.save('rgb_first_frame.npy', color_image)
                print(f"  First frame saved (shape: {color_image.shape}, dtype: {color_image.dtype})")
            elif frame_count == 99:
                np.save('rgb_last_frame.npy', color_image)
                print(f"  Last frame saved")
                
            frame_count += 1
            
            # Progress indicator
            if frame_count % 20 == 0:
                print(f"  Processed {frame_count} frames...")
        
        # Calculate FPS
        total_time = time.time() - start_time
        actual_fps = frame_count / total_time
        
        # Calculate frame time statistics
        frame_intervals = np.diff(frame_times)
        
        print(f"\nRGB Stream Statistics:")
        print(f"  Total frames: {frame_count}")
        print(f"  Total time: {total_time:.2f} seconds")
        print(f"  Actual FPS: {actual_fps:.2f}")
        print(f"  Frame interval mean: {np.mean(frame_intervals)*1000:.2f} ms")
        print(f"  Frame interval std: {np.std(frame_intervals)*1000:.2f} ms")
        
        # Color statistics summary
        mean_stats = {
            'avg_red': np.mean([s['mean_r'] for s in rgb_stats]),
            'avg_green': np.mean([s['mean_g'] for s in rgb_stats]),
            'avg_blue': np.mean([s['mean_b'] for s in rgb_stats])
        }
        
        print(f"\nColor Channel Averages:")
        print(f"  Red:   {mean_stats['avg_red']:.2f}")
        print(f"  Green: {mean_stats['avg_green']:.2f}")
        print(f"  Blue:  {mean_stats['avg_blue']:.2f}")
        
        # Save statistics
        with open('rgb_statistics.json', 'w') as f:
            json.dump({
                'summary': {
                    'total_frames': frame_count,
                    'total_time': total_time,
                    'actual_fps': actual_fps,
                    'mean_stats': mean_stats
                },
                'frame_stats': rgb_stats[:10]  # Save first 10 frames details
            }, f, indent=2)
        
        print("\nStatistics saved to 'rgb_statistics.json'")
        
    except Exception as e:
        print(f"ERROR: {str(e)}")
    finally:
        pipeline.stop()
        print("RGB stream stopped")


# ==============================================================================
# Test 4: Depth Stream Data Collection
# ==============================================================================

def test_depth_data():
    """Test depth stream and analyze depth data"""
    print("\n" + "="*60)
    print("TEST 4: Depth Stream Raw Data Analysis")
    print("="*60)
    
    pipeline = rs.pipeline()
    config = rs.config()
    
    # Configure depth stream
    config.enable_stream(rs.stream.depth, 640, 480, rs.format.z16, 30)
    
    try:
        # Start streaming
        pipeline.start(config)
        print("Depth stream started successfully")
        print("Collecting 100 frames for analysis...")
        
        frame_count = 0
        depth_stats = []
        
        while frame_count < 100:
            frames = pipeline.wait_for_frames()
            depth_frame = frames.get_depth_frame()
            
            if not depth_frame:
                continue
                
            # Convert to numpy array
            depth_image = np.asanyarray(depth_frame.get_data())
            
            # Get actual distance values in meters
            depth_scale = pipeline.get_active_profile().get_device().first_depth_sensor().get_depth_scale()
            depth_in_meters = depth_image * depth_scale
            
            # Calculate statistics (excluding zero values)
            valid_depths = depth_in_meters[depth_in_meters > 0]
            
            if len(valid_depths) > 0:
                stats = {
                    'frame': frame_count,
                    'timestamp': depth_frame.get_timestamp(),
                    'shape': depth_image.shape,
                    'depth_scale': depth_scale,
                    'min_distance_m': float(np.min(valid_depths)),
                    'max_distance_m': float(np.max(valid_depths)),
                    'mean_distance_m': float(np.mean(valid_depths)),
                    'std_distance_m': float(np.std(valid_depths)),
                    'valid_pixels': len(valid_depths),
                    'total_pixels': depth_image.size,
                    'coverage_percent': (len(valid_depths) / depth_image.size) * 100
                }
                depth_stats.append(stats)
            
            # Save first frame
            if frame_count == 0:
                np.save('depth_first_frame_raw.npy', depth_image)
                np.save('depth_first_frame_meters.npy', depth_in_meters)
                print(f"  First depth frame saved (shape: {depth_image.shape})")
                print(f"  Depth scale: {depth_scale} meters/unit")
                
            frame_count += 1
            
            if frame_count % 20 == 0:
                print(f"  Processed {frame_count} frames...")
        
        # Summary statistics
        print(f"\nDepth Stream Statistics:")
        print(f"  Total frames: {frame_count}")
        print(f"  Average min distance: {np.mean([s['min_distance_m'] for s in depth_stats]):.3f} m")
        print(f"  Average max distance: {np.mean([s['max_distance_m'] for s in depth_stats]):.3f} m")
        print(f"  Average coverage: {np.mean([s['coverage_percent'] for s in depth_stats]):.1f}%")
        
        # Save statistics
        with open('depth_statistics.json', 'w') as f:
            json.dump({
                'summary': {
                    'total_frames': frame_count,
                    'depth_scale': depth_scale,
                    'avg_min_distance': np.mean([s['min_distance_m'] for s in depth_stats]),
                    'avg_max_distance': np.mean([s['max_distance_m'] for s in depth_stats])
                },
                'frame_stats': depth_stats[:10]
            }, f, indent=2)
            
        print("Statistics saved to 'depth_statistics.json'")
        
    except Exception as e:
        print(f"ERROR: {str(e)}")
    finally:
        pipeline.stop()
        print("Depth stream stopped")


# ==============================================================================
# Test 5: Infrared Stream Test
# ==============================================================================

def test_infrared_data():
    """Test infrared streams and collect data"""
    print("\n" + "="*60)
    print("TEST 5: Infrared Stream Raw Data Analysis")
    print("="*60)
    
    pipeline = rs.pipeline()
    config = rs.config()
    
    # Configure infrared streams
    config.enable_stream(rs.stream.infrared, 1, 640, 480, rs.format.y8, 30)
    config.enable_stream(rs.stream.infrared, 2, 640, 480, rs.format.y8, 30)
    
    try:
        pipeline.start(config)
        print("Infrared streams started successfully")
        print("Collecting 50 frames for analysis...")
        
        frame_count = 0
        ir_stats = []
        
        while frame_count < 50:
            frames = pipeline.wait_for_frames()
            ir1_frame = frames.get_infrared_frame(1)
            ir2_frame = frames.get_infrared_frame(2)
            
            if not ir1_frame or not ir2_frame:
                continue
                
            # Convert to numpy arrays
            ir1_image = np.asanyarray(ir1_frame.get_data())
            ir2_image = np.asanyarray(ir2_frame.get_data())
            
            stats = {
                'frame': frame_count,
                'ir1_mean': float(np.mean(ir1_image)),
                'ir1_std': float(np.std(ir1_image)),
                'ir2_mean': float(np.mean(ir2_image)),
                'ir2_std': float(np.std(ir2_image)),
                'difference_mean': float(np.mean(np.abs(ir1_image.astype(float) - ir2_image.astype(float))))
            }
            ir_stats.append(stats)
            
            # Save first frame
            if frame_count == 0:
                np.save('ir_left_first_frame.npy', ir1_image)
                np.save('ir_right_first_frame.npy', ir2_image)
                print(f"  First IR frames saved (shape: {ir1_image.shape})")
                
            frame_count += 1
            
            if frame_count % 10 == 0:
                print(f"  Processed {frame_count} frames...")
        
        print(f"\nInfrared Stream Statistics:")
        print(f"  Total frames: {frame_count}")
        print(f"  Left IR average intensity: {np.mean([s['ir1_mean'] for s in ir_stats]):.2f}")
        print(f"  Right IR average intensity: {np.mean([s['ir2_mean'] for s in ir_stats]):.2f}")
        
        # Save statistics
        with open('ir_statistics.json', 'w') as f:
            json.dump({
                'summary': {
                    'total_frames': frame_count,
                    'left_avg': np.mean([s['ir1_mean'] for s in ir_stats]),
                    'right_avg': np.mean([s['ir2_mean'] for s in ir_stats])
                },
                'frame_stats': ir_stats[:10]
            }, f, indent=2)
            
        print("Statistics saved to 'ir_statistics.json'")
        
    except Exception as e:
        print(f"ERROR: {str(e)}")
    finally:
        pipeline.stop()
        print("Infrared streams stopped")


# ==============================================================================
# Test 6: Multi-Stream Performance Test
# ==============================================================================

def test_multi_stream_performance():
    """Test performance with multiple streams enabled"""
    print("\n" + "="*60)
    print("TEST 6: Multi-Stream Performance Test")
    print("="*60)
    
    test_configs = [
        {
            'name': 'Depth only (640x480)',
            'streams': [
                (rs.stream.depth, 640, 480, rs.format.z16, 30)
            ]
        },
        {
            'name': 'RGB only (640x480)',
            'streams': [
                (rs.stream.color, 640, 480, rs.format.bgr8, 30)
            ]
        },
        {
            'name': 'Depth + RGB (640x480)',
            'streams': [
                (rs.stream.depth, 640, 480, rs.format.z16, 30),
                (rs.stream.color, 640, 480, rs.format.bgr8, 30)
            ]
        },
        {
            'name': 'Depth + IR (640x480)',
            'streams': [
                (rs.stream.depth, 640, 480, rs.format.z16, 30),
                (rs.stream.infrared, 1, 640, 480, rs.format.y8, 30)
            ]
        },
        {
            'name': 'Low res - All streams (480x270)',
            'streams': [
                (rs.stream.depth, 480, 270, rs.format.z16, 30),
                (rs.stream.color, 480, 270, rs.format.bgr8, 30),
                (rs.stream.infrared, 1, 480, 270, rs.format.y8, 30)
            ]
        }
    ]
    
    results = []
    
    for test_config in test_configs:
        print(f"\nTesting: {test_config['name']}")
        
        pipeline = rs.pipeline()
        config = rs.config()
        
        # Configure streams
        for stream_type, width, height, format, fps in test_config['streams']:
            config.enable_stream(stream_type, width, height, format, fps)
        
        try:
            pipeline.start(config)
            
            # Warm up
            for _ in range(10):
                pipeline.wait_for_frames()
            
            # Measure performance
            start_time = time.time()
            frame_count = 0
            errors = 0
            
            while frame_count < 100:
                try:
                    frames = pipeline.wait_for_frames()
                    frame_count += 1
                except:
                    errors += 1
                    
            elapsed_time = time.time() - start_time
            fps = frame_count / elapsed_time
            
            result = {
                'config': test_config['name'],
                'fps': fps,
                'errors': errors,
                'time': elapsed_time
            }
            results.append(result)
            
            print(f"  Result: {fps:.2f} FPS ({errors} errors)")
            
            pipeline.stop()
            
        except Exception as e:
            print(f"  ERROR: {str(e)}")
            results.append({
                'config': test_config['name'],
                'error': str(e)
            })
    
    # Save results
    with open('performance_results.json', 'w') as f:
        json.dump(results, f, indent=2)
    
    print("\nPerformance results saved to 'performance_results.json'")


# ==============================================================================
# Test 7: Continuous Data Logger
# ==============================================================================

def test_data_logger(duration=30):
    """Log continuous data from all streams for analysis"""
    print("\n" + "="*60)
    print(f"TEST 7: Continuous Data Logger ({duration} seconds)")
    print("="*60)
    
    pipeline = rs.pipeline()
    config = rs.config()
    
    # Configure all streams at lower resolution for stability
    config.enable_stream(rs.stream.depth, 480, 270, rs.format.z16, 30)
    config.enable_stream(rs.stream.color, 480, 270, rs.format.bgr8, 30)
    config.enable_stream(rs.stream.infrared, 1, 480, 270, rs.format.y8, 30)
    
    # Create output directory
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_dir = f"realsense_data_{timestamp}"
    os.makedirs(output_dir, exist_ok=True)
    
    print(f"Logging data to directory: {output_dir}")
    
    try:
        pipeline.start(config)
        
        # Get depth scale
        depth_scale = pipeline.get_active_profile().get_device().first_depth_sensor().get_depth_scale()
        
        log_data = {
            'metadata': {
                'start_time': timestamp,
                'depth_scale': depth_scale,
                'duration_target': duration
            },
            'frames': []
        }
        
        start_time = time.time()
        frame_count = 0
        
        print("Logging started. Press Ctrl+C to stop early.")
        
        while (time.time() - start_time) < duration:
            try:
                frames = pipeline.wait_for_frames()
                
                depth_frame = frames.get_depth_frame()
                color_frame = frames.get_color_frame()
                ir_frame = frames.get_infrared_frame(1)
                
                if depth_frame and color_frame and ir_frame:
                    current_time = time.time() - start_time
                    
                    # Get center point distance
                    width = depth_frame.get_width()
                    height = depth_frame.get_height()
                    center_distance = depth_frame.get_distance(width // 2, height // 2)
                    
                    # Log frame data
                    frame_data = {
                        'frame': frame_count,
                        'time': current_time,
                        'depth_timestamp': depth_frame.get_timestamp(),
                        'color_timestamp': color_frame.get_timestamp(),
                        'center_distance_m': center_distance
                    }
                    log_data['frames'].append(frame_data)
                    
                    # Save snapshot every 5 seconds
                    if frame_count % 150 == 0:  # Approximately every 5 seconds at 30fps
                        # Save arrays
                        depth_array = np.asanyarray(depth_frame.get_data())
                        color_array = np.asanyarray(color_frame.get_data())
                        ir_array = np.asanyarray(ir_frame.get_data())
                        
                        np.save(f"{output_dir}/depth_{frame_count}.npy", depth_array)
                        np.save(f"{output_dir}/color_{frame_count}.npy", color_array)
                        np.save(f"{output_dir}/ir_{frame_count}.npy", ir_array)
                        
                        print(f"  Saved snapshot at {current_time:.1f}s (frame {frame_count})")
                    
                    frame_count += 1
                    
            except KeyboardInterrupt:
                print("\nLogging stopped by user")
                break
            except Exception as e:
                print(f"Frame error: {e}")
                continue
        
        # Final statistics
        actual_duration = time.time() - start_time
        actual_fps = frame_count / actual_duration
        
        log_data['metadata']['actual_duration'] = actual_duration
        log_data['metadata']['total_frames'] = frame_count
        log_data['metadata']['actual_fps'] = actual_fps
        
        # Save log data
        with open(f"{output_dir}/log_data.json", 'w') as f:
            json.dump(log_data, f, indent=2)
        
        print(f"\nLogging completed:")
        print(f"  Duration: {actual_duration:.1f} seconds")
        print(f"  Frames: {frame_count}")
        print(f"  FPS: {actual_fps:.2f}")
        print(f"  Data saved to: {output_dir}/")
        
    except Exception as e:
        print(f"ERROR: {str(e)}")
    finally:
        pipeline.stop()
        print("Data logger stopped")


# ==============================================================================
# Main Menu
# ==============================================================================

if __name__ == "__main__":
    print("\nIntel RealSense D435 Headless Test Suite")
    print("For Raspberry Pi with Ubuntu Server 22.04")
    print("="*60)
    
    # Check if running as root (sometimes needed for USB access)
    if os.geteuid() == 0:
        print("WARNING: Running as root. Consider adding user to 'video' group instead.")
    
    while True:
        print("\nAvailable Tests:")
        print("1. Test Connection and Device Info")
        print("2. List Stream Capabilities")
        print("3. RGB Raw Data Analysis")
        print("4. Depth Raw Data Analysis")
        print("5. Infrared Raw Data Analysis")
        print("6. Multi-Stream Performance Test")
        print("7. Continuous Data Logger (30s)")
        print("8. Run All Tests")
        print("0. Exit")
        
        choice = input("\nSelect test (0-8): ")
        
        try:
            if choice == '1':
                test_connection()
            elif choice == '2':
                test_stream_capabilities()
            elif choice == '3':
                test_rgb_data()
            elif choice == '4':
                test_depth_data()
            elif choice == '5':
                test_infrared_data()
            elif choice == '6':
                test_multi_stream_performance()
            elif choice == '7':
                duration = input("Enter duration in seconds (default 30): ")
                duration = int(duration) if duration else 30
                test_data_logger(duration)
            elif choice == '8':
                # Run all tests
                print("\nRunning all tests...")
                if test_connection():
                    test_stream_capabilities()
                    test_rgb_data()
                    test_depth_data()
                    test_infrared_data()
                    test_multi_stream_performance()
                    print("\nAll tests completed!")
                else:
                    print("Connection test failed. Please check your device.")
            elif choice == '0':
                print("Exiting...")
                break
            else:
                print("Invalid choice. Please try again.")
                
        except KeyboardInterrupt:
            print("\nTest interrupted by user")
        except Exception as e:
            print(f"\nERROR: {str(e)}")
            print("Make sure:")
            print("  1. Camera is connected")
            print("  2. pyrealsense2 is installed: pip3 install pyrealsense2")
            print("  3. User has USB permissions: sudo usermod -a -G video $USER")
            print("  4. Then logout and login again")
            
    print("\nTest suite finished.")
================================================================================


================================================================================
FILE: Test_folder/Camera_Test/D435/power_test.py
Category: Python | Size: 18.5 KB | Lines: 484
================================================================================
#!/usr/bin/env python3 power test
"""
Intel RealSense D435 Power and Connection Diagnostics for Raspberry Pi
Checks power status, USB connection, and helps diagnose frame timeout issues
"""

import pyrealsense2 as rs
import numpy as np
import time
import subprocess
import os
import json
from datetime import datetime

class RealSenseDiagnostics:
    def __init__(self):
        self.results = {
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'tests': {}
        }
        
    def run_command(self, cmd):
        """Run system command and return output"""
        try:
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            return result.stdout.strip()
        except:
            return "Command failed"
    
    def check_usb_power(self):
        """Check USB power status and current draw"""
        print("\n" + "="*60)
        print("USB POWER DIAGNOSTICS")
        print("="*60)
        
        results = {}
        
        # Check USB devices and their power status
        print("\n1. USB Device Tree:")
        lsusb_output = self.run_command("lsusb -t")
        print(lsusb_output)
        
        # Find RealSense device
        print("\n2. RealSense USB Details:")
        lsusb_verbose = self.run_command("lsusb -v 2>/dev/null | grep -A 10 -B 5 'Intel.*RealSense'")
        if lsusb_verbose:
            print(lsusb_verbose)
            # Extract power information
            max_power = self.run_command("lsusb -v 2>/dev/null | grep -A 20 'Intel.*RealSense' | grep MaxPower")
            if max_power:
                print(f"\nMax Power Required: {max_power}")
                results['max_power'] = max_power
        
        # Check USB port power limits
        print("\n3. USB Port Power Status:")
        usb_power_files = []
        for root, dirs, files in os.walk("/sys/bus/usb/devices/"):
            if "bMaxPower" in files:
                usb_power_files.append(os.path.join(root, "bMaxPower"))
        
        for power_file in usb_power_files:
            try:
                with open(power_file, 'r') as f:
                    power_value = f.read().strip()
                device_path = os.path.dirname(power_file)
                product_file = os.path.join(device_path, "product")
                if os.path.exists(product_file):
                    with open(product_file, 'r') as f:
                        product = f.read().strip()
                        if "RealSense" in product or "Intel" in product:
                            print(f"  Device: {product}")
                            print(f"  Max Power: {power_value} mA")
                            results['device_power'] = f"{power_value} mA"
            except:
                pass
        
        # Check if using USB 3.0
        print("\n4. USB Speed Check:")
        usb_speed = self.run_command("lsusb -t | grep -A 1 -B 1 'Intel'")
        print(usb_speed)
        if "5000M" in usb_speed:
            print("✓ Running at USB 3.0 speed (5000M)")
            results['usb_speed'] = "USB 3.0 (5000M)"
        elif "480M" in usb_speed:
            print("⚠ Running at USB 2.0 speed (480M) - This may cause issues!")
            results['usb_speed'] = "USB 2.0 (480M) - WARNING"
        
        self.results['tests']['usb_power'] = results
        return results
    
    def check_realsense_connection(self):
        """Test basic RealSense connection with detailed error handling"""
        print("\n" + "="*60)
        print("REALSENSE CONNECTION TEST")
        print("="*60)
        
        results = {'status': 'unknown', 'details': {}}
        
        try:
            ctx = rs.context()
            devices = ctx.query_devices()
            
            if len(devices) == 0:
                print("❌ No RealSense devices found!")
                results['status'] = 'no_device'
                
                # Check if device appears in system
                print("\nChecking system recognition:")
                lsusb = self.run_command("lsusb | grep Intel")
                if lsusb:
                    print(f"System sees device: {lsusb}")
                    print("Device visible to system but not to RealSense SDK")
                    results['details']['system_visible'] = True
                else:
                    print("Device not visible to system")
                    results['details']['system_visible'] = False
                
                return results
            
            print(f"✓ Found {len(devices)} RealSense device(s)")
            results['status'] = 'connected'
            results['details']['device_count'] = len(devices)
            
            for i, dev in enumerate(devices):
                print(f"\nDevice {i}:")
                device_info = {}
                
                try:
                    device_info['name'] = dev.get_info(rs.camera_info.name)
                    device_info['serial'] = dev.get_info(rs.camera_info.serial_number)
                    device_info['firmware'] = dev.get_info(rs.camera_info.firmware_version)
                    device_info['usb_type'] = dev.get_info(rs.camera_info.usb_type_descriptor)
                    
                    for key, value in device_info.items():
                        print(f"  {key}: {value}")
                    
                    results['details'][f'device_{i}'] = device_info
                    
                    # Check if firmware update recommended
                    if device_info['firmware'] < "05.13.00":
                        print("  ⚠ Firmware update recommended for better stability")
                        
                except Exception as e:
                    print(f"  Error getting device info: {e}")
                    
        except Exception as e:
            print(f"❌ Connection error: {e}")
            results['status'] = 'error'
            results['details']['error'] = str(e)
            
        self.results['tests']['connection'] = results
        return results
    
    def test_minimal_stream(self):
        """Test with minimal configuration to isolate power issues"""
        print("\n" + "="*60)
        print("MINIMAL STREAM TEST")
        print("="*60)
        
        test_configs = [
            {
                'name': 'Ultra Low - Depth 240x180 @ 6fps',
                'stream': rs.stream.depth,
                'width': 240,
                'height': 180,
                'format': rs.format.z16,
                'fps': 6
            },
            {
                'name': 'Low - Depth 480x270 @ 15fps',
                'stream': rs.stream.depth,
                'width': 480,
                'height': 270,
                'format': rs.format.z16,
                'fps': 15
            },
            {
                'name': 'Low - Color 424x240 @ 15fps',
                'stream': rs.stream.color,
                'width': 424,
                'height': 240,
                'format': rs.format.bgr8,
                'fps': 15
            },
            {
                'name': 'Standard - Depth 640x480 @ 30fps',
                'stream': rs.stream.depth,
                'width': 640,
                'height': 480,
                'format': rs.format.z16,
                'fps': 30
            }
        ]
        
        results = []
        
        for config in test_configs:
            print(f"\nTesting: {config['name']}")
            result = {
                'config': config['name'],
                'status': 'failed',
                'frames_received': 0,
                'errors': []
            }
            
            pipeline = rs.pipeline()
            rs_config = rs.config()
            
            try:
                # Enable single stream with specific configuration
                rs_config.enable_stream(
                    config['stream'], 
                    config['width'], 
                    config['height'], 
                    config['format'], 
                    config['fps']
                )
                
                # Start with custom timeout
                pipeline_profile = pipeline.start(rs_config)
                
                print("  Stream started, attempting to capture frames...")
                
                # Try different timeout values
                timeout_tests = [1000, 5000, 10000]  # milliseconds
                
                for timeout in timeout_tests:
                    try:
                        print(f"  Testing with {timeout}ms timeout...")
                        frames = pipeline.wait_for_frames(timeout)
                        
                        if frames:
                            result['frames_received'] += 1
                            print(f"    ✓ Frame received with {timeout}ms timeout")
                            
                            # Try to get 10 frames
                            for i in range(9):
                                frames = pipeline.wait_for_frames(timeout)
                                if frames:
                                    result['frames_received'] += 1
                            
                            result['status'] = 'success'
                            result['working_timeout'] = timeout
                            break
                            
                    except Exception as e:
                        error_msg = f"Timeout {timeout}ms: {str(e)}"
                        result['errors'].append(error_msg)
                        print(f"    ❌ {error_msg}")
                
                print(f"  Total frames received: {result['frames_received']}")
                
            except Exception as e:
                error_msg = f"Pipeline start error: {str(e)}"
                result['errors'].append(error_msg)
                print(f"  ❌ {error_msg}")
                
            finally:
                try:
                    pipeline.stop()
                except:
                    pass
            
            results.append(result)
            time.sleep(2)  # Brief pause between tests
        
        self.results['tests']['minimal_stream'] = results
        return results
    
    def test_power_recovery(self):
        """Test camera recovery after power cycling"""
        print("\n" + "="*60)
        print("POWER RECOVERY TEST")
        print("="*60)
        
        results = {
            'recovery_attempts': [],
            'recommendations': []
        }
        
        print("Testing camera initialization and recovery...")
        
        for attempt in range(3):
            print(f"\nAttempt {attempt + 1}:")
            attempt_result = {
                'attempt': attempt + 1,
                'status': 'failed',
                'time_to_ready': None
            }
            
            try:
                # Reset USB if possible (requires sudo)
                if os.geteuid() == 0:
                    print("  Resetting USB hub...")
                    self.run_command("echo '1-1' > /sys/bus/usb/drivers/usb/unbind 2>/dev/null")
                    time.sleep(2)
                    self.run_command("echo '1-1' > /sys/bus/usb/drivers/usb/bind 2>/dev/null")
                    time.sleep(3)
                
                start_time = time.time()
                
                # Try to initialize
                ctx = rs.context()
                devices = ctx.query_devices()
                
                if len(devices) > 0:
                    init_time = time.time() - start_time
                    attempt_result['time_to_ready'] = init_time
                    print(f"  ✓ Device ready in {init_time:.2f} seconds")
                    
                    # Quick stream test
                    pipeline = rs.pipeline()
                    config = rs.config()
                    config.enable_stream(rs.stream.depth, 480, 270, rs.format.z16, 15)
                    
                    pipeline.start(config)
                    frames = pipeline.wait_for_frames(10000)
                    pipeline.stop()
                    
                    if frames:
                        attempt_result['status'] = 'success'
                        print("  ✓ Stream test successful")
                    else:
                        print("  ⚠ Device found but stream failed")
                        
                else:
                    print("  ❌ No device found")
                    
            except Exception as e:
                print(f"  ❌ Error: {e}")
                attempt_result['error'] = str(e)
            
            results['recovery_attempts'].append(attempt_result)
            
            if attempt < 2:
                print("  Waiting 5 seconds before next attempt...")
                time.sleep(5)
        
        # Analyze results and provide recommendations
        successful_attempts = [a for a in results['recovery_attempts'] if a['status'] == 'success']
        
        if len(successful_attempts) == 0:
            results['recommendations'].extend([
                "CRITICAL: Camera fails to initialize reliably",
                "1. Check Y-splitter cable quality and connections",
                "2. Try a powered USB 3.0 hub instead of Y-splitter",
                "3. Ensure total power supply can provide at least 2A",
                "4. Test with shorter USB cable (under 1 meter)"
            ])
        elif len(successful_attempts) < 3:
            results['recommendations'].extend([
                "WARNING: Camera initialization is intermittent",
                "1. Power supply may be marginal - increase current capacity",
                "2. USB connection may be unstable - check all connections",
                "3. Consider adding capacitor across power lines for stability"
            ])
        else:
            results['recommendations'].append("Camera initialization is stable")
        
        self.results['tests']['power_recovery'] = results
        return results
    
    def check_system_resources(self):
        """Check Raspberry Pi system resources"""
        print("\n" + "="*60)
        print("SYSTEM RESOURCES CHECK")
        print("="*60)
        
        results = {}
        
        # CPU temperature
        temp_output = self.run_command("vcgencmd measure_temp")
        print(f"CPU Temperature: {temp_output}")
        results['cpu_temp'] = temp_output
        
        # Check for throttling
        throttle_output = self.run_command("vcgencmd get_throttled")
        print(f"Throttle Status: {throttle_output}")
        if "0x0" not in throttle_output:
            print("⚠ WARNING: System throttling detected!")
            print("  This indicates power or temperature issues")
        results['throttle_status'] = throttle_output
        
        # Memory usage
        mem_output = self.run_command("free -m | grep Mem")
        print(f"\nMemory Usage:\n{mem_output}")
        results['memory'] = mem_output
        
        # USB controller info
        print("\nUSB Controller:")
        usb_controller = self.run_command("lspci 2>/dev/null | grep USB || echo 'Using onboard USB'")
        print(usb_controller)
        
        self.results['tests']['system_resources'] = results
        return results
    
    def generate_report(self):
        """Generate diagnostic report with recommendations"""
        print("\n" + "="*60)
        print("DIAGNOSTIC SUMMARY")
        print("="*60)
        
        # Save detailed results
        with open('realsense_diagnostic_report.json', 'w') as f:
            json.dump(self.results, f, indent=2)
        
        print("\nKey Findings:")
        
        # Check USB power
        if 'usb_power' in self.results['tests']:
            usb_test = self.results['tests']['usb_power']
            if 'usb_speed' in usb_test:
                if "USB 2.0" in usb_test['usb_speed']:
                    print("❌ CRITICAL: Running on USB 2.0 - insufficient bandwidth")
                else:
                    print("✓ USB 3.0 connection confirmed")
        
        # Check connection
        if 'connection' in self.results['tests']:
            conn_test = self.results['tests']['connection']
            if conn_test['status'] == 'connected':
                print("✓ Camera detected by RealSense SDK")
            else:
                print("❌ Camera not properly detected")
        
        # Check streaming
        if 'minimal_stream' in self.results['tests']:
            stream_results = self.results['tests']['minimal_stream']
            working_configs = [r for r in stream_results if r['status'] == 'success']
            if working_configs:
                print(f"✓ {len(working_configs)} configurations work")
                print(f"  Recommended: {working_configs[0]['config']}")
            else:
                print("❌ No configurations work reliably")
        
        print("\n" + "-"*60)
        print("RECOMMENDATIONS FOR YOUR SETUP:")
        print("-"*60)
        
        print("\n1. IMMEDIATE ACTIONS:")
        print("   - Verify Y-splitter is connected properly (data to Pi, power to adapter)")
        print("   - Ensure power adapter provides at least 2A @ 5V")
        print("   - Try connecting directly to Pi USB 3.0 port without splitter")
        
        print("\n2. POWER SOLUTIONS:")
        print("   - Best: Use powered USB 3.0 hub (recommended: 3A+ per port)")
        print("   - Alternative: Official RealSense power cable")
        print("   - Check: Measure voltage at camera (should be 4.75V-5.25V)")
        
        print("\n3. SOFTWARE OPTIMIZATIONS:")
        print("   - Start with lower resolution: 480x270 @ 15fps")
        print("   - Increase pipeline timeout: wait_for_frames(10000)")
        print("   - Disable auto-exposure initially")
        print("   - Use single stream before attempting multiple")
        
        print("\n4. TROUBLESHOOTING STEPS:")
        print("   a. Test with external powered hub")
        print("   b. Monitor dmesg during connection: dmesg -w")
        print("   c. Try different USB ports")
        print("   d. Update camera firmware if needed")
        
        print("\nDetailed report saved to: realsense_diagnostic_report.json")

def main():
    print("Intel RealSense D435 Diagnostic Tool")
    print("For Raspberry Pi with Y-Splitter Power Setup")
    print("="*60)
    
    if os.geteuid() != 0:
        print("Note: Running as user. Some tests may be limited.")
        print("For full diagnostics, run with: sudo python3 diagnostics.py")
    
    diag = RealSenseDiagnostics()
    
    # Run all diagnostics
    diag.check_system_resources()
    diag.check_usb_power()
    diag.check_realsense_connection()
    diag.test_minimal_stream()
    diag.test_power_recovery()
    diag.generate_report()

if __name__ == "__main__":
    main()
================================================================================


================================================================================
FILE: Test_folder/Camera_Test/D435/usb_reset.py
Category: Python | Size: 11.1 KB | Lines: 324
================================================================================
#!/usr/bin/env python3
"""
Manual USB Reset Methods for RealSense D435
Works without additional packages
"""

import subprocess
import os
import time
import sys

def create_usbreset_tool():
    """Create and compile usbreset tool if it doesn't exist"""
    if os.path.exists('/usr/local/bin/usbreset'):
        return True
    
    print("Creating usbreset tool...")
    
    usbreset_code = '''
/* usbreset -- send a USB port reset to a USB device */
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <linux/usbdevice_fs.h>

int main(int argc, char **argv)
{
    const char *filename;
    int fd;
    int rc;

    if (argc != 2) {
        fprintf(stderr, "Usage: usbreset device-filename\\n");
        return 1;
    }
    filename = argv[1];

    fd = open(filename, O_WRONLY);
    if (fd < 0) {
        perror("Error opening output file");
        return 1;
    }

    printf("Resetting USB device %s\\n", filename);
    rc = ioctl(fd, USBDEVFS_RESET, 0);
    if (rc < 0) {
        perror("Error in ioctl");
        return 1;
    }
    printf("Reset successful\\n");

    close(fd);
    return 0;
}
'''
    
    try:
        # Write source code
        with open('/tmp/usbreset.c', 'w') as f:
            f.write(usbreset_code)
        
        # Compile
        result = subprocess.run(['gcc', '/tmp/usbreset.c', '-o', '/tmp/usbreset'], 
                              capture_output=True, text=True)
        if result.returncode != 0:
            print(f"Compilation failed: {result.stderr}")
            return False
        
        # Install
        subprocess.run(['sudo', 'cp', '/tmp/usbreset', '/usr/local/bin/'], check=True)
        subprocess.run(['sudo', 'chmod', '+x', '/usr/local/bin/usbreset'], check=True)
        
        # Cleanup
        os.remove('/tmp/usbreset.c')
        os.remove('/tmp/usbreset')
        
        print("usbreset tool created successfully!")
        return True
        
    except Exception as e:
        print(f"Failed to create usbreset: {e}")
        return False


def find_realsense_device():
    """Find RealSense device information"""
    try:
        result = subprocess.run(['lsusb'], capture_output=True, text=True)
        for line in result.stdout.split('\n'):
            if 'Intel Corp.' in line and 'RealSense' in line:
                # Extract bus and device numbers
                parts = line.split()
                bus = parts[1]
                device = parts[3].rstrip(':')
                
                # Pad with zeros
                bus = bus.zfill(3)
                device = device.zfill(3)
                
                return bus, device, line.strip()
    except Exception as e:
        print(f"Error finding device: {e}")
    
    return None, None, None


def reset_using_usbreset(bus, device):
    """Reset USB device using usbreset tool"""
    device_path = f"/dev/bus/usb/{bus}/{device}"
    
    if not os.path.exists(device_path):
        print(f"Device path {device_path} does not exist")
        return False
    
    try:
        print(f"Resetting device at {device_path}...")
        result = subprocess.run(['sudo', 'usbreset', device_path], 
                              capture_output=True, text=True)
        print(result.stdout)
        if result.returncode == 0:
            return True
        else:
            print(f"Reset failed: {result.stderr}")
            return False
    except Exception as e:
        print(f"usbreset error: {e}")
        return False


def reset_using_sysfs():
    """Reset USB device using sysfs unbind/bind method"""
    print("\nTrying sysfs reset method...")
    
    try:
        # Find all USB devices
        result = subprocess.run(['find', '/sys/bus/usb/devices/', '-name', 'idVendor', 
                               '-type', 'f', '-readable'], 
                              capture_output=True, text=True)
        
        for vendor_path in result.stdout.strip().split('\n'):
            if not vendor_path:
                continue
                
            try:
                with open(vendor_path, 'r') as f:
                    vendor_id = f.read().strip()
                    
                if vendor_id == '8086':  # Intel vendor ID
                    device_path = os.path.dirname(vendor_path)
                    product_path = os.path.join(device_path, 'idProduct')
                    
                    if os.path.exists(product_path):
                        with open(product_path, 'r') as f:
                            product_id = f.read().strip()
                            
                        # RealSense D435 product IDs
                        if product_id.lower() in ['0b07', '0b3a']:
                            print(f"Found RealSense at: {device_path}")
                            device_name = os.path.basename(device_path)
                            
                            # Check if authorized file exists (USB authorization method)
                            auth_path = os.path.join(device_path, 'authorized')
                            if os.path.exists(auth_path):
                                print("Using USB authorization reset...")
                                # Deauthorize
                                subprocess.run(['sudo', 'sh', '-c', 
                                              f'echo 0 > {auth_path}'], check=True)
                                time.sleep(1)
                                # Reauthorize
                                subprocess.run(['sudo', 'sh', '-c', 
                                              f'echo 1 > {auth_path}'], check=True)
                                print("Authorization reset completed")
                                return True
                            
                            # Try unbind/bind method
                            unbind_path = '/sys/bus/usb/drivers/usb/unbind'
                            bind_path = '/sys/bus/usb/drivers/usb/bind'
                            
                            if os.path.exists(unbind_path) and os.path.exists(bind_path):
                                print("Using unbind/bind reset...")
                                # Unbind
                                subprocess.run(['sudo', 'sh', '-c', 
                                              f'echo {device_name} > {unbind_path}'], 
                                             check=True)
                                time.sleep(1)
                                # Bind
                                subprocess.run(['sudo', 'sh', '-c', 
                                              f'echo {device_name} > {bind_path}'], 
                                             check=True)
                                print("Unbind/bind reset completed")
                                return True
                                
            except Exception as e:
                continue
                
    except Exception as e:
        print(f"Sysfs reset error: {e}")
    
    return False


def reset_using_power_control():
    """Try to control USB port power if supported"""
    print("\nTrying USB power control method...")
    
    try:
        # Find USB hubs that support power control
        result = subprocess.run(['find', '/sys/bus/usb/devices/', '-name', 'power', 
                               '-type', 'd'], 
                              capture_output=True, text=True)
        
        for power_dir in result.stdout.strip().split('\n'):
            if not power_dir:
                continue
                
            control_path = os.path.join(power_dir, 'control')
            if os.path.exists(control_path):
                device_path = os.path.dirname(power_dir)
                
                # Check if this is related to our RealSense device
                product_path = os.path.join(device_path, 'product')
                if os.path.exists(product_path):
                    try:
                        with open(product_path, 'r') as f:
                            product = f.read().strip()
                        
                        if 'RealSense' in product:
                            print(f"Found RealSense power control at: {control_path}")
                            
                            # Cycle power
                            subprocess.run(['sudo', 'sh', '-c', 
                                          f'echo auto > {control_path}'], check=True)
                            time.sleep(0.5)
                            subprocess.run(['sudo', 'sh', '-c', 
                                          f'echo on > {control_path}'], check=True)
                            print("Power cycle completed")
                            return True
                            
                    except:
                        continue
                        
    except Exception as e:
        print(f"Power control error: {e}")
    
    return False


def perform_full_reset():
    """Perform a complete USB reset trying all available methods"""
    print("=== RealSense USB Reset Tool ===\n")
    
    # Find device
    bus, device, info = find_realsense_device()
    
    if not bus:
        print("ERROR: No RealSense device found!")
        print("\nPlease check:")
        print("1. Is the camera connected?")
        print("2. Try: lsusb | grep -i real")
        return False
    
    print(f"Found: {info}")
    print(f"Bus: {bus}, Device: {device}")
    
    # Method 1: Try usbreset tool
    if os.path.exists('/usr/local/bin/usbreset'):
        print("\nMethod 1: Using usbreset tool...")
        if reset_using_usbreset(bus, device):
            print("Success!")
            return True
    else:
        print("\nusbreset tool not found. Creating it...")
        if create_usbreset_tool():
            if reset_using_usbreset(bus, device):
                print("Success!")
                return True
    
    # Method 2: Try sysfs reset
    print("\nMethod 1 failed. Trying Method 2: sysfs reset...")
    if reset_using_sysfs():
        print("Success!")
        return True
    
    # Method 3: Try power control
    print("\nMethod 2 failed. Trying Method 3: power control...")
    if reset_using_power_control():
        print("Success!")
        return True
    
    print("\n*** All reset methods failed ***")
    print("\nManual reset options:")
    print("1. Unplug and replug the USB cable")
    print("2. Try a different USB port")
    print("3. Reboot the Raspberry Pi: sudo reboot")
    
    return False


if __name__ == "__main__":
    if os.geteuid() != 0:
        print("Note: This script may need sudo privileges for some operations.")
        print("If it fails, try running with: sudo python3", sys.argv[0])
        print()
    
    # Check for gcc (needed to compile usbreset)
    try:
        subprocess.run(['gcc', '--version'], capture_output=True, check=True)
    except:
        print("WARNING: gcc not found. Installing build-essential...")
        subprocess.run(['sudo', 'apt-get', 'install', '-y', 'build-essential'])
    
    # Perform reset
    success = perform_full_reset()
    
    if success:
        print("\nUSB reset completed successfully!")
        print("Wait 3-5 seconds before trying to use the camera again.")
        time.sleep(3)
    else:
        print("\nUSB reset failed. Please try manual methods.")
    
    sys.exit(0 if success else 1)
================================================================================


================================================================================
FILE: Test_folder/Camera_Test/Thermal_Camera_test/save_frame_local.py
Category: Python | Size: 5.9 KB | Lines: 140
================================================================================
#!/usr/bin/env python3
"""
Read an MLX-90640 thermal camera, display the 24×32 matrix in the terminal,
and save each frame to a CSV file locally.
"""

import sys, time, warnings, board, busio, numpy as np
import adafruit_mlx90640
import os
from datetime import datetime

# ─── USER SETTINGS ────────────────────────────────────────────────────────────
REFRESH_RATE      = adafruit_mlx90640.RefreshRate.REFRESH_1_HZ  # sensor at 1 Hz
DISPLAY_INTERVAL  = 2.0      # seconds between displays
SAVE_EVERY_FRAME  = True     # save every frame, not just displayed ones
SHOW_STATS        = True     # show min/max/avg temperature
SAVE_DIRECTORY    = "thermal_data"  # directory to save CSV files
BACKOFF_BASE_S    = 0.1
BACKOFF_MAX_S     = 2.0
# ───────────────────────────────────────────────────────────────────────────────

warnings.filterwarnings(
    "ignore", category=RuntimeWarning,
    message="I2C frequency is not settable in python, ignoring!"
)

# Create save directory if it doesn't exist
if not os.path.exists(SAVE_DIRECTORY):
    os.makedirs(SAVE_DIRECTORY)
    print(f"Created directory: {SAVE_DIRECTORY}")

i2c = busio.I2C(board.SCL, board.SDA)            # bus already at 100 kHz
mlx = adafruit_mlx90640.MLX90640(i2c)
mlx.refresh_rate = REFRESH_RATE                   # 1 Hz is stable
flat = np.zeros(24 * 32, dtype=np.float32)

print(f"MLX90640 Thermal Camera - Displaying every {DISPLAY_INTERVAL} seconds")
print(f"Saving frames to: {os.path.abspath(SAVE_DIRECTORY)}/")
print("Press Ctrl+C to stop\n")

frames_seen = 0
frames_saved = 0
retries = 0
last_display_time = 0

def save_frame_to_csv(frame_2d, frame_number):
    """Save a single frame to a CSV file with timestamp"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")[:-3]  # milliseconds
    filename = f"thermal_frame_{timestamp}_f{frame_number:06d}.csv"
    filepath = os.path.join(SAVE_DIRECTORY, filename)
    
    try:
        # Save with header showing frame info
        header = f"Frame {frame_number}, Time: {datetime.now().isoformat()}, Shape: 24x32"
        np.savetxt(filepath, frame_2d, delimiter=',', fmt='%.2f', header=header)
        return True, filepath
    except Exception as e:
        print(f"Error saving frame: {e}", file=sys.stderr)
        return False, None

try:
    while True:
        try:
            mlx.getFrame(flat)
            frames_seen += 1
            current_time = time.time()
            
            # Reshape for processing
            frame2d = flat.reshape((24, 32))
            
            # Save frame if enabled
            if SAVE_EVERY_FRAME:
                success, filepath = save_frame_to_csv(frame2d, frames_seen)
                if success:
                    frames_saved += 1
                    # Show save confirmation in terminal
                    print(f"\r[Frame {frames_seen}] Saved: {os.path.basename(filepath)} | "
                          f"Min: {flat.min():.1f}°C, Max: {flat.max():.1f}°C, "
                          f"Avg: {flat.mean():.1f}°C", end='', flush=True)

            # Display detailed view at specified interval
            if current_time - last_display_time >= DISPLAY_INTERVAL:
                # Clear previous single-line output
                print("\r" + " " * 100 + "\r", end='')
                
                # Clear screen for cleaner display (optional)
                print("\033[2J\033[H", end='')  # ANSI escape codes to clear screen
                
                np.set_printoptions(precision=1, suppress=True, linewidth=200)
                
                print(f"Frame #{frames_seen} - Thermal Data (°C):")
                print("=" * 80)
                print(frame2d)
                
                if SHOW_STATS:
                    print("\n" + "─" * 40)
                    print(f"Min Temperature:  {flat.min():.1f}°C")
                    print(f"Max Temperature:  {flat.max():.1f}°C")
                    print(f"Avg Temperature:  {flat.mean():.1f}°C")
                    print(f"Center Temp:      {frame2d[12, 16]:.1f}°C")  # center pixel
                    
                    # Find hottest spot
                    max_idx = np.argmax(flat)
                    max_row, max_col = divmod(max_idx, 32)
                    print(f"Hottest Pixel:    [{max_row}, {max_col}] = {flat[max_idx]:.1f}°C")
                
                print(f"\nFrames captured: {frames_seen} | Frames saved: {frames_saved}")
                print("Files saved to:", os.path.abspath(SAVE_DIRECTORY))
                print("=" * 80 + "\n")
                
                last_display_time = current_time

            retries = 0  # good read → reset back-off

        except ValueError:  # CRC error
            wait = min(BACKOFF_BASE_S * (retries + 1), BACKOFF_MAX_S)
            retries += 1
            print(f"\nCRC error – retrying in {wait:.1f} s (attempt {retries})",
                  file=sys.stderr, flush=True)
            time.sleep(wait)

        except OSError as e:  # other I²C hiccup
            wait = min(BACKOFF_BASE_S * (retries + 1), BACKOFF_MAX_S)
            retries += 1
            print(f"\nI²C error ({e}) – retrying in {wait:.1f} s (attempt {retries})",
                  file=sys.stderr, flush=True)
            time.sleep(wait)

except KeyboardInterrupt:
    print("\n\nStopped cleanly.")
    print(f"Total frames read: {frames_seen}")
    print(f"Total frames saved: {frames_saved}")
    print(f"Data saved in: {os.path.abspath(SAVE_DIRECTORY)}/")
    
    # Show last few saved files
    if frames_saved > 0:
        files = sorted(os.listdir(SAVE_DIRECTORY))[-5:]  # last 5 files
        print("\nLast saved files:")
        for f in files:
            print(f"  - {f}")
================================================================================


================================================================================
FILE: Test_folder/Camera_Test/Thermal_Camera_test/short_CRC_test.py
Category: Python | Size: 498.0 B | Lines: 15
================================================================================
import time, board, busio, numpy as np, adafruit_mlx90640
i2c = busio.I2C(board.SCL, board.SDA)                 # no frequency arg
mlx = adafruit_mlx90640.MLX90640(i2c)
mlx.refresh_rate = adafruit_mlx90640.RefreshRate.REFRESH_1_HZ
buf = np.zeros(24*32, dtype=np.float32)

good = bad = 0
t0 = time.time()
while time.time() - t0 < 30:                          # 30 s window
    try:
        mlx.getFrame(buf)
        good += 1
    except ValueError:
        bad += 1
print(f"good {good}, CRC {bad}")

================================================================================


================================================================================
FILE: Test_folder/Camera_Test/Thermal_Camera_test/thermal_camera_test.py
Category: Python | Size: 3.4 KB | Lines: 83
================================================================================
#!/usr/bin/env python3
"""
Read an MLX-90640 thermal camera and display the 24×32 matrix in the terminal.
No CSV saving - just live display.
"""

import sys, time, warnings, board, busio, numpy as np
import adafruit_mlx90640

# ─── USER SETTINGS ────────────────────────────────────────────────────────────
REFRESH_RATE      = adafruit_mlx90640.RefreshRate.REFRESH_1_HZ  # sensor at 1 Hz
DISPLAY_INTERVAL  = 2.0      # seconds between displays
SHOW_STATS        = True     # show min/max/avg temperature
BACKOFF_BASE_S    = 0.1
BACKOFF_MAX_S     = 2.0
# ───────────────────────────────────────────────────────────────────────────────

warnings.filterwarnings(
    "ignore", category=RuntimeWarning,
    message="I2C frequency is not settable in python, ignoring!"
)

i2c = busio.I2C(board.SCL, board.SDA)            # bus already at 100 kHz
mlx = adafruit_mlx90640.MLX90640(i2c)
mlx.refresh_rate = REFRESH_RATE                   # 1 Hz is stable
flat = np.zeros(24 * 32, dtype=np.float32)

print(f"MLX90640 Thermal Camera - Displaying every {DISPLAY_INTERVAL} seconds")
print("Press Ctrl+C to stop\n")

frames_seen = 0
retries = 0
last_display_time = 0

try:
    while True:
        try:
            mlx.getFrame(flat)
            frames_seen += 1
            current_time = time.time()

            # Only display at the specified interval
            if current_time - last_display_time >= DISPLAY_INTERVAL:
                # Clear screen for cleaner display (optional)
                print("\033[2J\033[H", end='')  # ANSI escape codes to clear screen
                
                # Reshape for nice console output
                frame2d = flat.reshape((24, 32))
                np.set_printoptions(precision=1, suppress=True, linewidth=200)
                
                print(f"Frame #{frames_seen} - Thermal Data (°C):")
                print("=" * 80)
                print(frame2d)
                
                if SHOW_STATS:
                    print("\n" + "─" * 40)
                    print(f"Min Temperature:  {flat.min():.1f}°C")
                    print(f"Max Temperature:  {flat.max():.1f}°C")
                    print(f"Avg Temperature:  {flat.mean():.1f}°C")
                    print(f"Center Temp:      {frame2d[12, 16]:.1f}°C")  # center pixel
                
                print("\n" + "=" * 80 + "\n")
                last_display_time = current_time

            retries = 0  # good read → reset back-off

        except ValueError:  # CRC error
            wait = min(BACKOFF_BASE_S * (retries + 1), BACKOFF_MAX_S)
            retries += 1
            print(f"CRC error – retrying in {wait:.1f} s (attempt {retries})",
                  file=sys.stderr, flush=True)
            time.sleep(wait)

        except OSError as e:  # other I²C hiccup
            wait = min(BACKOFF_BASE_S * (retries + 1), BACKOFF_MAX_S)
            retries += 1
            print(f"I²C error ({e}) – retrying in {wait:.1f} s (attempt {retries})",
                  file=sys.stderr, flush=True)
            time.sleep(wait)

except KeyboardInterrupt:
    print("\n\nStopped cleanly.")
    print(f"Total frames read: {frames_seen}")
================================================================================


================================================================================
FILE: Test_folder/Motor Channel Mapping/channel_mapping_client.py
Category: Python | Size: 4.8 KB | Lines: 158
================================================================================
from __future__ import annotations

import socket
import signal
import sys
from typing import Dict, Tuple

try:
    import board  # type: ignore
    import busio  # type: ignore
    import adafruit_pca9685  # type: ignore
    HARDWARE = True
except ImportError:
    # Dummy fallback so the script is testable on non‑Pi hosts.
    HARDWARE = False

    class _DummyCh:
        def __init__(self):
            self.duty_cycle = 0
    class _DummyPCA:
        def __init__(self):
            self.channels = [_DummyCh() for _ in range(16)]
            self.frequency = 100
    class _DummyI2C: pass
    class _DummyBusio:
        @staticmethod
        def I2C(*_):
            return _DummyI2C()
    class _DummyBoard:
        SCL = None
        SDA = None
    board = _DummyBoard()  # type: ignore
    busio = _DummyBusio()  # type: ignore
    adafruit_pca9685 = type("adafruit_pca9685", (), {"PCA9685": _DummyPCA})  # type: ignore

# ---------------------------------------------------------------------------
# Globals
# ---------------------------------------------------------------------------
FORWARD_POLARITY = (0, 0xFFFF)
BACKWARD_POLARITY = (0xFFFF, 0)

MOTOR_MAP: Dict[int, Tuple[int, int]] = {}

# ---------------------------------------------------------------------------
# Hardware init
# ---------------------------------------------------------------------------
i2c = busio.I2C(board.SCL, board.SDA)  # type: ignore
pca = adafruit_pca9685.PCA9685(i2c)    # type: ignore
pca.frequency = 100

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def clamp(val: int, lo: int = 0, hi: int = 65535) -> int:
    return max(lo, min(hi, val))


def set_motor(motor_id: int, direction: str, speed: int) -> str:
    if motor_id not in MOTOR_MAP:
        return f"ERROR: motor {motor_id} not mapped"

    speed_ch, dir_ch = MOTOR_MAP[motor_id]
    speed = clamp(speed)

    if direction == "forward":
        pca.channels[dir_ch].duty_cycle = FORWARD_POLARITY[1]
    elif direction == "backward":
        pca.channels[dir_ch].duty_cycle = BACKWARD_POLARITY[1]
    elif direction == "brake":
        pca.channels[dir_ch].duty_cycle = 0
        speed = 0
    else:
        return "ERROR: direction must be forward/backward/brake"

    pca.channels[speed_ch].duty_cycle = speed
    return f"OK: motor={motor_id},dir={direction},speed={speed}"


# ---------------------------------------------------------------------------
# Command parser
# ---------------------------------------------------------------------------

def parse_and_execute(cmd: str) -> str:
    cmd = cmd.strip()
    if cmd == "ping":
        return "pong"

    parts = cmd.split(",")

    # ---- mapping command ----------------------------------------------------
    if parts[0] == "map":
        if len(parts) != 4:
            return "ERROR: format map,<motor_id>,<speed_ch>,<dir_ch>"
        try:
            motor_id, speed_ch, dir_ch = map(int, parts[1:])
        except ValueError:
            return "ERROR: non‑integer values in map command"
        MOTOR_MAP[motor_id] = (speed_ch, dir_ch)
        return (f"OK: mapped motor {motor_id} → speed={speed_ch},dir={dir_ch}")

    # ---- motion command -----------------------------------------------------
    if len(parts) != 3:
        return "ERROR: format <motor_id>,<direction>,<speed>"
    try:
        m_id = int(parts[0])
        dirn = parts[1].lower()
        spd  = int(parts[2])
    except ValueError:
        return "ERROR: non‑integer motor_id or speed"

    return set_motor(m_id, dirn, spd)


# ---------------------------------------------------------------------------
# TCP server
# ---------------------------------------------------------------------------
server_socket: socket.socket | None = None


def clean_exit(_sig, _frm):
    global server_socket
    print("\nShutting down motor server …")
    if server_socket:
        server_socket.close()
    sys.exit(0)

signal.signal(signal.SIGINT, clean_exit)
signal.signal(signal.SIGTERM, clean_exit)


def main() -> None:
    global server_socket
    HOST, PORT = "0.0.0.0", 12345
    print(f"Motor server listening on {HOST}:{PORT}")
    if not HARDWARE:
        print("⚠️  Dummy hardware mode – no real PCA9685 detected.")

    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

    try:
        server_socket.bind((HOST, PORT))
        server_socket.listen()
        while True:
            client, _addr = server_socket.accept()
            with client:
                data = client.recv(1024).decode()
                if data:
                    resp = parse_and_execute(data)
                    client.sendall(resp.encode())
    finally:
        if server_socket:
            server_socket.close()


if __name__ == "__main__":
    main()
================================================================================


================================================================================
FILE: Test_folder/Motor Channel Mapping/channel_mapping_host.py
Category: Python | Size: 2.9 KB | Lines: 73
================================================================================
from flask import Flask, render_template_string, request, jsonify
import socket, sys

# ------------ configuration ------------
PI_IP   = "192.168.2.3"   # "127.0.0.1" if you host on the Pi
PI_PORT = 12345
PWM_CHANNELS = 16          # 0‑15 outputs on PCA9685
MOTOR_ID = 0               # logical motor we exercise
# ---------------------------------------

app = Flask(__name__)

HTML = """<!doctype html><html><head><title>Robot Motor Control</title></head><body>
<h1>Robot Motor Control</h1>
<p><strong>Pi status:</strong> <span id=status>checking…</span></p>
<label>Speed channel:</label>
<select id=speed onchange=mapped()>{% for c in channels %}<option>{{c}}</option>{% endfor %}</select>
&nbsp;&nbsp;
<label>Direction channel:</label>
<select id=dirch onchange=mapped()>{% for c in channels %}<option>{{c}}</option>{% endfor %}</select>
<hr>
<label>Direction</label>
<select id=dir><option value=forward>Forward</option><option value=backward>Backward</option></select>
<label>Speed</label><input type=range id=spd min=0 max=100 value=50 oninput="slbl.textContent=this.value+'%';">
<span id=slbl>50%</span>
<button onclick=run()>Run Motor</button>
<button onclick=brake()>Brake</button>
<p>Response: <span id=resp></span></p>
<script>
function ping(){fetch('/ping').then(r=>r.json()).then(j=>status.textContent=j.ok?'connected':'offline')}
setInterval(ping,2000); ping();
function mapped(){let s=document.getElementById('speed').value;let d=document.getElementById('dirch').value;fetch(`/map/${s}/${d}`).then(r=>r.json()).then(j=>resp.textContent=j.msg)}
function run(){let dir=document.getElementById('dir').value;let pct=document.getElementById('spd').value;let speed=Math.round(pct/100*65535);fetch(`/drive/${dir}/${speed}`).then(r=>r.json()).then(j=>resp.textContent=j.msg)}
function brake(){fetch('/brake').then(r=>r.json()).then(j=>resp.textContent=j.msg)}
</script></body></html>"""

# -------- helper to talk to Pi ---------

def send(cmd: str) -> str:
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.settimeout(2)
            s.connect((PI_IP, PI_PORT))
            s.sendall(cmd.encode())
            return s.recv(1024).decode()
    except Exception as e:
        return f"ERROR: {e}"

# -------------- routes -----------------
@app.route('/')
def index():
    return render_template_string(HTML, channels=list(range(PWM_CHANNELS)))

@app.route('/ping')
def ping():
    return jsonify(ok=(send('ping')=='pong'))

@app.route('/map/<int:speed_ch>/<int:dir_ch>')
def map_motor(speed_ch, dir_ch):
    return jsonify(msg=send(f"map,{MOTOR_ID},{speed_ch},{dir_ch}"))

@app.route('/drive/<dir>/<int:speed>')
def drive(dir, speed):
    return jsonify(msg=send(f"{MOTOR_ID},{dir},{speed}"))

@app.route('/brake')
def brake():
    return jsonify(msg=send(f"{MOTOR_ID},brake,0"))

# -------------- main -------------------
if __name__ == '__main__':
    port = int(sys.argv[1]) if len(sys.argv) > 1 else 9000
    app.run(host='0.0.0.0', port=port, debug=True)
================================================================================


================================================================================
FILE: Test_folder/Trigger_system/WS_control.py
Category: Python | Size: 10.4 KB | Lines: 292
================================================================================
#!/usr/bin/env python3
"""
Linear Actuator Control using PCA9685 with Keyboard Control
W key - Extend at FULL SPEED (hold to continue, release to stop)
S key - Retract at FULL SPEED (hold to continue, release to stop)
Q key - Quit program
Total extension time is limited to 8 seconds cumulative
"""

import time
import sys
import threading
import select
import termios
import tty

try:
    import board
    import busio
    import adafruit_pca9685
    HARDWARE = True
except ImportError:
    print("Warning: PCA9685 libraries not found. Running in simulation mode.")
    HARDWARE = False
    
    # Dummy classes for testing without hardware
    class _DummyChannel:
        def __init__(self):
            self.duty_cycle = 0
    
    class _DummyPCA:
        def __init__(self, i2c=None):
            self.channels = [_DummyChannel() for _ in range(16)]
            self.frequency = 100
    
    class _DummyI2C: pass
    
    class _DummyBusio:
        @staticmethod
        def I2C(*_):
            return _DummyI2C()
    
    class _DummyBoard:
        SCL = None
        SDA = None
    
    board = _DummyBoard()
    busio = _DummyBusio()
    adafruit_pca9685 = type("adafruit_pca9685", (), {"PCA9685": _DummyPCA})


class KeyboardController:
    """Non-blocking keyboard input handler"""
    def __init__(self):
        self.old_settings = termios.tcgetattr(sys.stdin)
        tty.setraw(sys.stdin.fileno())
        
    def get_key(self):
        """Get a single keypress without blocking"""
        if select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], []):
            return sys.stdin.read(1).lower()
        return None
    
    def restore(self):
        """Restore terminal settings"""
        termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.old_settings)


class LinearActuatorPCA9685:
    def __init__(self, in1_channel=4, in2_channel=5, frequency=1000, max_extend_time=8):
        """
        Initialize linear actuator controller using PCA9685
        in1_channel: PCA9685 channel for IN1 (default: 4)
        in2_channel: PCA9685 channel for IN2 (default: 5)
        frequency: PWM frequency in Hz (default: 1000)
        max_extend_time: Maximum CUMULATIVE time allowed for extension in seconds (default: 8)
        """
        # Initialize I2C and PCA9685
        self.i2c = busio.I2C(board.SCL, board.SDA)
        self.pca = adafruit_pca9685.PCA9685(self.i2c)
        self.pca.frequency = frequency
        
        # Store channel numbers
        self.in1_channel = in1_channel
        self.in2_channel = in2_channel
        
        # Safety limit for cumulative extension time
        self.max_extend_time = max_extend_time
        self.total_extend_time = 0.0  # Track cumulative extend time
        
        # Track movement
        self.movement_start_time = None
        self.current_direction = None
        self.is_moving = False
        
        # Initialize channels to 0 (stopped)
        self.stop()
        
        print(f"\nPCA9685 initialized - IN1: Channel {in1_channel}, IN2: Channel {in2_channel}")
        print(f"PWM Frequency: {frequency}Hz")
        print(f"Safety limit - Max cumulative extend time: {max_extend_time}s")
    
    def _set_duty_cycle(self, channel, value):
        """Set duty cycle for a channel (0-65535)"""
        value = max(0, min(65535, value))
        self.pca.channels[channel].duty_cycle = value
    
    def get_remaining_extend_time(self):
        """Get remaining extension time available"""
        return max(0, self.max_extend_time - self.total_extend_time)
    
    def can_extend(self):
        """Check if extension is allowed"""
        return self.get_remaining_extend_time() > 0
    
    def extend(self, speed=100):
        """Extend the linear actuator at specified speed (default 100%)"""
        if not self.can_extend():
            print(f"\n⚠️  Cannot extend: Cumulative limit of {self.max_extend_time}s reached!")
            return False
        
        # Convert percentage to 16-bit duty cycle
        duty_cycle = int((speed / 100.0) * 65535)
        
        # IN1 = HIGH (PWM), IN2 = LOW
        self._set_duty_cycle(self.in1_channel, duty_cycle)
        self._set_duty_cycle(self.in2_channel, 0)
        
        # Track movement
        self.movement_start_time = time.time()
        self.current_direction = "extend"
        self.is_moving = True
        
        remaining = self.get_remaining_extend_time()
        print(f"\nExtending at {speed}% speed... (Remaining time: {remaining:.1f}s)")
        return True
    
    def retract(self, speed=100):
        """Retract the linear actuator at specified speed (default 100%)"""
        # Convert percentage to 16-bit duty cycle
        duty_cycle = int((speed / 100.0) * 65535)
        
        # IN1 = LOW, IN2 = HIGH (PWM)
        self._set_duty_cycle(self.in1_channel, 0)
        self._set_duty_cycle(self.in2_channel, duty_cycle)
        
        # Track movement
        self.movement_start_time = time.time()
        self.current_direction = "retract"
        self.is_moving = True
        
        print(f"\nRetracting at {speed}% speed... (No time limit)")
        return True
    
    def stop(self):
        """Stop the linear actuator"""
        # Update cumulative extend time if we were extending
        if self.is_moving and self.current_direction == "extend" and self.movement_start_time:
            elapsed = time.time() - self.movement_start_time
            self.total_extend_time += elapsed
            print(f"\nStopped. Extended for {elapsed:.1f}s (Total: {self.total_extend_time:.1f}s)")
        elif self.is_moving and self.current_direction == "retract":
            elapsed = time.time() - self.movement_start_time
            print(f"\nStopped. Retracted for {elapsed:.1f}s")
        
        # Both channels to 0
        self._set_duty_cycle(self.in1_channel, 0)
        self._set_duty_cycle(self.in2_channel, 0)
        
        # Clear movement tracking
        self.movement_start_time = None
        self.current_direction = None
        self.is_moving = False
    
    def check_safety(self):
        """Check if extension time limit reached during movement"""
        if self.is_moving and self.current_direction == "extend" and self.movement_start_time:
            elapsed = time.time() - self.movement_start_time
            if self.total_extend_time + elapsed >= self.max_extend_time:
                print(f"\n⚠️  SAFETY STOP: Cumulative extension limit ({self.max_extend_time}s) reached!")
                self.stop()
                return True
        return False
    
    def cleanup(self):
        """Clean up - ensure actuator is stopped"""
        self.stop()


def main():
    # Create actuator controller
    actuator = LinearActuatorPCA9685(in1_channel=4, in2_channel=5)
    
    print("\n" + "="*50)
    print("Linear Actuator Keyboard Control (PCA9685)")
    print("="*50)
    print("\nControls:")
    print("  W     - Hold to EXTEND at FULL SPEED (release to stop)")
    print("  S     - Hold to RETRACT at FULL SPEED (release to stop)")
    print("  Q     - Quit program")
    print("  Space - Emergency STOP")
    print("\n⚠️  Total extension time is limited to 8 seconds")
    print("-"*50)
    
    # Initialize keyboard controller
    kb = KeyboardController()
    
    # Track key states
    key_states = {'w': False, 's': False}
    running = True
    
    # Safety monitor thread
    def safety_monitor():
        while running:
            actuator.check_safety()
            time.sleep(0.1)
    
    safety_thread = threading.Thread(target=safety_monitor, daemon=True)
    safety_thread.start()
    
    # Status display thread
    def status_display():
        while running:
            if actuator.is_moving:
                remaining = actuator.get_remaining_extend_time()
                if actuator.current_direction == "extend":
                    elapsed = time.time() - actuator.movement_start_time
                    print(f"\r[EXTENDING @ 100%] Time: {elapsed:.1f}s | Remaining: {remaining - elapsed:.1f}s | Total used: {actuator.total_extend_time + elapsed:.1f}s", end='', flush=True)
                elif actuator.current_direction == "retract":
                    elapsed = time.time() - actuator.movement_start_time
                    print(f"\r[RETRACTING @ 100%] Time: {elapsed:.1f}s | Extension budget remaining: {remaining:.1f}s", end='', flush=True)
            time.sleep(0.1)
    
    status_thread = threading.Thread(target=status_display, daemon=True)
    status_thread.start()
    
    try:
        print("\nReady! Use W/S keys to control actuator, Q to quit")
        
        while running:
            key = kb.get_key()
            
            if key == 'q':
                print("\nQuitting...")
                running = False
                break
                
            elif key == ' ':  # Space for emergency stop
                actuator.stop()
                key_states = {'w': False, 's': False}
                print("\n⚠️  EMERGENCY STOP!")
                
            elif key == 'w':
                if not key_states['w'] and not key_states['s']:  # Not already extending and not retracting
                    if actuator.extend(speed=100):  # FULL SPEED
                        key_states['w'] = True
                        
            elif key == 's':
                if not key_states['s'] and not key_states['w']:  # Not already retracting and not extending
                    if actuator.retract(speed=100):  # FULL SPEED
                        key_states['s'] = True
            
            # Check for key releases
            if key_states['w'] and key != 'w':
                # W was pressed but now released
                actuator.stop()
                key_states['w'] = False
                
            if key_states['s'] and key != 's':
                # S was pressed but now released
                actuator.stop()
                key_states['s'] = False
            
            time.sleep(0.01)  # Small delay to prevent CPU spinning
            
    except KeyboardInterrupt:
        print("\n\nProgram interrupted by user")
        
    finally:
        running = False
        actuator.cleanup()
        kb.restore()
        print(f"\nFinal stats: Total extension time used: {actuator.total_extend_time:.1f}s / {actuator.max_extend_time}s")
        print("Actuator stopped. Exiting...")


if __name__ == "__main__":
    if not HARDWARE:
        print("\n⚠️  WARNING: Running in simulation mode - no real hardware detected!")
        print("Install adafruit-circuitpython-pca9685 to use with real hardware.\n")
    
    main()
================================================================================


================================================================================
FILE: Test_folder/Trigger_system/demo.py
Category: Python | Size: 9.6 KB | Lines: 287
================================================================================
#!/usr/bin/env python3
"""
Linear Actuator Control using PCA9685
Controls a DC linear actuator through motor driver connected to PCA9685
Using channels 4 and 5 on the PCA9685
"""

import time
import sys

try:
    import board
    import busio
    import adafruit_pca9685
    HARDWARE = True
except ImportError:
    print("Warning: PCA9685 libraries not found. Running in simulation mode.")
    HARDWARE = False
    
    # Dummy classes for testing without hardware
    class _DummyChannel:
        def __init__(self):
            self.duty_cycle = 0
    
    class _DummyPCA:
        def __init__(self, i2c=None):  # Accept i2c parameter but ignore it
            self.channels = [_DummyChannel() for _ in range(16)]
            self.frequency = 100
    
    class _DummyI2C: pass
    
    class _DummyBusio:
        @staticmethod
        def I2C(*_):
            return _DummyI2C()
    
    class _DummyBoard:
        SCL = None
        SDA = None
    
    board = _DummyBoard()
    busio = _DummyBusio()
    adafruit_pca9685 = type("adafruit_pca9685", (), {"PCA9685": _DummyPCA})


class LinearActuatorPCA9685:
    def __init__(self, in1_channel=4, in2_channel=5, frequency=1000, max_extend_time=8):
        """
        Initialize linear actuator controller using PCA9685
        in1_channel: PCA9685 channel for IN1 (default: 4)
        in2_channel: PCA9685 channel for IN2 (default: 5)
        frequency: PWM frequency in Hz (default: 1000)
        max_extend_time: Maximum time allowed for extension in seconds (default: 8)
        """
        # Initialize I2C and PCA9685
        self.i2c = busio.I2C(board.SCL, board.SDA)
        self.pca = adafruit_pca9685.PCA9685(self.i2c)
        self.pca.frequency = frequency
        
        # Store channel numbers
        self.in1_channel = in1_channel
        self.in2_channel = in2_channel
        
        # Safety limit for extension only
        self.max_extend_time = max_extend_time
        
        # Track movement start time
        self.movement_start_time = None
        self.current_direction = None
        
        # Initialize channels to 0 (stopped)
        self.stop()
        
        print(f"PCA9685 initialized - IN1: Channel {in1_channel}, IN2: Channel {in2_channel}")
        print(f"PWM Frequency: {frequency}Hz")
        print(f"Safety limit - Max extend: {max_extend_time}s (no limit on retraction)")
    
    def _check_safety_timeout(self):
        """
        Check if extension movement has exceeded safety time limit
        Only applies to extension, not retraction
        """
        if self.movement_start_time and self.current_direction == "extend":
            elapsed = time.time() - self.movement_start_time
            
            if elapsed >= self.max_extend_time:
                print(f"\n⚠️  SAFETY STOP: Extension time limit ({self.max_extend_time}s) reached!")
                self.stop()
                return True
        return False
    
    def _set_duty_cycle(self, channel, value):
        """
        Set duty cycle for a channel (0-65535)
        """
        value = max(0, min(65535, value))  # Clamp to valid range
        self.pca.channels[channel].duty_cycle = value
    
    def extend(self, speed=100):
        """
        Extend the linear actuator
        speed: 0-100 (percentage of max speed)
        """
        # Check if already at safety limit
        if self._check_safety_timeout():
            return
        
        # Convert percentage to 16-bit duty cycle
        duty_cycle = int((speed / 100.0) * 65535)
        
        # IN1 = HIGH (PWM), IN2 = LOW
        self._set_duty_cycle(self.in1_channel, duty_cycle)
        self._set_duty_cycle(self.in2_channel, 0)
        
        # Track movement for safety
        self.movement_start_time = time.time()
        self.current_direction = "extend"
        
        print(f"Extending actuator at {speed}% speed (duty cycle: {duty_cycle})")
        if speed == 100:
            print(f"⚠️  Auto-stop will engage after {self.max_extend_time} seconds for safety")
    
    def retract(self, speed=100):
        """
        Retract the linear actuator (no time limit)
        speed: 0-100 (percentage of max speed)
        """
        # Convert percentage to 16-bit duty cycle
        duty_cycle = int((speed / 100.0) * 65535)
        
        # IN1 = LOW, IN2 = HIGH (PWM)
        self._set_duty_cycle(self.in1_channel, 0)
        self._set_duty_cycle(self.in2_channel, duty_cycle)
        
        # Track movement for consistency (but no safety limit)
        self.movement_start_time = time.time()
        self.current_direction = "retract"
        
        print(f"Retracting actuator at {speed}% speed (duty cycle: {duty_cycle})")
        print("No time limit on retraction - will run until stopped")
    
    def stop(self):
        """
        Stop the linear actuator
        """
        # Both channels to 0
        self._set_duty_cycle(self.in1_channel, 0)
        self._set_duty_cycle(self.in2_channel, 0)
        
        # Clear movement tracking
        self.movement_start_time = None
        self.current_direction = None
        
        print("Actuator stopped")
    
    def extend_for_duration(self, duration, speed=100):
        """
        Extend actuator for a specific duration (in seconds)
        """
        self.extend(speed)
        time.sleep(duration)
        self.stop()
    
    def retract_for_duration(self, duration, speed=100):
        """
        Retract actuator for a specific duration (in seconds)
        """
        self.retract(speed)
        time.sleep(duration)
        self.stop()
    
    def cleanup(self):
        """
        Clean up - ensure actuator is stopped
        """
        self.stop()
        # Note: PCA9685 doesn't require GPIO cleanup like RPi.GPIO


def main():
    # Create actuator controller using PCA9685 channels 4 and 5
    actuator = LinearActuatorPCA9685(in1_channel=4, in2_channel=5)
    
    print("\n" + "="*50)
    print("Linear Actuator Control (PCA9685)")
    print("="*50)
    print("\nCommands:")
    print("  e     - Extend at full speed")
    print("  r     - Retract at full speed")
    print("  s     - Stop")
    print("  1-9   - Extend/Retract for 1-9 seconds")
    print("  v     - Variable speed control (0-100%)")
    print("  t     - Test sequence")
    print("  quit  - Exit program")
    print("-"*50)
    
    # Start safety monitor thread
    import threading
    
    def safety_monitor():
        while True:
            actuator._check_safety_timeout()
            time.sleep(0.1)  # Check every 100ms
    
    safety_thread = threading.Thread(target=safety_monitor, daemon=True)
    safety_thread.start()
    
    try:
        while True:
            command = input("\nEnter command: ").lower().strip()
            
            if command == 'quit':
                break
                
            elif command == 'e':
                actuator.extend()
                
            elif command == 'r':
                actuator.retract()
                
            elif command == 's':
                actuator.stop()
                
            elif command in '123456789':
                duration = int(command)
                direction = input(f"Extend (e) or Retract (r) for {duration} seconds? ").lower()
                
                if direction == 'e':
                    if duration > actuator.max_extend_time:
                        print(f"⚠️  Warning: Extension duration {duration}s exceeds safety limit of {actuator.max_extend_time}s")
                        print(f"Duration will be capped at {actuator.max_extend_time}s")
                        duration = actuator.max_extend_time
                    actuator.extend_for_duration(duration)
                elif direction == 'r':
                    # No limit on retraction
                    actuator.retract_for_duration(duration)
                else:
                    print("Invalid direction. Use 'e' or 'r'")
                    
            elif command == 'v':
                try:
                    speed = int(input("Enter speed (0-100): "))
                    if 0 <= speed <= 100:
                        direction = input("Extend (e) or Retract (r)? ").lower()
                        if direction == 'e':
                            actuator.extend(speed)
                        elif direction == 'r':
                            actuator.retract(speed)
                        else:
                            print("Invalid direction. Use 'e' or 'r'")
                    else:
                        print("Speed must be between 0 and 100")
                except ValueError:
                    print("Invalid speed value")
                    
            elif command == 't':
                print("\nRunning test sequence...")
                print("1. Extending at 50% speed for 2 seconds")
                actuator.extend_for_duration(2, 50)
                time.sleep(1)
                
                print("2. Retracting at 100% speed for 2 seconds")
                actuator.retract_for_duration(2, 100)
                time.sleep(1)
                
                print("3. Extending at 25% speed for 1 second")
                actuator.extend_for_duration(1, 25)
                
                print("Test sequence complete!")
                
            else:
                print("Unknown command. Type 'quit' to exit.")
                
    except KeyboardInterrupt:
        print("\n\nProgram interrupted by user")
        
    finally:
        actuator.cleanup()
        print("Actuator stopped. Exiting...")


if __name__ == "__main__":
    if not HARDWARE:
        print("\n⚠️  WARNING: Running in simulation mode - no real hardware detected!")
        print("Install adafruit-circuitpython-pca9685 to use with real hardware.\n")
    
    main()
================================================================================


================================================================================
FILE: Test_folder/lidar/YDLidar_G2_test.py
Category: Python | Size: 4.6 KB | Lines: 147
================================================================================
#!/usr/bin/env python3
"""
YDLidar G2 Diagnostic Script
Shows raw data pattern to understand the data format
"""

import sys
import time
import serial
import serial.tools.list_ports

def find_lidar_port():
    """Find the YDLidar USB port"""
    print("Searching for YDLidar...")
    ports = serial.tools.list_ports.comports()
    
    for port in ports:
        if 'CP210' in port.description or 'ttyUSB' in port.device:
            print(f"Found: {port.device}")
            return port.device
            
    # Try common ports
    for port in ['/dev/ttyUSB0', '/dev/ttyUSB1']:
        try:
            s = serial.Serial(port, 230400, timeout=0.1)
            s.close()
            return port
        except:
            pass
    return None

def main():
    # Find and connect
    port = find_lidar_port()
    if not port:
        print("No lidar found!")
        return
        
    print(f"Connecting to {port}...")
    ser = serial.Serial(port, 230400, timeout=0.1)
    
    # Start scan
    print("Starting scan...")
    ser.write(b'\xA5\x60')
    time.sleep(0.5)
    
    print("\n=== RAW DATA ANALYSIS ===")
    print("Looking for data patterns...\n")
    
    # Collect some data
    data_buffer = b''
    for i in range(5):
        if ser.in_waiting > 0:
            new_data = ser.read(ser.in_waiting)
            data_buffer += new_data
        time.sleep(0.1)
    
    # Show first 200 bytes in hex
    print("First 200 bytes (hex):")
    hex_str = data_buffer[:200].hex()
    for i in range(0, len(hex_str), 32):
        print(hex_str[i:i+32])
    
    # Look for patterns
    print("\n=== PATTERN ANALYSIS ===")
    
    # Count occurrences of potential start bytes
    print("\nByte frequency (potential markers):")
    byte_counts = {}
    for b in data_buffer[:1000]:
        if b not in byte_counts:
            byte_counts[b] = 0
        byte_counts[b] += 1
    
    # Show most common bytes
    sorted_bytes = sorted(byte_counts.items(), key=lambda x: x[1], reverse=True)[:10]
    for byte_val, count in sorted_bytes:
        print(f"  0x{byte_val:02X}: {count} times")
    
    # Look for AA 55 pattern
    print("\n0xAA 0x55 pattern locations:")
    for i in range(len(data_buffer)-1):
        if data_buffer[i] == 0xAA and data_buffer[i+1] == 0x55:
            # Show context around pattern
            start = max(0, i-2)
            end = min(len(data_buffer), i+20)
            context = data_buffer[start:end].hex()
            print(f"  Position {i}: ...{context}...")
            if i < 500:  # Only show first few
                # Try to parse as potential packet
                if i+10 < len(data_buffer):
                    packet_type = data_buffer[i+2]
                    sample_num = data_buffer[i+3]
                    print(f"    Type: 0x{packet_type:02X}, Samples: {sample_num}")
    
    # Simple data display
    print("\n=== SIMPLE DATA PARSER ===")
    print("Attempting basic parsing...\n")
    
    # Clear buffer and collect fresh data
    ser.reset_input_buffer()
    time.sleep(0.1)
    
    scan_count = 0
    byte_count = 0
    start_time = time.time()
    
    try:
        while True:
            if ser.in_waiting > 0:
                data = ser.read(ser.in_waiting)
                byte_count += len(data)
                
                # Look for any distance-like values (2-byte integers)
                for i in range(0, len(data)-1, 2):
                    value = data[i] | (data[i+1] << 8)
                    # Reasonable distance range: 100-4000mm
                    if 100 < value < 4000:
                        scan_count += 1
                        if scan_count % 100 == 0:
                            print(f"Possible distance: {value} mm (sample #{scan_count})")
                
                # Status update
                if time.time() - start_time > 2:
                    print(f"\n[{time.time()-start_time:.1f}s] Bytes: {byte_count}, Possible distances found: {scan_count}")
                    if byte_count > 0:
                        print("Data IS flowing! Motor should be spinning.")
                    start_time = time.time()
                    
    except KeyboardInterrupt:
        print("\n\nStopping...")
        
    # Stop scan
    ser.write(b'\xA5\x65')
    ser.close()
    
    print("\n=== SUMMARY ===")
    print(f"Total bytes received: {byte_count}")
    print(f"Data rate: ~{byte_count/10:.0f} bytes/second")
    print("\nYour lidar IS working and sending data!")
    print("The data format just needs proper parsing.")
    print("\nNext steps:")
    print("1. The official YDLidar SDK would handle this parsing automatically")
    print("2. Or we can refine the parser once we understand the exact format")

if __name__ == "__main__":
    main()
================================================================================


================================================================================
FILE: Test_folder/system_monitor.py
Category: Python | Size: 13.1 KB | Lines: 350
================================================================================
#!/usr/bin/env python3
"""
Raspberry Pi System and ROS Monitor
Monitors system load, temperature, runtime, and ROS metrics
Can be run as a standalone script or as a ROS node
"""

import psutil
import os
import time
import json
import subprocess
from datetime import datetime, timedelta
from collections import defaultdict

# ROS imports (optional - will work without ROS)
try:
    import rospy
    from std_msgs.msg import String, Float32
    import rostopic
    import rosnode
    ROS_AVAILABLE = True
except ImportError:
    ROS_AVAILABLE = False
    print("ROS not available - running in standalone mode")


class SystemMonitor:
    """Monitor system metrics on Raspberry Pi"""
    
    def __init__(self):
        self.start_time = time.time()
        self.cpu_temps = []
        self.ros_topic_stats = defaultdict(dict)
        
    def get_cpu_temperature(self):
        """Get CPU temperature on Raspberry Pi"""
        temp = None
        
        # Method 1: Try thermal zone (works on most Linux systems)
        try:
            with open('/sys/class/thermal/thermal_zone0/temp', 'r') as f:
                temp = float(f.read()) / 1000.0
                return temp
        except:
            pass
        
        # Method 2: Try vcgencmd (Raspberry Pi specific)
        try:
            result = subprocess.check_output(['vcgencmd', 'measure_temp']).decode()
            temp = float(result.replace('temp=', '').replace("'C\n", ''))
            return temp
        except:
            pass
        
        # Method 3: Try sensors command
        try:
            result = subprocess.check_output(['sensors']).decode()
            for line in result.split('\n'):
                if 'Core 0' in line or 'temp1' in line:
                    temp_str = line.split('+')[1].split('°')[0]
                    temp = float(temp_str)
                    return temp
        except:
            pass
        
        return -1  # Temperature not available
    
    def get_system_load(self):
        """Get comprehensive system load information"""
        return {
            'cpu_percent': psutil.cpu_percent(interval=1),
            'cpu_percent_per_core': psutil.cpu_percent(interval=1, percpu=True),
            'cpu_count': psutil.cpu_count(),
            'cpu_freq': psutil.cpu_freq()._asdict() if psutil.cpu_freq() else None,
            'load_average': {
                '1min': psutil.getloadavg()[0],
                '5min': psutil.getloadavg()[1],
                '15min': psutil.getloadavg()[2]
            },
            'memory': {
                'percent': psutil.virtual_memory().percent,
                'used_gb': psutil.virtual_memory().used / (1024**3),
                'total_gb': psutil.virtual_memory().total / (1024**3),
                'available_gb': psutil.virtual_memory().available / (1024**3)
            },
            'swap': {
                'percent': psutil.swap_memory().percent,
                'used_gb': psutil.swap_memory().used / (1024**3),
                'total_gb': psutil.swap_memory().total / (1024**3)
            },
            'disk': {
                'percent': psutil.disk_usage('/').percent,
                'used_gb': psutil.disk_usage('/').used / (1024**3),
                'total_gb': psutil.disk_usage('/').total / (1024**3),
                'free_gb': psutil.disk_usage('/').free / (1024**3)
            }
        }
    
    def get_runtime_info(self):
        """Get system runtime and process information"""
        current_time = time.time()
        uptime_seconds = current_time - psutil.boot_time()
        script_runtime = current_time - self.start_time
        
        return {
            'system_uptime': str(timedelta(seconds=int(uptime_seconds))),
            'system_uptime_seconds': uptime_seconds,
            'script_runtime': str(timedelta(seconds=int(script_runtime))),
            'script_runtime_seconds': script_runtime,
            'boot_time': datetime.fromtimestamp(psutil.boot_time()).strftime('%Y-%m-%d %H:%M:%S'),
            'current_time': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'process_count': len(psutil.pids()),
            'network_connections': len(psutil.net_connections())
        }
    
    def get_network_stats(self):
        """Get network statistics"""
        net_io = psutil.net_io_counters()
        return {
            'bytes_sent_mb': net_io.bytes_sent / (1024**2),
            'bytes_recv_mb': net_io.bytes_recv / (1024**2),
            'packets_sent': net_io.packets_sent,
            'packets_recv': net_io.packets_recv,
            'errors_in': net_io.errin,
            'errors_out': net_io.errout
        }
    
    def get_process_info(self, top_n=5):
        """Get top N processes by CPU and memory usage"""
        processes = []
        for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
            try:
                processes.append(proc.info)
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                pass
        
        # Sort by CPU usage
        top_cpu = sorted(processes, key=lambda x: x['cpu_percent'], reverse=True)[:top_n]
        
        # Sort by memory usage
        top_memory = sorted(processes, key=lambda x: x['memory_percent'], reverse=True)[:top_n]
        
        return {
            'top_cpu_processes': top_cpu,
            'top_memory_processes': top_memory
        }
    
    def get_ros_load(self):
        """Get ROS-specific load information"""
        if not ROS_AVAILABLE:
            return {'error': 'ROS not available'}
        
        ros_info = {
            'ros_available': False,
            'nodes': [],
            'topics': [],
            'services': [],
            'topic_stats': {},
            'node_stats': {}
        }
        
        try:
            # Check if roscore is running
            master = rospy.get_master()
            master.getPid()
            ros_info['ros_available'] = True
            
            # Get list of nodes
            ros_info['nodes'] = rosnode.get_node_names()
            
            # Get list of topics with their types
            topics_and_types = rospy.get_published_topics()
            ros_info['topics'] = [{'name': t[0], 'type': t[1]} for t in topics_and_types]
            
            # Get services
            ros_info['services'] = sorted(rospy.get_services())
            
            # Get topic statistics (bandwidth, frequency)
            for topic, msg_type in topics_and_types[:10]:  # Limit to first 10 topics
                try:
                    # Get topic bandwidth
                    topic_info = subprocess.check_output(
                        ['rostopic', 'bw', topic], 
                        timeout=2
                    ).decode().strip()
                    
                    if 'average:' in topic_info:
                        bandwidth = topic_info.split('average:')[1].strip()
                        ros_info['topic_stats'][topic] = {'bandwidth': bandwidth}
                except:
                    pass
            
            # Get node CPU and memory usage
            for node in ros_info['nodes'][:10]:  # Limit to first 10 nodes
                try:
                    # Find process ID for the node
                    node_info = rosnode.get_node_info_description(node)
                    
                    # Try to find the process
                    for proc in psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']):
                        if node in proc.info['name'] or proc.info['name'] in node:
                            ros_info['node_stats'][node] = {
                                'pid': proc.info['pid'],
                                'cpu_percent': proc.info['cpu_percent'],
                                'memory_percent': proc.info['memory_percent']
                            }
                            break
                except:
                    pass
            
        except Exception as e:
            ros_info['error'] = str(e)
        
        return ros_info
    
    def get_all_metrics(self):
        """Get all system and ROS metrics"""
        metrics = {
            'timestamp': datetime.now().isoformat(),
            'temperature': self.get_cpu_temperature(),
            'system_load': self.get_system_load(),
            'runtime': self.get_runtime_info(),
            'network': self.get_network_stats(),
            'processes': self.get_process_info(),
            'ros_load': self.get_ros_load() if ROS_AVAILABLE else None
        }
        return metrics
    
    def print_summary(self, metrics):
        """Print a formatted summary of the metrics"""
        print("\n" + "="*60)
        print(f"System Monitor Report - {metrics['timestamp']}")
        print("="*60)
        
        # Temperature
        print(f"\n🌡️  CPU Temperature: {metrics['temperature']:.1f}°C")
        
        # System Load
        load = metrics['system_load']
        print(f"\n💻 System Load:")
        print(f"   CPU Usage: {load['cpu_percent']:.1f}%")
        print(f"   Load Average: {load['load_average']['1min']:.2f} (1m), "
              f"{load['load_average']['5min']:.2f} (5m), "
              f"{load['load_average']['15min']:.2f} (15m)")
        print(f"   Memory: {load['memory']['percent']:.1f}% "
              f"({load['memory']['used_gb']:.1f}/{load['memory']['total_gb']:.1f} GB)")
        print(f"   Disk: {load['disk']['percent']:.1f}% "
              f"({load['disk']['used_gb']:.1f}/{load['disk']['total_gb']:.1f} GB)")
        
        # Runtime
        runtime = metrics['runtime']
        print(f"\n⏱️  Runtime Info:")
        print(f"   System Uptime: {runtime['system_uptime']}")
        print(f"   Script Runtime: {runtime['script_runtime']}")
        print(f"   Process Count: {runtime['process_count']}")
        
        # Top Processes
        processes = metrics['processes']
        print(f"\n📊 Top CPU Processes:")
        for proc in processes['top_cpu_processes'][:3]:
            print(f"   {proc['name']}: {proc['cpu_percent']:.1f}%")
        
        # ROS Info
        if metrics['ros_load'] and metrics['ros_load'].get('ros_available'):
            ros = metrics['ros_load']
            print(f"\n🤖 ROS Status:")
            print(f"   Active Nodes: {len(ros['nodes'])}")
            print(f"   Active Topics: {len(ros['topics'])}")
            print(f"   Services: {len(ros['services'])}")
            
            if ros['node_stats']:
                print(f"\n   Node CPU Usage:")
                for node, stats in list(ros['node_stats'].items())[:3]:
                    print(f"     {node}: {stats['cpu_percent']:.1f}% CPU, "
                          f"{stats['memory_percent']:.1f}% Memory")


class ROSSystemPublisher:
    """Publish system metrics as ROS topics"""
    
    def __init__(self, monitor):
        self.monitor = monitor
        
        # Initialize ROS node
        rospy.init_node('system_monitor', anonymous=True)
        
        # Publishers
        self.temp_pub = rospy.Publisher('/system/temperature', Float32, queue_size=1)
        self.cpu_pub = rospy.Publisher('/system/cpu_usage', Float32, queue_size=1)
        self.memory_pub = rospy.Publisher('/system/memory_usage', Float32, queue_size=1)
        self.full_status_pub = rospy.Publisher('/system/full_status', String, queue_size=1)
        
        # Timer for periodic publishing
        self.timer = rospy.Timer(rospy.Duration(2.0), self.publish_metrics)
        
    def publish_metrics(self, event):
        """Publish metrics to ROS topics"""
        metrics = self.monitor.get_all_metrics()
        
        # Publish individual metrics
        self.temp_pub.publish(Float32(metrics['temperature']))
        self.cpu_pub.publish(Float32(metrics['system_load']['cpu_percent']))
        self.memory_pub.publish(Float32(metrics['system_load']['memory']['percent']))
        
        # Publish full status as JSON
        self.full_status_pub.publish(String(json.dumps(metrics, indent=2)))


def main():
    """Main function to run the monitor"""
    monitor = SystemMonitor()
    
    # Check if we should run as ROS node
    use_ros = '--ros' in os.sys.argv and ROS_AVAILABLE
    
    if use_ros:
        print("Starting ROS System Monitor Node...")
        publisher = ROSSystemPublisher(monitor)
        
        # Keep publishing until shutdown
        rospy.spin()
    else:
        print("Starting System Monitor (Standalone Mode)...")
        print("Add --ros flag to publish metrics to ROS topics")
        
        try:
            while True:
                # Get all metrics
                metrics = monitor.get_all_metrics()
                
                # Print summary
                monitor.print_summary(metrics)
                
                # Optional: Save to file
                if '--save' in os.sys.argv:
                    filename = f"system_metrics_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
                    with open(filename, 'w') as f:
                        json.dump(metrics, f, indent=2)
                    print(f"\nMetrics saved to {filename}")
                
                # Wait before next update
                time.sleep(5)
                
        except KeyboardInterrupt:
            print("\nMonitoring stopped.")


if __name__ == '__main__':
    main()
================================================================================


================================================================================
FILE: create_servo_package.py
Category: Python | Size: 16.5 KB | Lines: 508
================================================================================
#!/usr/bin/env python3
"""
Complete script to create the ROS2 servo controller package
"""

import os
import sys

def create_directory_structure():
    """Create all necessary directories"""
    directories = [
        "servo_controller_py/servo_controller_py",
        "servo_controller_py/launch",
        "servo_controller_py/config",
        "servo_controller_py/test",
        "servo_controller_py/resource",
        "servo_interfaces/msg",
        "servo_interfaces/srv"
    ]
    
    for directory in directories:
        os.makedirs(directory, exist_ok=True)
        print(f"Created directory: {directory}")
    
    # Create empty files
    open("servo_controller_py/servo_controller_py/__init__.py", 'a').close()
    open("servo_controller_py/resource/servo_controller_py", 'a').close()

def create_servo_controller_node():
    """Create the main servo controller node"""
    content = '''#!/usr/bin/env python3
"""
ROS2 node for controlling pan-tilt servos on Raspberry Pi
"""

import rclpy
from rclpy.node import Node
from servo_interfaces.msg import ServoPosition, ServoState
from servo_interfaces.srv import SetServoPosition, SetServoSpeed
import RPi.GPIO as GPIO
import time
import threading


class ServoControllerNode(Node):
    def __init__(self):
        super().__init__('servo_controller_node')
        
        # Declare parameters
        self.declare_parameter('pan_pin', 13)
        self.declare_parameter('tilt_pin', 12)
        self.declare_parameter('pwm_frequency', 50)
        self.declare_parameter('min_angle', 0)
        self.declare_parameter('max_angle', 270)
        self.declare_parameter('default_speed', 50)  # degrees per second
        
        # Get parameters
        self.pan_pin = self.get_parameter('pan_pin').value
        self.tilt_pin = self.get_parameter('tilt_pin').value
        self.pwm_frequency = self.get_parameter('pwm_frequency').value
        self.min_angle = self.get_parameter('min_angle').value
        self.max_angle = self.get_parameter('max_angle').value
        self.default_speed = self.get_parameter('default_speed').value
        
        # Current servo states
        self.current_pan = 135.0  # Center position
        self.current_tilt = 135.0  # Center position
        self.pan_speed = self.default_speed
        self.tilt_speed = self.default_speed
        
        # Movement flags
        self.pan_moving = False
        self.tilt_moving = False
        
        # Initialize GPIO
        self.init_gpio()
        
        # Create publishers
        self.state_publisher = self.create_publisher(ServoState, 'servo_state', 10)
        
        # Create subscribers
        self.position_subscriber = self.create_subscription(
            ServoPosition,
            'servo_position_cmd',
            self.position_callback,
            10
        )
        
        # Create services
        self.set_position_service = self.create_service(
            SetServoPosition,
            'set_servo_position',
            self.set_position_callback
        )
        
        self.set_speed_service = self.create_service(
            SetServoSpeed,
            'set_servo_speed',
            self.set_speed_callback
        )
        
        # Create timer for publishing state
        self.state_timer = self.create_timer(0.1, self.publish_state)
        
        # Move to initial position
        self.move_servo_immediate(self.pan_pwm, self.current_pan)
        self.move_servo_immediate(self.tilt_pwm, self.current_tilt)
        
        self.get_logger().info(f'Servo controller initialized - Pan: GPIO{self.pan_pin}, Tilt: GPIO{self.tilt_pin}')
    
    def init_gpio(self):
        """Initialize GPIO and PWM"""
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(self.pan_pin, GPIO.OUT)
        GPIO.setup(self.tilt_pin, GPIO.OUT)
        
        self.pan_pwm = GPIO.PWM(self.pan_pin, self.pwm_frequency)
        self.tilt_pwm = GPIO.PWM(self.tilt_pin, self.pwm_frequency)
        
        self.pan_pwm.start(0)
        self.tilt_pwm.start(0)
        
        time.sleep(0.5)
    
    def angle_to_duty_cycle(self, angle):
        """Convert angle to duty cycle percentage"""
        # Map angle (0-270) to duty cycle (2.5-12.5)
        duty_cycle = 2.5 + (angle / 270.0) * 10.0
        return duty_cycle
    
    def move_servo_immediate(self, servo_pwm, angle):
        """Move servo immediately to specified angle"""
        if self.min_angle <= angle <= self.max_angle:
            duty_cycle = self.angle_to_duty_cycle(angle)
            servo_pwm.ChangeDutyCycle(duty_cycle)
            time.sleep(0.02)  # Small delay for signal
            servo_pwm.ChangeDutyCycle(0)  # Stop signal to reduce jitter
            return True
        return False
    
    def move_servo_smooth(self, servo_pwm, start_angle, target_angle, speed, is_pan=True):
        """Move servo smoothly from start to target angle at specified speed"""
        if is_pan:
            self.pan_moving = True
        else:
            self.tilt_moving = True
        
        current = start_angle
        step = 1.0 if target_angle > start_angle else -1.0
        delay = 1.0 / speed  # Time between steps
        
        while abs(current - target_angle) > 0.5:
            current += step
            if step > 0:
                current = min(current, target_angle)
            else:
                current = max(current, target_angle)
            
            self.move_servo_immediate(servo_pwm, current)
            
            if is_pan:
                self.current_pan = current
            else:
                self.current_tilt = current
            
            time.sleep(delay)
        
        # Final position
        self.move_servo_immediate(servo_pwm, target_angle)
        
        if is_pan:
            self.current_pan = target_angle
            self.pan_moving = False
        else:
            self.current_tilt = target_angle
            self.tilt_moving = False
    
    def position_callback(self, msg):
        """Handle position command messages"""
        # Start pan movement in thread
        if msg.pan_angle != self.current_pan and not self.pan_moving:
            pan_thread = threading.Thread(
                target=self.move_servo_smooth,
                args=(self.pan_pwm, self.current_pan, msg.pan_angle, self.pan_speed, True)
            )
            pan_thread.daemon = True
            pan_thread.start()
        
        # Start tilt movement in thread
        if msg.tilt_angle != self.current_tilt and not self.tilt_moving:
            tilt_thread = threading.Thread(
                target=self.move_servo_smooth,
                args=(self.tilt_pwm, self.current_tilt, msg.tilt_angle, self.tilt_speed, False)
            )
            tilt_thread.daemon = True
            tilt_thread.start()
    
    def set_position_callback(self, request, response):
        """Handle set position service requests"""
        success = True
        
        # Validate angles
        if not (self.min_angle <= request.pan_angle <= self.max_angle):
            response.success = False
            response.message = f"Pan angle must be between {self.min_angle} and {self.max_angle}"
            return response
        
        if not (self.min_angle <= request.tilt_angle <= self.max_angle):
            response.success = False
            response.message = f"Tilt angle must be between {self.min_angle} and {self.max_angle}"
            return response
        
        # Create and publish position message
        pos_msg = ServoPosition()
        pos_msg.pan_angle = request.pan_angle
        pos_msg.tilt_angle = request.tilt_angle
        self.position_callback(pos_msg)
        
        response.success = True
        response.message = f"Moving to Pan: {request.pan_angle}°, Tilt: {request.tilt_angle}°"
        return response
    
    def set_speed_callback(self, request, response):
        """Handle set speed service requests"""
        if request.pan_speed > 0:
            self.pan_speed = request.pan_speed
        if request.tilt_speed > 0:
            self.tilt_speed = request.tilt_speed
        
        response.success = True
        response.message = f"Speed set - Pan: {self.pan_speed}°/s, Tilt: {self.tilt_speed}°/s"
        return response
    
    def publish_state(self):
        """Publish current servo state"""
        state_msg = ServoState()
        state_msg.header.stamp = self.get_clock().now().to_msg()
        state_msg.pan_angle = self.current_pan
        state_msg.tilt_angle = self.current_tilt
        state_msg.pan_moving = self.pan_moving
        state_msg.tilt_moving = self.tilt_moving
        self.state_publisher.publish(state_msg)
    
    def cleanup(self):
        """Clean up GPIO resources"""
        self.pan_pwm.stop()
        self.tilt_pwm.stop()
        GPIO.cleanup()


def main(args=None):
    rclpy.init(args=args)
    
    try:
        servo_controller = ServoControllerNode()
        rclpy.spin(servo_controller)
    except KeyboardInterrupt:
        pass
    finally:
        servo_controller.cleanup()
        servo_controller.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
'''
    
    with open("servo_controller_py/servo_controller_py/servo_controller_node.py", "w") as f:
        f.write(content)
    print("Created servo_controller_node.py")

def create_launch_file():
    """Create the launch file"""
    content = '''from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration
import os
from ament_index_python.packages import get_package_share_directory


def generate_launch_description():
    # Get the package directory
    pkg_dir = get_package_share_directory('servo_controller_py')
    
    # Path to config file
    config_file = os.path.join(pkg_dir, 'config', 'servo_config.yaml')
    
    return LaunchDescription([
        # Declare launch arguments
        DeclareLaunchArgument(
            'config_file',
            default_value=config_file,
            description='Path to servo configuration file'
        ),
        
        # Servo controller node
        Node(
            package='servo_controller_py',
            executable='servo_controller_node',
            name='servo_controller',
            output='screen',
            parameters=[LaunchConfiguration('config_file')],
            respawn=True,
            respawn_delay=2.0
        )
    ])
'''
    
    with open("servo_controller_py/launch/servo_controller_launch.py", "w") as f:
        f.write(content)
    print("Created servo_controller_launch.py")

def create_package_files():
    """Create all package configuration files"""
    files = {
        "servo_controller_py/package.xml": '''<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>servo_controller_py</name>
  <version>0.0.1</version>
  <description>ROS2 package for controlling pan-tilt servos on Raspberry Pi</description>
  <maintainer email="your_email@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_python</buildtool_depend>

  <exec_depend>rclpy</exec_depend>
  <exec_depend>std_msgs</exec_depend>
  <exec_depend>servo_interfaces</exec_depend>

  <test_depend>ament_copyright</test_depend>
  <test_depend>ament_flake8</test_depend>
  <test_depend>ament_pep257</test_depend>
  <test_depend>python3-pytest</test_depend>

  <export>
    <build_type>ament_python</build_type>
  </export>
</package>
''',

        "servo_controller_py/setup.py": '''from setuptools import setup
import os
from glob import glob

package_name = 'servo_controller_py'

setup(
    name=package_name,
    version='0.0.1',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),
        (os.path.join('share', package_name, 'config'), glob('config/*.yaml')),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Your Name',
    maintainer_email='your_email@example.com',
    description='ROS2 package for controlling pan-tilt servos on Raspberry Pi',
    license='Apache-2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'servo_controller_node = servo_controller_py.servo_controller_node:main',
        ],
    },
)
''',

        "servo_controller_py/setup.cfg": '''[develop]
script_dir=$base/lib/servo_controller_py
[install]
install_scripts=$base/lib/servo_controller_py
''',

        "servo_controller_py/config/servo_config.yaml": '''servo_controller:
  ros__parameters:
    # GPIO pin numbers (BCM numbering)
    pan_pin: 13    # GPIO 13 for pan servo
    tilt_pin: 12   # GPIO 12 for tilt servo
    
    # PWM settings
    pwm_frequency: 50  # Hz
    
    # Angle limits
    min_angle: 0     # degrees
    max_angle: 270   # degrees
    
    # Movement speed
    default_speed: 50  # degrees per second
''',

        "servo_interfaces/package.xml": '''<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
<package format="3">
  <name>servo_interfaces</name>
  <version>0.0.1</version>
  <description>Custom messages and services for servo control</description>
  <maintainer email="your_email@example.com">Your Name</maintainer>
  <license>Apache-2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <buildtool_depend>rosidl_default_generators</buildtool_depend>

  <depend>std_msgs</depend>

  <exec_depend>rosidl_default_runtime</exec_depend>

  <member_of_group>rosidl_interface_packages</member_of_group>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
''',

        "servo_interfaces/CMakeLists.txt": '''cmake_minimum_required(VERSION 3.8)
project(servo_interfaces)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()

find_package(ament_cmake REQUIRED)
find_package(std_msgs REQUIRED)
find_package(rosidl_default_generators REQUIRED)

rosidl_generate_interfaces(${PROJECT_NAME}
  "msg/ServoPosition.msg"
  "msg/ServoState.msg"
  "srv/SetServoPosition.srv"
  "srv/SetServoSpeed.srv"
  DEPENDENCIES std_msgs
)

ament_export_dependencies(rosidl_default_runtime)
ament_package()
''',

        "servo_interfaces/msg/ServoPosition.msg": '''# Message for commanding servo positions
float32 pan_angle   # Pan angle in degrees (0-270)
float32 tilt_angle  # Tilt angle in degrees (0-270)
''',

        "servo_interfaces/msg/ServoState.msg": '''# Message for current servo state
std_msgs/Header header
float32 pan_angle    # Current pan angle in degrees
float32 tilt_angle   # Current tilt angle in degrees
bool pan_moving      # True if pan servo is currently moving
bool tilt_moving     # True if tilt servo is currently moving
''',

        "servo_interfaces/srv/SetServoPosition.srv": '''# Service for setting servo positions
float32 pan_angle   # Target pan angle in degrees (0-270)
float32 tilt_angle  # Target tilt angle in degrees (0-270)
---
bool success        # True if command was accepted
string message      # Response message
''',

        "servo_interfaces/srv/SetServoSpeed.srv": '''# Service for setting servo movement speeds
float32 pan_speed   # Pan speed in degrees per second (0 = keep current)
float32 tilt_speed  # Tilt speed in degrees per second (0 = keep current)
---
bool success        # True if command was accepted
string message      # Response message
'''
    }
    
    for filepath, content in files.items():
        with open(filepath, "w") as f:
            f.write(content)
        print(f"Created {filepath}")

def main():
    print("Creating ROS2 Servo Controller Package...")
    print("=" * 50)
    
    # Create directory structure
    create_directory_structure()
    
    # Create all files
    create_package_files()
    create_servo_controller_node()
    create_launch_file()
    
    print("\n" + "=" * 50)
    print("✅ Package creation complete!")
    print("\nNext steps:")
    print("1. Update email and name in package.xml and setup.py files")
    print("2. Commit to git:")
    print("   git add servo_controller_py/ servo_interfaces/")
    print("   git commit -m 'Add servo controller ROS2 packages'")
    print("   git push")
    print("\n3. On Raspberry Pi:")
    print("   cd ~/ros2_ws")
    print("   colcon build --packages-select servo_interfaces servo_controller_py")
    print("   source install/setup.bash")
    print("   ros2 launch servo_controller_py servo_controller_launch.py")

if __name__ == "__main__":
    main()

================================================================================


================================================================================
FILE: dump_local_repo.py
Category: Python | Size: 2.9 KB | Lines: 91
================================================================================
#!/usr/bin/env python3
import os
import sys
from pathlib import Path

def print_file_content(file_path, base_path):
    """Print the content of a file with proper formatting."""
    relative_path = os.path.relpath(file_path, base_path)
    print(f"\n{'='*80}")
    print(f"FILE: {relative_path}")
    print(f"{'='*80}")
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
            print(content)
    except Exception as e:
        print(f"ERROR reading file: {e}")
    
    print(f"{'='*80}\n")

def scan_directory(directory):
    """Recursively scan directory and print all file contents."""
    base_path = Path(directory).resolve()
    
    # Define file extensions to include
    extensions_to_include = [
        '.py', '.yaml', '.yml', '.xml', '.txt', '.cmake', 
        '.msg', '.srv', '.action', '.launch', '.sh', '.bash'
    ]
    
    # Define directories to skip
    dirs_to_skip = ['__pycache__', '.git', 'build', 'install', 'log', '.vscode', '.idea']
    
    print(f"Scanning directory: {base_path}")
    print(f"{'='*80}")
    
    # First, print the directory structure
    print("\nDIRECTORY STRUCTURE:")
    print("-" * 40)
    
    for root, dirs, files in os.walk(base_path):
        # Skip certain directories
        dirs[:] = [d for d in dirs if d not in dirs_to_skip]
        
        level = root.replace(str(base_path), '').count(os.sep)
        indent = ' ' * 2 * level
        print(f"{indent}{os.path.basename(root)}/")
        
        subindent = ' ' * 2 * (level + 1)
        for file in sorted(files):
            print(f"{subindent}{file}")
    
    print("\n" + "="*80)
    print("FILE CONTENTS:")
    print("="*80)
    
    # Now print file contents
    for root, dirs, files in os.walk(base_path):
        # Skip certain directories
        dirs[:] = [d for d in dirs if d not in dirs_to_skip]
        
        for file in sorted(files):
            file_path = os.path.join(root, file)
            
            # Check if file has an extension we want to include
            if any(file.endswith(ext) for ext in extensions_to_include) or file in ['CMakeLists.txt', 'package.xml', 'setup.py', 'setup.cfg']:
                print_file_content(file_path, base_path)

def main():
    # Look for mlx90640_driver in current directory or subdirectories
    current_dir = os.getcwd()
    
    # Search for mlx90640_driver directory
    mlx_dir = None
    for root, dirs, files in os.walk(current_dir):
        if 'mlx90640_driver' in dirs:
            mlx_dir = os.path.join(root, 'mlx90640_driver')
            break
    
    if not mlx_dir:
        print("Error: Could not find mlx90640_driver directory")
        print(f"Current directory: {current_dir}")
        print("\nPlease run this script from your Fire-fighting-Robot repository root")
        sys.exit(1)
    
    print(f"Found mlx90640_driver at: {mlx_dir}")
    scan_directory(mlx_dir)

if __name__ == "__main__":
    main()
================================================================================


================================================================================
FILE: fire_fighting_robot_bringup/launch/robot_bringup.launch.py
Category: Python | Size: 2.9 KB | Lines: 79
================================================================================
#!/usr/bin/env python3
import subprocess
import time
from launch import LaunchDescription
from launch.actions import ExecuteProcess, TimerAction
from launch_ros.actions import Node

def generate_launch_description():
    # Kill any existing ROS processes first to ensure clean start
    print("Cleaning up any existing ROS processes...")
    subprocess.run(['pkill', '-9', '-f', 'rosbridge_websocket'], capture_output=True)
    subprocess.run(['pkill', '-9', '-f', 'rosapi_node'], capture_output=True)
    subprocess.run(['pkill', '-9', '-f', 'motor_driver_node'], capture_output=True)
    subprocess.run(['pkill', '-9', '-f', 'ydlidar'], capture_output=True)
    subprocess.run(['pkill', '-9', '-f', 'thermal_camera_node'], capture_output=True)
    subprocess.run(['pkill', '-9', '-f', 'servo_controller_node'], capture_output=True)
    time.sleep(1)  # Give processes time to fully terminate
    print("Cleanup complete. Starting fresh...")
    
    # Define the servo controller node
    servo_controller = Node(
        package='servo_controller_py',
        executable='servo_controller_node',
        name='servo_controller',
        parameters=['/home/ubuntu-robot-pi4/ros2_ws/src/Fire-Fighting-Robot/servo_controller_py/config/servo_config.yaml'],
        output='screen',
        respawn=True,
        respawn_delay=2.0
    )
    
    return LaunchDescription([
        # ROSbridge WebSocket - start nodes directly
        Node(
            package='rosbridge_server',
            executable='rosbridge_websocket',
            name='rosbridge_websocket',
            output='screen',
            parameters=[{
                'port': 9090,
                'address': '0.0.0.0'
            }]
        ),
        
        # ROSapi node (needed by rosbridge)
        Node(
            package='rosapi',
            executable='rosapi_node',
            name='rosapi_node',
            output='screen'
        ),
        
        # Motor Driver Node
        Node(
            package='pca9685_motor_driver_py',
            executable='motor_driver_node',
            name='motor_driver',
            parameters=['/home/ubuntu-robot-pi4/ros2_ws/src/Fire-Fighting-Robot/pca9685_motor_driver_py/config/motor_map.yaml'],
            output='screen'
        ),
        
        # YDLIDAR
        ExecuteProcess(
            cmd=['ros2', 'launch', 'ydlidar_ros2_driver', 'ydlidar_launch.py',
                 'params_file:=/home/ubuntu-robot-pi4/ros2_ws/src/ydlidar_ros2_driver/params/G2.yaml'],
            output='screen'
        ),
        
        # Thermal Camera - using direct path
        ExecuteProcess(
            cmd=['/home/ubuntu-robot-pi4/ros2_ws/install/mlx90640_driver/bin/thermal_camera_node'],
            output='screen'
        ),
        
        # Servo Controller Node - Start with 3 second delay to avoid conflicts
        TimerAction(
            period=3.0,
            actions=[servo_controller]
        )
    ])
================================================================================


================================================================================
FILE: mlx90640_driver/launch/thermal_camera_launch.py
Category: Python | Size: 1.2 KB | Lines: 37
================================================================================
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration
import os
from ament_index_python.packages import get_package_share_directory

def generate_launch_description():
    # Get the package directory
    pkg_dir = get_package_share_directory('mlx90640_driver')
    
    # Path to config file
    config_file = os.path.join(pkg_dir, 'config', 'thermal_camera.yaml')
    
    return LaunchDescription([
        DeclareLaunchArgument(
            'config_file',
            default_value=config_file,
            description='Path to config file'
        ),
        
        DeclareLaunchArgument(
            'output',
            default_value='screen',
            description='Output type for node'
        ),
        
        Node(
            package='mlx90640_driver',
            executable='thermal_camera_node',
            name='thermal_camera_node',
            output=LaunchConfiguration('output'),
            parameters=[LaunchConfiguration('config_file')],
            respawn=True,  # Restart if it crashes
            respawn_delay=2.0,  # Wait 2 seconds before restarting
        )
    ])
================================================================================


================================================================================
FILE: mlx90640_driver/mlx90640_driver/__init__.py
Category: Python | Size: 0.0 B | Lines: 0
================================================================================

================================================================================


================================================================================
FILE: mlx90640_driver/mlx90640_driver/thermal_camera_node.py
Category: Python | Size: 6.3 KB | Lines: 182
================================================================================
#!/usr/bin/env python3
"""
ROS 2 node for MLX90640 thermal camera
Publishes thermal frames as both topic and service
"""

import time
import warnings
import numpy as np
import board
import busio
import adafruit_mlx90640

import rclpy
from rclpy.node import Node
from std_msgs.msg import Header
from mlx90640_interfaces.msg import ThermalFrame
from mlx90640_interfaces.srv import GetThermalFrame

# Suppress I2C frequency warning
warnings.filterwarnings(
    "ignore", category=RuntimeWarning,
    message="I2C frequency is not settable in python, ignoring!"
)

class ThermalCameraNode(Node):
    def __init__(self):
        super().__init__('thermal_camera_node')
        
        # Declare parameters
        self.declare_parameter('publish_rate', 0.5)  # Hz
        self.declare_parameter('frame_id', 'thermal_camera')
        self.declare_parameter('enable_publisher', True)
        
        # Get parameters
        self.publish_rate = self.get_parameter('publish_rate').value
        self.frame_id = self.get_parameter('frame_id').value
        self.enable_publisher = self.get_parameter('enable_publisher').value
        
        # Initialize thermal camera with SAFE refresh rate
        try:
            i2c = busio.I2C(board.SCL, board.SDA)
            self.mlx = adafruit_mlx90640.MLX90640(i2c)
            # Use 1Hz - this is the most stable
            self.mlx.refresh_rate = adafruit_mlx90640.RefreshRate.REFRESH_1_HZ
            self.flat = np.zeros(24 * 32, dtype=np.float32)
            self.get_logger().info('MLX90640 thermal camera initialized at 1Hz (safe rate)')
        except Exception as e:
            self.get_logger().error(f'Failed to initialize thermal camera: {e}')
            raise
        
        # Frame counter
        self.frame_count = 0
        
        # Error handling
        self.consecutive_errors = 0
        self.max_consecutive_errors = 5
        
        # Create publisher
        if self.enable_publisher:
            self.publisher = self.create_publisher(ThermalFrame, 'thermal_frame', 10)
            self.timer = self.create_timer(1.0 / self.publish_rate, self.publish_thermal_frame)
            self.get_logger().info(f'Publishing thermal frames at {self.publish_rate} Hz')
        
        # Create service
        self.get_frame_service = self.create_service(
            GetThermalFrame, 
            'get_thermal_frame', 
            self.handle_get_thermal_frame
        )
        
        self.get_logger().info('Thermal camera node ready')
    
    def read_thermal_frame(self):
        """Read a frame from the thermal camera with error handling"""
        try:
            self.mlx.getFrame(self.flat)
            self.frame_count += 1
            self.consecutive_errors = 0  # Reset error counter on success
            
            # Calculate statistics
            min_temp = float(np.min(self.flat))
            max_temp = float(np.max(self.flat))
            avg_temp = float(np.mean(self.flat))
            
            # Get center temperature (middle of 24x32 array)
            frame2d = self.flat.reshape((24, 32))
            center_temp = float(frame2d[12, 16])
            
            # Create message
            msg = ThermalFrame()
            msg.header = Header()
            msg.header.stamp = self.get_clock().now().to_msg()
            msg.header.frame_id = self.frame_id
            
            msg.width = 32
            msg.height = 24
            msg.data = self.flat.tolist()
            
            msg.min_temp = min_temp
            msg.max_temp = max_temp
            msg.avg_temp = avg_temp
            msg.center_temp = center_temp
            msg.frame_count = self.frame_count
            
            return True, msg
            
        except (ValueError, OSError) as e:
            self.consecutive_errors += 1
            self.get_logger().warning(
                f'Error reading thermal frame ({self.consecutive_errors}/{self.max_consecutive_errors}): {e}'
            )
            
            if self.consecutive_errors >= self.max_consecutive_errors:
                self.get_logger().error('Too many consecutive errors, trying to reinitialize camera')
                self.reinitialize_camera()
            
            # Small delay before retry
            time.sleep(0.1)
            return False, None
        
        except Exception as e:
            self.get_logger().error(f'Unexpected error reading thermal frame: {e}')
            return False, None
    
    def reinitialize_camera(self):
        """Try to reinitialize the camera after errors"""
        try:
            self.get_logger().info('Attempting to reinitialize thermal camera...')
            time.sleep(1)  # Give it a moment
            
            i2c = busio.I2C(board.SCL, board.SDA)
            self.mlx = adafruit_mlx90640.MLX90640(i2c)
            self.mlx.refresh_rate = adafruit_mlx90640.RefreshRate.REFRESH_1_HZ
            
            self.consecutive_errors = 0
            self.get_logger().info('Camera reinitialized successfully')
            
        except Exception as e:
            self.get_logger().error(f'Failed to reinitialize camera: {e}')
    
    def publish_thermal_frame(self):
        """Timer callback to publish thermal frames"""
        success, msg = self.read_thermal_frame()
        if success and msg:
            self.publisher.publish(msg)
            self.get_logger().debug(
                f'Published frame {self.frame_count}: '
                f'min={msg.min_temp:.1f}°C, max={msg.max_temp:.1f}°C'
            )
    
    def handle_get_thermal_frame(self, request, response):
        """Service callback to get a single thermal frame"""
        success, msg = self.read_thermal_frame()
        
        response.success = success
        if success:
            response.message = f'Frame {self.frame_count} captured successfully'
            response.frame = msg
        else:
            response.message = 'Failed to capture thermal frame'
            response.frame = ThermalFrame()  # Empty frame
        
        return response

def main(args=None):
    rclpy.init(args=args)
    
    try:
        node = ThermalCameraNode()
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f'Error: {e}')
    finally:
        if 'node' in locals():
            node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
================================================================================


================================================================================
FILE: mlx90640_driver/setup.py
Category: Python | Size: 1.6 KB | Lines: 44
================================================================================
from setuptools import setup
import os
from glob import glob

package_name = "mlx90640_driver"

setup(
    name=package_name,
    version="0.0.0",
    packages=[package_name],
    # ------------------------------------------------------------------
    # Files that should be copied into the install tree
    # ------------------------------------------------------------------
    data_files=[
        # ① package-level resource (already present)
        ("share/ament_index/resource_index/packages",
         [f"resource/{package_name}"]),

        # ② executable-level resource  (<<< NEW line)
        ("share/ament_index/resource_index/ros2_executable",
         ["resource/thermal_camera_node"]),

        # ③ misc package data
        (f"share/{package_name}", ["package.xml"]),
        (os.path.join("share", package_name, "config"), glob("config/*.yaml")),
        (os.path.join("share", package_name, "launch"), glob("launch/*.py")),
    ],
    # ------------------------------------------------------------------
    install_requires=["setuptools"],
    zip_safe=True,
    maintainer="Your Name",
    maintainer_email="you@example.com",
    description="ROS 2 driver for MLX90640 thermal camera",
    license="Apache-2.0",
    tests_require=["pytest"],
    # ------------------------------------------------------------------
    # Entry-point script ROS 2 should expose via `ros2 run`
    # ------------------------------------------------------------------
    entry_points={
        "console_scripts": [
            "thermal_camera_node = mlx90640_driver.thermal_camera_node:main",
        ],
    },
)

================================================================================


================================================================================
FILE: pca9685_motor_driver_py/launch/motor_driver_launch.py
Category: Python | Size: 484.0 B | Lines: 15
================================================================================
from launch import LaunchDescription
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    cfg = os.path.join(
        get_package_share_directory('pca9685_motor_driver_py'),
        'config', 'motor_map.yaml')
    return LaunchDescription([
        Node(
            package='pca9685_motor_driver_py',
            executable='motor_driver_node',
            parameters=[cfg])
    ])

================================================================================


================================================================================
FILE: pca9685_motor_driver_py/pca9685_motor_driver_py/__init__.py
Category: Python | Size: 0.0 B | Lines: 0
================================================================================

================================================================================


================================================================================
FILE: pca9685_motor_driver_py/pca9685_motor_driver_py/motor_driver_node.py
Category: Python | Size: 8.2 KB | Lines: 229
================================================================================
#!/usr/bin/env python3
"""
motor_driver_node.py
--------------------
ROS 2 node that drives DC motors through an Adafruit PCA9685 PWM board.

Modified for dual-PWM motor drivers (like DBH-1A):
Each motor uses two PCA channels:
    • forward_ch – PWM for forward motion (0 when backward)
    • backward_ch – PWM for backward motion (0 when forward)

IMPROVEMENTS:
- Dead time only applied on direction changes
- Smooth speed transitions without stopping
- Configurable dead time parameter
- Better logging for debugging
"""

from __future__ import annotations
from typing import Dict, Tuple, Optional
import time

import rclpy
from rclpy.node import Node
from rclpy.parameter import Parameter
from rcl_interfaces.msg import ParameterDescriptor, ParameterType
from pca9685_interfaces.srv import SetMotor

# ────────────────────────────── hardware abstraction (stub fallback)
try:
    import board                # type: ignore
    import busio                # type: ignore
    import adafruit_pca9685     # type: ignore

    HARDWARE = True
except ImportError:             # running on a PC with no I²C bus
    HARDWARE = False

    class _DummyChannel:
        def __init__(self):
            self.duty_cycle = 0

    class _DummyPCA:
        def __init__(self):
            self.channels = [_DummyChannel() for _ in range(16)]
            self.frequency = 100

    class _DummyI2C:
        pass

    busio = type("busio", (), {"I2C": lambda *_: _DummyI2C()})
    board = type("board", (), {"SCL": None, "SDA": None})
    adafruit_pca9685 = type("adafruit_pca9685", (), {"PCA9685": _DummyPCA})

# ────────────────────────────── helpers
CLAMP = lambda v, lo=0, hi=0xFFFF: max(lo, min(hi, v))

# ────────────────────────────── main node
class MotorDriver(Node):
    def __init__(self):
        super().__init__("motor_driver")

        # 1. Declare parameters
        self.declare_parameter(
            "motor_map",
            [0, 1, 2, 3],  # default: 2 motors
            ParameterDescriptor(type=ParameterType.PARAMETER_INTEGER_ARRAY)
        )
        self.declare_parameter("pwm_frequency", 100)
        self.declare_parameter("dead_time_ms", 50)  # Dead time in milliseconds
        self.declare_parameter("min_speed_change", 5)  # Minimum PWM change to apply

        # 2. Read parameters
        flat_map = self.get_parameter("motor_map") \
                         .get_parameter_value().integer_array_value

        if len(flat_map) % 2:
            self.get_logger().fatal(
                "motor_map must contain an even number of integers "
                "(forward_ch, backward_ch pairs)")
            rclpy.shutdown()
            return

        # Convert flat list → {motor_id: (forward_ch, backward_ch)}
        self.motor_map: Dict[int, Tuple[int, int]] = {
            i: (flat_map[2 * i], flat_map[2 * i + 1])
            for i in range(len(flat_map) // 2)
        }
        
        pwm_freq = int(self.get_parameter("pwm_frequency").value)
        self.dead_time = self.get_parameter("dead_time_ms").value / 1000.0  # Convert to seconds
        self.min_speed_change = self.get_parameter("min_speed_change").value

        # 3. Init hardware (real or stub)
        i2c = busio.I2C(board.SCL, board.SDA)          # type: ignore
        self.pca = adafruit_pca9685.PCA9685(i2c)       # type: ignore
        self.pca.frequency = pwm_freq

        # 4. Track motor states to optimize transitions
        self.motor_states: Dict[int, Dict[str, any]] = {
            motor_id: {
                "direction": "brake",
                "speed": 0,
                "last_update": time.time()
            }
            for motor_id in self.motor_map.keys()
        }

        self.get_logger().info(
            f"🟢 Motor-driver ready — {len(self.motor_map)} motors, "
            f"PCA9685 freq {pwm_freq} Hz, dead_time {self.dead_time*1000}ms "
            f"({'real' if HARDWARE else 'dummy'} hardware)"
        )
        self.get_logger().info(f"Motor mapping: {self.motor_map}")

        # 5. ROS service
        self.create_service(SetMotor, "set_motor", self.handle_set_motor)

    # -------------------------- service callback -------------------------
    def handle_set_motor(
        self,
        req: SetMotor.Request,
        res: SetMotor.Response
    ) -> SetMotor.Response:

        mid, dirn, speed = req.motor_id, req.direction.lower(), CLAMP(req.speed)

        if mid not in self.motor_map:
            res.success = False
            res.message = f"motor {mid} not in motor_map"
            return res

        forward_ch, backward_ch = self.motor_map[mid]
        
        # Get current state
        current_state = self.motor_states[mid]
        current_direction = current_state["direction"]
        current_speed = current_state["speed"]
        
        # Check if this is a significant change
        speed_change = abs(speed - current_speed)
        direction_changed = (dirn != current_direction)
        
        # Skip if change is too small (unless stopping or changing direction)
        if not direction_changed and speed_change < self.min_speed_change and dirn != "brake":
            res.success = True
            res.message = f"Skipped minor speed change ({speed_change} < {self.min_speed_change})"
            return res

        # Apply dead time ONLY on direction changes (not speed changes)
        if direction_changed and current_direction != "brake" and dirn != "brake":
            # Direction change requires stopping first
            self.get_logger().info(
                f"Motor {mid} direction change: {current_direction} → {dirn}, applying dead time"
            )
            
            # Stop both channels
            self.pca.channels[forward_ch].duty_cycle = 0
            self.pca.channels[backward_ch].duty_cycle = 0
            
            # Apply dead time
            time.sleep(self.dead_time)
        
        # Apply new motor command
        if dirn == "forward":
            # For forward: backward=0, forward=PWM
            self.pca.channels[backward_ch].duty_cycle = 0
            self.pca.channels[forward_ch].duty_cycle = speed
            self.get_logger().info(
                f"Motor {mid} forward: speed {current_speed}→{speed} "
                f"(CH{forward_ch}={speed}, CH{backward_ch}=0)"
            )
            
        elif dirn == "backward":
            # For backward: forward=0, backward=PWM
            self.pca.channels[forward_ch].duty_cycle = 0
            self.pca.channels[backward_ch].duty_cycle = speed
            self.get_logger().info(
                f"Motor {mid} backward: speed {current_speed}→{speed} "
                f"(CH{forward_ch}=0, CH{backward_ch}={speed})"
            )
            
        elif dirn == "brake":
            # Brake: both channels to 0
            self.pca.channels[forward_ch].duty_cycle = 0
            self.pca.channels[backward_ch].duty_cycle = 0
            self.get_logger().info(
                f"Motor {mid} brake (CH{forward_ch}=0, CH{backward_ch}=0)"
            )
        else:
            res.success = False
            res.message = "direction must be forward/backward/brake"
            return res

        # Update motor state
        self.motor_states[mid] = {
            "direction": dirn,
            "speed": speed,
            "last_update": time.time()
        }

        res.success = True
        res.message = (
            f"motor {mid} dir={dirn} speed={speed} "
            f"(CH{forward_ch},CH{backward_ch})"
        )
        return res

# ────────────────────────────── entry-point
def main(args=None):
    rclpy.init(args=args)
    node = MotorDriver()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        # Stop all motors on shutdown
        for motor_id in node.motor_map.keys():
            forward_ch, backward_ch = node.motor_map[motor_id]
            node.pca.channels[forward_ch].duty_cycle = 0
            node.pca.channels[backward_ch].duty_cycle = 0
        
        node.destroy_node()
        rclpy.shutdown()


if __name__ == "__main__":
    main()
================================================================================


================================================================================
FILE: pca9685_motor_driver_py/setup.py
Category: Python | Size: 1.0 KB | Lines: 32
================================================================================
from setuptools import setup
from glob import glob
import os

package_name = "pca9685_motor_driver_py"

setup(
    name=package_name,
    version="0.0.0",
    packages=[package_name],
    install_requires=["setuptools"],
    zip_safe=True,
    author="Yang Yue",
    author_email="zcemuex@ucl.ac.uk",
    description="ROS 2 motor driver for a PCA9685 PWM board",
    license="MIT",
    entry_points={
        "console_scripts": [
            # ros2 run pca9685_motor_driver_py motor_driver_node
            f"motor_driver_node = {package_name}.motor_driver_node:main",
        ],
    },
    # non-python resources that must be installed
    data_files=[
        ("share/ament_index/resource_index/packages",
            [f"resource/{package_name}"]),
        (f"share/{package_name}",              ["package.xml"]),
        (f"share/{package_name}/launch",       glob("launch/*.py")),
        (f"share/{package_name}/config",       glob("config/*.yaml")),
        (f"share/{package_name}/srv",          glob("srv/*.srv")),
    ],
)

================================================================================


================================================================================
FILE: pca9685_motor_driver_py/test/test_copyright.py
Category: Python | Size: 962.0 B | Lines: 25
================================================================================
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_copyright.main import main
import pytest


# Remove the `skip` decorator once the source file(s) have a copyright header
@pytest.mark.skip(reason='No copyright header has been placed in the generated source file.')
@pytest.mark.copyright
@pytest.mark.linter
def test_copyright():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found errors'

================================================================================


================================================================================
FILE: pca9685_motor_driver_py/test/test_flake8.py
Category: Python | Size: 884.0 B | Lines: 25
================================================================================
# Copyright 2017 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_flake8.main import main_with_errors
import pytest


@pytest.mark.flake8
@pytest.mark.linter
def test_flake8():
    rc, errors = main_with_errors(argv=[])
    assert rc == 0, \
        'Found %d code style errors / warnings:\n' % len(errors) + \
        '\n'.join(errors)

================================================================================


================================================================================
FILE: pca9685_motor_driver_py/test/test_pep257.py
Category: Python | Size: 803.0 B | Lines: 23
================================================================================
# Copyright 2015 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from ament_pep257.main import main
import pytest


@pytest.mark.linter
@pytest.mark.pep257
def test_pep257():
    rc = main(argv=['.', 'test'])
    assert rc == 0, 'Found code style errors / warnings'

================================================================================


================================================================================
FILE: robot-dashboard/backend/__init__.py
Category: Python | Size: 285.0 B | Lines: 14
================================================================================
"""
Backend package for ROS 2 Motor Control
"""

from .ros_bridge import ROSBridgeConnection, MotorController, get_ros_bridge, get_motor_controller

__all__ = [
    'ROSBridgeConnection',
    'MotorController', 
    'get_ros_bridge',
    'get_motor_controller'
]

__version__ = '1.0.0'
================================================================================


================================================================================
FILE: robot-dashboard/backend/config_manager.py
Category: Python | Size: 3.3 KB | Lines: 105
================================================================================
#!/usr/bin/env python3
"""
Configuration manager for persistent settings
Saves and loads configuration from a JSON file
"""

import json
import os
from pathlib import Path
import logging

logger = logging.getLogger(__name__)

class ConfigManager:
    """Manages persistent configuration settings"""
    
    def __init__(self, config_file: str = None):
        """
        Initialize configuration manager
        
        Args:
            config_file: Path to configuration file (default: ~/.robot_dashboard_config.json)
        """
        if config_file is None:
            # Use home directory for config file
            self.config_file = Path.home() / ".robot_dashboard_config.json"
        else:
            self.config_file = Path(config_file)
        
        # Default configuration
        self.default_config = {
            "PI_IP": "192.168.2.1",
            "ROS_BRIDGE_PORT": 9090,
            "FLASK_PORT": 5001,
            "FLASK_HOST": "0.0.0.0"
        }
        
        # Load configuration
        self.config = self.load_config()
    
    def load_config(self) -> dict:
        """Load configuration from file or return defaults"""
        try:
            if self.config_file.exists():
                with open(self.config_file, 'r') as f:
                    loaded_config = json.load(f)
                    # Merge with defaults (in case new fields are added)
                    config = self.default_config.copy()
                    config.update(loaded_config)
                    logger.info(f"Loaded configuration from {self.config_file}")
                    return config
            else:
                logger.info("No config file found, using defaults")
                return self.default_config.copy()
        except Exception as e:
            logger.error(f"Error loading config: {e}")
            return self.default_config.copy()
    
    def save_config(self):
        """Save current configuration to file"""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
            logger.info(f"Saved configuration to {self.config_file}")
            return True
        except Exception as e:
            logger.error(f"Error saving config: {e}")
            return False
    
    def update_config(self, updates: dict) -> bool:
        """
        Update configuration values
        
        Args:
            updates: Dictionary of configuration updates
            
        Returns:
            bool: True if successful
        """
        try:
            # Update configuration
            self.config.update(updates)
            # Save to file
            return self.save_config()
        except Exception as e:
            logger.error(f"Error updating config: {e}")
            return False
    
    def get(self, key: str, default=None):
        """Get configuration value"""
        return self.config.get(key, default)
    
    def get_all(self) -> dict:
        """Get all configuration values"""
        return self.config.copy()

# Singleton instance
_config_manager = None

def get_config_manager(config_file: str = None) -> ConfigManager:
    """Get or create ConfigManager instance"""
    global _config_manager
    if _config_manager is None:
        _config_manager = ConfigManager(config_file)
    return _config_manager
================================================================================


================================================================================
FILE: robot-dashboard/backend/host_backend.py
Category: Python | Size: 17.6 KB | Lines: 571
================================================================================
#!/usr/bin/env python3
"""
Flask backend server for ROS 2 robot control
Main application entry point with multi-component support
"""

import os
import sys
from pathlib import Path

# Add parent directory to path for imports
sys.path.append(str(Path(__file__).parent.parent))

from flask import Flask, render_template, jsonify, request
from flask_cors import CORS
from flask_socketio import SocketIO, emit
import logging

# Import configuration manager
from backend.config_manager import get_config_manager

# Import ROS bridge components
from backend.ros_bridge import get_ros_bridge, get_motor_controller
from backend.sensors.lidar import get_lidar_sensor
from backend.sensors.thermal_camera import get_thermal_camera_sensor
from backend.motors.servo_control import ServoController

# Create Flask app
app = Flask(__name__, 
            template_folder='../frontend/templates',
            static_folder='../frontend/static')
CORS(app)  # Enable CORS for API requests
socketio = SocketIO(app, cors_allowed_origins="*")  # For real-time data

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Load configuration from persistent storage
config_manager = get_config_manager()
CONFIG = config_manager.get_all()

# Initialize ROS components with saved configuration
ros_bridge = get_ros_bridge(CONFIG["PI_IP"], CONFIG["ROS_BRIDGE_PORT"])
motor_controller = get_motor_controller()
lidar_sensor = get_lidar_sensor()
thermal_camera_sensor = get_thermal_camera_sensor()
servo_controller = ServoController()

# Set ROS bridge for servo controller
servo_controller.set_ros_bridge(ros_bridge)

# Data streaming states
lidar_streaming = False
servo_streaming = False

# =============================================================================
# MAIN DASHBOARD ROUTES
# =============================================================================

@app.route('/')
def index():
    """Serve the main dashboard home page"""
    return render_template('dashboard_home.html')

@app.route('/motors')
def motors_page():
    """Serve the motor control interface"""
    return render_template('motor_control.html')

@app.route('/lidar')
def lidar_page():
    """Serve the lidar visualization interface"""
    return render_template('lidar_visualization.html')

@app.route('/thermal')
def thermal_page():
    """Serve the thermal camera interface"""
    return render_template('thermal_camera.html')

@app.route('/aiming')
def aiming_system():
    """Serve the aiming system control interface"""
    return render_template('aiming_system.html')

# =============================================================================
# MOTOR CONTROL API ROUTES
# =============================================================================

@app.route('/api/motor/<int:motor_id>', methods=['POST'])
def control_motor(motor_id):
    """Control a specific motor"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        # Use motor controller
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in control_motor: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/motor/<int:motor_id>', methods=['GET'])
def get_motor_status(motor_id):
    """Get current status of a specific motor"""
    state = motor_controller.get_motor_state(motor_id)
    
    if state:
        return jsonify({
            "success": True,
            "motor_id": motor_id,
            "state": state
        })
    else:
        return jsonify({
            "success": False,
            "error": "Invalid motor ID"
        }), 404

@app.route('/api/motors', methods=['GET'])
def get_all_motors_status():
    """Get current status of all motors"""
    states = motor_controller.get_all_motor_states()
    
    return jsonify({
        "success": True,
        "motors": states
    })

@app.route('/api/motors/stop', methods=['POST'])
def stop_all_motors():
    """Emergency stop - brake all motors"""
    result = motor_controller.stop_all_motors()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

# =============================================================================
# SERVO/AIMING SYSTEM API ROUTES
# =============================================================================

@app.route('/api/servo/position', methods=['POST'])
def set_servo_position():
    """Set servo position for pan/tilt"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        pan_angle = data.get('pan_angle', servo_controller.pan_angle)
        tilt_angle = data.get('tilt_angle', servo_controller.tilt_angle)
        
        # Move servos
        result = servo_controller.move_to_position(pan_angle, tilt_angle)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in set_servo_position: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/servo/position', methods=['GET'])
def get_servo_position():
    """Get current servo position"""
    state = servo_controller.get_state()
    
    return jsonify({
        "success": True,
        "state": state
    })

@app.route('/api/servo/center', methods=['POST'])
def center_servos():
    """Move servos to center position"""
    result = servo_controller.center_position()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 400

@app.route('/api/servo/preset/<string:position>', methods=['POST'])
def move_to_preset(position):
    """Move servos to preset position (left, right, up, down)"""
    preset_functions = {
        'left': servo_controller.move_left,
        'right': servo_controller.move_right,
        'up': servo_controller.move_up,
        'down': servo_controller.move_down,
        'center': servo_controller.center_position
    }
    
    if position not in preset_functions:
        return jsonify({
            "success": False,
            "error": f"Invalid preset position: {position}"
        }), 400
    
    result = preset_functions[position]()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 400

# =============================================================================
# LIDAR API ROUTES
# =============================================================================

@app.route('/api/lidar/status', methods=['GET'])
def get_lidar_status():
    """Get lidar sensor status"""
    latest_scan = lidar_sensor.get_latest_scan()
    
    return jsonify({
        "connected": lidar_sensor.subscription_active,
        "has_data": latest_scan is not None,
        "timestamp": latest_scan["timestamp"] if latest_scan else None
    })

@app.route('/api/lidar/latest', methods=['GET'])
def get_latest_lidar_scan():
    """Get the most recent lidar scan data"""
    scan_data = lidar_sensor.get_latest_scan()
    
    if scan_data:
        return jsonify({
            "success": True,
            "data": scan_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "No scan data available"
        }), 404

@app.route('/api/lidar/subscribe', methods=['POST'])
def subscribe_lidar():
    """Start lidar data subscription"""
    global lidar_streaming
    
    def lidar_callback(scan_data):
        """Emit lidar data through WebSocket"""
        if lidar_streaming:
            socketio.emit('lidar_data', scan_data)
    
    success = lidar_sensor.subscribe(callback=lidar_callback, processed_data=True)
    
    if success:
        lidar_streaming = True
        return jsonify({"success": True, "message": "Lidar subscription started"})
    else:
        return jsonify({"success": False, "error": "Failed to subscribe to lidar"}), 500

@app.route('/api/lidar/unsubscribe', methods=['POST'])
def unsubscribe_lidar():
    """Stop lidar data subscription"""
    global lidar_streaming
    
    lidar_streaming = False
    lidar_sensor.unsubscribe()
    
    return jsonify({"success": True, "message": "Lidar subscription stopped"})

# =============================================================================
# THERMAL CAMERA API ROUTES
# =============================================================================

@app.route('/api/thermal/status', methods=['GET'])
def get_thermal_status():
    """Get thermal camera sensor status"""
    latest_frame = thermal_camera_sensor.get_latest_frame()
    
    return jsonify({
        "connected": thermal_camera_sensor.subscription_active,
        "has_data": latest_frame is not None,
        "timestamp": latest_frame["timestamp"] if latest_frame else None
    })

@app.route('/api/thermal/latest', methods=['GET'])
def get_latest_thermal_frame():
    """Get the most recent thermal frame data"""
    frame_data = thermal_camera_sensor.get_latest_frame()
    
    if frame_data:
        return jsonify({
            "success": True,
            "data": frame_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "No thermal data available"
        }), 404

@app.route('/api/thermal/frame', methods=['GET'])
def get_thermal_frame():
    """Get a single thermal frame via service call"""
    frame_data = thermal_camera_sensor.get_thermal_frame_once()
    
    if frame_data:
        return jsonify({
            "success": True,
            "data": frame_data
        })
    else:
        return jsonify({
            "success": False,
            "error": "Failed to capture thermal frame"
        }), 500

@app.route('/api/thermal/subscribe', methods=['POST'])
def subscribe_thermal():
    """Start thermal camera data subscription"""
    def thermal_callback(frame_data):
        """Emit thermal data through WebSocket"""
        socketio.emit('thermal_data', frame_data)
    
    success = thermal_camera_sensor.subscribe(callback=thermal_callback)
    
    if success:
        return jsonify({"success": True, "message": "Thermal camera subscription started"})
    else:
        return jsonify({"success": False, "error": "Failed to subscribe to thermal camera"}), 500

@app.route('/api/thermal/unsubscribe', methods=['POST'])
def unsubscribe_thermal():
    """Stop thermal camera data subscription"""
    thermal_camera_sensor.unsubscribe()
    
    return jsonify({"success": True, "message": "Thermal camera subscription stopped"})

# =============================================================================
# SYSTEM STATUS ROUTES
# =============================================================================

@app.route('/api/status', methods=['GET'])
def get_system_status():
    """Check connection status to ROS bridge and system info"""
    ros_connected = ros_bridge.test_connection()
    
    return jsonify({
        "connected": ros_connected,
        "rosbridge_url": ros_bridge.url,
        "config": {
            "robot_ip": CONFIG["PI_IP"],
            "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"]
        },
        "components": {
            "motors": True,
            "lidar": lidar_sensor.subscription_active,
            "thermal": thermal_camera_sensor.subscription_active,
            "servo": servo_controller.connected
        }
    }), 200 if ros_connected else 503

@app.route('/api/config', methods=['GET'])
def get_config():
    """Get current configuration"""
    return jsonify({
        "robot_ip": CONFIG["PI_IP"],
        "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"],
        "flask_port": CONFIG["FLASK_PORT"],
        "flask_host": CONFIG["FLASK_HOST"]
    })

@app.route('/api/config', methods=['POST'])
def update_config():
    """Update configuration with new connection settings"""
    try:
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        # Get new settings
        new_ip = data.get('robot_ip')
        new_port = data.get('rosbridge_port')
        
        if not new_ip or not new_port:
            return jsonify({"error": "Missing robot_ip or rosbridge_port"}), 400
        
        # Update configuration in memory
        CONFIG["PI_IP"] = new_ip
        CONFIG["ROS_BRIDGE_PORT"] = int(new_port)
        
        # Save to persistent storage
        config_updates = {
            "PI_IP": new_ip,
            "ROS_BRIDGE_PORT": int(new_port)
        }
        config_manager.update_config(config_updates)
        
        # Update ROS bridge connection
        global ros_bridge, motor_controller, lidar_sensor, thermal_camera_sensor, servo_controller
        ros_bridge = get_ros_bridge(CONFIG["PI_IP"], CONFIG["ROS_BRIDGE_PORT"])
        motor_controller = get_motor_controller()
        lidar_sensor = get_lidar_sensor()
        thermal_camera_sensor = get_thermal_camera_sensor()
        
        # Update servo controller with new ROS bridge
        servo_controller.set_ros_bridge(ros_bridge)
        
        logger.info(f"Configuration updated and saved: IP={new_ip}, Port={new_port}")
        
        return jsonify({
            "success": True,
            "message": "Configuration updated successfully",
            "config": {
                "robot_ip": CONFIG["PI_IP"],
                "rosbridge_port": CONFIG["ROS_BRIDGE_PORT"]
            }
        })
        
    except Exception as e:
        logger.error(f"Error updating configuration: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

# =============================================================================
# WEBSOCKET EVENTS
# =============================================================================

@socketio.on('connect')
def handle_connect():
    """Handle WebSocket connection"""
    logger.info("Client connected to WebSocket")
    emit('connected', {'data': 'Connected to robot dashboard'})

@socketio.on('disconnect')
def handle_disconnect():
    """Handle WebSocket disconnection"""
    logger.info("Client disconnected from WebSocket")

# Servo WebSocket events
@socketio.on('servo_command')
def handle_servo_command(data):
    """Handle servo commands via WebSocket"""
    global servo_streaming
    
    try:
        command_type = data.get('type', 'servo_command')
        
        if command_type == 'servo_command':
            result = servo_controller.handle_websocket_command(data)
            
            # Send response
            emit('servo_response', {
                'type': 'command_result',
                'result': result
            })
            
            # Send updated state to all clients
            state = servo_controller.get_state()
            socketio.emit('servo_state', {
                'type': 'servo_state',
                **state
            })
            
    except Exception as e:
        logger.error(f"Error handling servo command: {e}")
        emit('servo_error', {
            'type': 'error',
            'error': str(e)
        })

@socketio.on('request_servo_state')
def handle_servo_state_request():
    """Send current servo state via WebSocket"""
    state = servo_controller.get_state()
    emit('servo_state', {
        'type': 'servo_state',
        **state
    })

# =============================================================================
# ERROR HANDLERS
# =============================================================================

@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Not found"}), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({"error": "Internal server error"}), 500

# Health check endpoint
@app.route('/health', methods=['GET'])
def health_check():
    """Simple health check endpoint"""
    return jsonify({
        "status": "healthy",
        "service": "robot-dashboard-backend"
    })

# =============================================================================
# INITIALIZATION
# =============================================================================

def initialize_system():
    """Initialize all system components"""
    logger.info("Initializing system components...")
    
    # Set WebSocket handler for servo updates
    def servo_websocket_handler(data):
        """Handle servo state updates"""
        socketio.emit('servo_state', data)
    
    servo_controller.set_websocket_handler(servo_websocket_handler)
    
    # Initialize servo to center position
    logger.info("Moving servos to center position...")
    servo_controller.center_position()
    
    logger.info("System initialization complete")

def main():
    """Main entry point"""
    logger.info("=" * 50)
    logger.info("ROS 2 Robot Dashboard Backend")
    logger.info(f"Robot IP: {CONFIG['PI_IP']}")
    logger.info(f"ROS Bridge Port: {CONFIG['ROS_BRIDGE_PORT']}")
    logger.info(f"Flask Server: {CONFIG['FLASK_HOST']}:{CONFIG['FLASK_PORT']}")
    logger.info(f"Config file: {config_manager.config_file}")
    logger.info("=" * 50)
    
    # Initialize system
    initialize_system()
    
    # Run Flask app with SocketIO
    debug_mode = os.environ.get('FLASK_ENV', 'development') == 'development'
    
    socketio.run(
        app,
        debug=debug_mode,
        host=CONFIG['FLASK_HOST'],
        port=CONFIG['FLASK_PORT'],
        use_reloader=False  # Disable auto-reloader to prevent numpy reload issues
    )

if __name__ == '__main__':
    main()
================================================================================


================================================================================
FILE: robot-dashboard/backend/motors/__init__.py
Category: Python | Size: 0.0 B | Lines: 0
================================================================================

================================================================================


================================================================================
FILE: robot-dashboard/backend/motors/motor_controller.py
Category: Python | Size: 6.3 KB | Lines: 192
================================================================================
"""
Motor Controller Module
Handles motor control logic and ROS communication
"""

import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

class MotorController:
    """Motor controller for 4-motor robot using L298N drivers"""
    
    def __init__(self, ros_bridge=None):
        self.ros_bridge = ros_bridge
        
        # Motor state tracking
        self.motor_states = {
            1: {"direction": "brake", "speed": 0},
            2: {"direction": "brake", "speed": 0},
            3: {"direction": "brake", "speed": 0},
            4: {"direction": "brake", "speed": 0}
        }
        
        # Motor channel mapping (2 motors per L298N channel)
        self.motor_to_channel = {
            1: 'A',  # Front-left
            2: 'A',  # Front-right
            3: 'B',  # Rear-left
            4: 'B'   # Rear-right
        }
        
        logger.info("Motor controller initialized")
    
    def set_ros_bridge(self, ros_bridge):
        """Set or update the ROS bridge instance"""
        self.ros_bridge = ros_bridge
        logger.info("ROS bridge connected to motor controller")
    
    def set_motor(self, motor_id: int, direction: str, speed: int) -> Dict[str, Any]:
        """
        Control a specific motor
        
        Args:
            motor_id: Motor number (1-4)
            direction: 'forward', 'backward', or 'brake'
            speed: Speed value (0-100)
        
        Returns:
            Result dictionary with success status
        """
        # Validate inputs
        if motor_id not in range(1, 5):
            return {
                "success": False,
                "error": f"Invalid motor ID: {motor_id}. Must be 1-4."
            }
        
        if direction not in ['forward', 'backward', 'brake']:
            return {
                "success": False,
                "error": f"Invalid direction: {direction}"
            }
        
        # Clamp speed to valid range
        speed = max(0, min(100, speed))
        
        # Update motor state
        self.motor_states[motor_id] = {
            "direction": direction,
            "speed": speed
        }
        
        # Get channel for this motor
        channel = self.motor_to_channel[motor_id]
        
        # Send command via ROS bridge if available
        if self.ros_bridge:
            try:
                # For motors sharing a channel, we need to consider both motors
                channel_motors = [m for m, ch in self.motor_to_channel.items() if ch == channel]
                
                # If both motors on the channel have the same direction, use that
                # Otherwise, handle mixed directions appropriately
                channel_direction = direction
                channel_speed = speed
                
                # Send motor command
                self.ros_bridge.send_motor_command(channel, channel_direction, channel_speed)
                
                logger.info(f"Motor {motor_id} set to {direction} at speed {speed}")
                
                return {
                    "success": True,
                    "motor_id": motor_id,
                    "direction": direction,
                    "speed": speed,
                    "channel": channel
                }
                
            except Exception as e:
                logger.error(f"Failed to send motor command: {e}")
                return {
                    "success": False,
                    "error": str(e)
                }
        else:
            # No ROS bridge - just update local state
            return {
                "success": True,
                "motor_id": motor_id,
                "direction": direction,
                "speed": speed,
                "message": "Motor state updated (no ROS bridge connected)"
            }
    
    def get_motor_state(self, motor_id: int) -> Optional[Dict[str, Any]]:
        """Get current state of a specific motor"""
        if motor_id in self.motor_states:
            return self.motor_states[motor_id]
        return None
    
    def get_all_motor_states(self) -> Dict[int, Dict[str, Any]]:
        """Get current state of all motors"""
        return self.motor_states.copy()
    
    def stop_all_motors(self) -> Dict[str, Any]:
        """Emergency stop - brake all motors"""
        try:
            for motor_id in range(1, 5):
                self.set_motor(motor_id, "brake", 0)
            
            logger.warning("Emergency stop - all motors braked")
            
            return {
                "success": True,
                "message": "All motors stopped"
            }
            
        except Exception as e:
            logger.error(f"Failed to stop all motors: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def set_channel_motors(self, channel: str, direction: str, speed: int) -> Dict[str, Any]:
        """
        Control all motors on a specific channel
        Used for coordinated movement (e.g., both left motors for turning)
        
        Args:
            channel: 'A' or 'B'
            direction: 'forward', 'backward', or 'brake'
            speed: Speed value (0-100)
        """
        if channel not in ['A', 'B']:
            return {
                "success": False,
                "error": f"Invalid channel: {channel}"
            }
        
        # Find motors on this channel
        channel_motors = [m for m, ch in self.motor_to_channel.items() if ch == channel]
        
        # Set all motors on the channel
        for motor_id in channel_motors:
            result = self.set_motor(motor_id, direction, speed)
            if not result['success']:
                return result
        
        return {
            "success": True,
            "channel": channel,
            "motors": channel_motors,
            "direction": direction,
            "speed": speed
        }

# Singleton instance
_motor_controller_instance = None

def get_motor_controller(ros_bridge=None):
    """Get or create motor controller instance"""
    global _motor_controller_instance
    
    if _motor_controller_instance is None:
        _motor_controller_instance = MotorController(ros_bridge)
    elif ros_bridge is not None:
        _motor_controller_instance.set_ros_bridge(ros_bridge)
    
    return _motor_controller_instance
================================================================================


================================================================================
FILE: robot-dashboard/backend/motors/motor_routes.py
Category: Python | Size: 3.7 KB | Lines: 121
================================================================================
"""
Motor Control Routes Module
Handles all motor-related API endpoints
"""

from flask import Blueprint, jsonify, request, render_template
import logging
from backend.motor.motor_controller import get_motor_controller

# Create Blueprint
motor_bp = Blueprint('motors', __name__)

# Setup logging
logger = logging.getLogger(__name__)

# =============================================================================
# MOTOR PAGE ROUTE
# =============================================================================

@motor_bp.route('/motors')
def motors_page():
    """Serve the motor control interface"""
    return render_template('motor_control.html')

# =============================================================================
# MOTOR CONTROL API ROUTES
# =============================================================================

@motor_bp.route('/api/motor/<int:motor_id>', methods=['POST'])
def control_motor(motor_id):
    """Control a specific motor"""
    try:
        motor_controller = get_motor_controller()
        data = request.get_json()
        
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        # Use motor controller
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        if result['success']:
            return jsonify(result)
        else:
            return jsonify(result), 400
            
    except Exception as e:
        logger.error(f"Error in control_motor: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@motor_bp.route('/api/motor/<int:motor_id>', methods=['GET'])
def get_motor_status(motor_id):
    """Get current status of a specific motor"""
    motor_controller = get_motor_controller()
    state = motor_controller.get_motor_state(motor_id)
    
    if state:
        return jsonify({
            "success": True,
            "motor_id": motor_id,
            "state": state
        })
    else:
        return jsonify({
            "success": False,
            "error": "Invalid motor ID"
        }), 404

@motor_bp.route('/api/motors', methods=['GET'])
def get_all_motors_status():
    """Get current status of all motors"""
    motor_controller = get_motor_controller()
    states = motor_controller.get_all_motor_states()
    
    return jsonify({
        "success": True,
        "motors": states
    })

@motor_bp.route('/api/motors/stop', methods=['POST'])
def stop_all_motors():
    """Emergency stop - brake all motors"""
    motor_controller = get_motor_controller()
    result = motor_controller.stop_all_motors()
    
    if result['success']:
        return jsonify(result)
    else:
        return jsonify(result), 500

# Optional: WebSocket support for real-time motor control
def init_motor_websocket(socketio):
    """Initialize WebSocket handlers for motor control"""
    
    @socketio.on('motor_command')
    def handle_motor_command(data):
        """Handle real-time motor commands via WebSocket"""
        motor_controller = get_motor_controller()
        motor_id = data.get('motor_id')
        direction = data.get('direction', 'brake')
        speed = data.get('speed', 0)
        
        result = motor_controller.set_motor(motor_id, direction, speed)
        
        socketio.emit('motor_response', {
            'motor_id': motor_id,
            'result': result
        })
    
    @socketio.on('request_motor_states')
    def handle_motor_states_request():
        """Send current motor states via WebSocket"""
        motor_controller = get_motor_controller()
        states = motor_controller.get_all_motor_states()
        socketio.emit('motor_states', states)
================================================================================


================================================================================
FILE: robot-dashboard/backend/motors/servo_control.py
Category: Python | Size: 6.7 KB | Lines: 199
================================================================================
"""
Servo Control Interface for Aiming System
Controls pan and tilt servos through ROS2 topics
"""

import json
import logging
from typing import Dict, Any, Optional, Callable
from datetime import datetime
import asyncio

logger = logging.getLogger(__name__)

class ServoController:
    def __init__(self):
        self.pan_angle = 135.0  # Default center position
        self.tilt_angle = 135.0  # Default center position
        self.pan_moving = False
        self.tilt_moving = False
        self.connected = False
        self.ros_bridge = None
        self.websocket_handler = None
        self.last_command_time = None
        
        # Servo limits
        self.pan_min = 75.0
        self.pan_max = 195.0
        self.tilt_min = 75.0
        self.tilt_max = 195.0
        
        # Movement tracking
        self.target_pan = 135.0
        self.target_tilt = 135.0
        self.movement_speed = 60.0  # degrees per second
        
        logger.info("Servo controller initialized")
    
    def set_ros_bridge(self, ros_bridge):
        """Set the ROS bridge instance for publishing commands"""
        self.ros_bridge = ros_bridge
        self.connected = True
        logger.info("ROS bridge connected to servo controller")
    
    def set_websocket_handler(self, handler: Callable):
        """Set the WebSocket handler for sending updates"""
        self.websocket_handler = handler
    
    def move_to_position(self, pan: float, tilt: float) -> Dict[str, Any]:
        """
        Move servos to specified position (synchronous version)
        
        Args:
            pan: Pan angle (75-195 degrees)
            tilt: Tilt angle (75-195 degrees)
            
        Returns:
            Status dictionary
        """
        # Run async version in sync context
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        result = loop.run_until_complete(self._async_move_to_position(pan, tilt))
        loop.close()
        return result
    
    async def _async_move_to_position(self, pan: float, tilt: float) -> Dict[str, Any]:
        """
        Move servos to specified position (async version)
        
        Args:
            pan: Pan angle (75-195 degrees)
            tilt: Tilt angle (75-195 degrees)
            
        Returns:
            Status dictionary
        """
        # Validate angles
        pan = max(self.pan_min, min(self.pan_max, pan))
        tilt = max(self.tilt_min, min(self.tilt_max, tilt))
        
        self.target_pan = pan
        self.target_tilt = tilt
        self.last_command_time = datetime.now()
        
        # Check if movement needed
        if abs(self.pan_angle - pan) > 0.5:
            self.pan_moving = True
        if abs(self.tilt_angle - tilt) > 0.5:
            self.tilt_moving = True
        
        # Send ROS command if bridge available
        if self.ros_bridge:
            try:
                from backend.ros_bridge import get_servo_publisher
                servo_pub = get_servo_publisher()
                success = servo_pub.publish_position(pan, tilt)
                if success:
                    logger.info(f"Servo command sent: pan={pan}, tilt={tilt}")
                else:
                    logger.error("Failed to publish servo command")
                    return {
                        'success': False,
                        'error': 'Failed to publish servo command'
                    }
            except Exception as e:
                logger.error(f"Failed to send servo command: {e}")
                return {
                    'success': False,
                    'error': str(e)
                }
        
        # Update positions immediately for UI feedback
        self.pan_angle = pan
        self.tilt_angle = tilt
        self.pan_moving = False
        self.tilt_moving = False
        
        return {
            'success': True,
            'pan_angle': pan,
            'tilt_angle': tilt,
            'message': f"Moving to pan={pan}°, tilt={tilt}°"
        }
    
    def get_state(self) -> Dict[str, Any]:
        """Get current servo state"""
        return {
            'pan_angle': round(self.pan_angle, 1),
            'tilt_angle': round(self.tilt_angle, 1),
            'pan_moving': self.pan_moving,
            'tilt_moving': self.tilt_moving,
            'connected': self.connected,
            'target_pan': self.target_pan,
            'target_tilt': self.target_tilt,
            'timestamp': datetime.now().isoformat()
        }
    
    def center_position(self) -> Dict[str, Any]:
        """Move servos to center position (135, 135)"""
        return self.move_to_position(135.0, 135.0)
    
    def move_left(self) -> Dict[str, Any]:
        """Move to left position"""
        return self.move_to_position(75.0, 135.0)
    
    def move_right(self) -> Dict[str, Any]:
        """Move to right position"""
        return self.move_to_position(195.0, 135.0)
    
    def move_up(self) -> Dict[str, Any]:
        """Move to up position"""
        return self.move_to_position(135.0, 195.0)
    
    def move_down(self) -> Dict[str, Any]:
        """Move to down position"""
        return self.move_to_position(135.0, 75.0)
    
    def emergency_stop(self):
        """Stop all servo movement"""
        self.pan_moving = False
        self.tilt_moving = False
        self.target_pan = self.pan_angle
        self.target_tilt = self.tilt_angle
        logger.warning("Emergency stop activated for servos")
    
    def process_ros_feedback(self, data: Dict[str, Any]):
        """Process feedback from ROS about actual servo positions"""
        if 'pan_angle' in data:
            self.pan_angle = data['pan_angle']
        if 'tilt_angle' in data:
            self.tilt_angle = data['tilt_angle']
        
        # Check if reached target
        if abs(self.pan_angle - self.target_pan) < 1.0:
            self.pan_moving = False
        if abs(self.tilt_angle - self.target_tilt) < 1.0:
            self.tilt_moving = False
    
    def handle_websocket_command(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Handle commands from WebSocket (synchronous)"""
        action = data.get('action')
        
        if action == 'move':
            pan = data.get('pan_angle', self.pan_angle)
            tilt = data.get('tilt_angle', self.tilt_angle)
            return self.move_to_position(pan, tilt)
        
        elif action == 'center':
            return self.center_position()
        
        elif action == 'get_state':
            return self.get_state()
        
        elif action == 'emergency_stop':
            self.emergency_stop()
            return {'success': True, 'message': 'Emergency stop activated'}
        
        else:
            return {'success': False, 'error': f'Unknown action: {action}'}
================================================================================


================================================================================
FILE: robot-dashboard/backend/ros_bridge.py
Category: Python | Size: 14.3 KB | Lines: 458
================================================================================
#!/usr/bin/env python3
"""
ROS Bridge WebSocket communication module
Handles all ROS 2 communication via rosbridge
"""

import json
import logging
from websocket import create_connection
from typing import Dict, Any, Optional, Tuple

# Setup logging
logger = logging.getLogger(__name__)

class ROSBridgeConnection:
    """Manages WebSocket connection to ROS 2 via rosbridge"""
    
    def __init__(self, host: str = "192.168.2.4", port: int = 9090):
        """
        Initialize ROS Bridge connection parameters
        
        Args:
            host: IP address of the ROS 2 robot
            port: rosbridge websocket port (default: 9090)
        """
        self.host = host
        self.port = port
        self.url = f"ws://{host}:{port}"
        self._connection = None
    
    def connect(self) -> bool:
        """
        Establish connection to rosbridge
        
        Returns:
            bool: True if connection successful, False otherwise
        """
        try:
            self._connection = create_connection(self.url, timeout=5)
            logger.info(f"Connected to rosbridge at {self.url}")
            return True
        except Exception as e:
            logger.error(f"Failed to connect to rosbridge: {e}")
            return False
    
    def disconnect(self):
        """Close the websocket connection"""
        if self._connection:
            self._connection.close()
            self._connection = None
            logger.info("Disconnected from rosbridge")
    
    def is_connected(self) -> bool:
        """Check if connection is active"""
        return self._connection is not None
    
    def call_service(self, service_name: str, args: Dict[str, Any], 
                    service_id: Optional[str] = None) -> Tuple[bool, Dict[str, Any]]:
        """
        Call a ROS service through rosbridge
        
        Args:
            service_name: Name of the ROS service (e.g., "/set_motor")
            args: Service arguments as dictionary
            service_id: Optional ID for the service call
        
        Returns:
            Tuple[bool, Dict]: (success, response_data)
        """
        try:
            # Try to create a new connection for each call to avoid broken pipe
            ws = create_connection(self.url, timeout=5)
            
            # Prepare service call message
            request = {
                "op": "call_service",
                "service": service_name,
                "args": args
            }
            
            if service_id:
                request["id"] = service_id
            
            # Send request
            ws.send(json.dumps(request))
            
            # Get response
            response = ws.recv()
            response_data = json.loads(response)
            
            # Close connection
            ws.close()
            
            logger.debug(f"Service call response: {response_data}")
            return True, response_data
            
        except Exception as e:
            logger.error(f"Service call failed: {e}")
            return False, {"error": str(e)}
    
    def publish_topic(self, topic_name: str, msg_type: str, msg_data: Dict[str, Any]) -> bool:
        """
        Publish a message to a ROS topic
        
        Args:
            topic_name: Name of the ROS topic (e.g., "/servo_position_cmd")
            msg_type: ROS message type (e.g., "servo_interfaces/msg/ServoPosition")
            msg_data: Message data as dictionary
        
        Returns:
            bool: True if publish successful, False otherwise
        """
        try:
            # Create a new connection for publishing
            ws = create_connection(self.url, timeout=5)
            
            # First advertise the topic
            advertise_msg = {
                "op": "advertise",
                "topic": topic_name,
                "type": msg_type
            }
            ws.send(json.dumps(advertise_msg))
            
            # Then publish the message
            publish_msg = {
                "op": "publish",
                "topic": topic_name,
                "msg": msg_data
            }
            ws.send(json.dumps(publish_msg))
            
            # Close connection
            ws.close()
            
            logger.debug(f"Published to {topic_name}: {msg_data}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to publish to topic {topic_name}: {e}")
            return False
    
    def subscribe_topic(self, topic_name: str, callback=None) -> bool:
        """
        Subscribe to a ROS topic
        
        Args:
            topic_name: Name of the ROS topic
            callback: Function to call when message received
        
        Returns:
            bool: True if subscription successful
        """
        try:
            if not self._connection:
                self.connect()
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": topic_name
            }
            self._connection.send(json.dumps(subscribe_msg))
            
            logger.info(f"Subscribed to topic: {topic_name}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to topic {topic_name}: {e}")
            return False
    
    def test_connection(self) -> bool:
        """
        Test if rosbridge connection is working
        
        Returns:
            bool: True if connection is working
        """
        try:
            temp_conn = create_connection(self.url, timeout=2)
            temp_conn.close()
            return True
        except Exception:
            return False

class MotorController:
    """High-level motor control interface using ROSBridge"""
    
    def __init__(self, ros_bridge: ROSBridgeConnection):
        """
        Initialize motor controller
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.motor_states = {
            0: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            1: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            2: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0},
            3: {"direction": "brake", "speed_percent": 0, "speed_pwm": 0}
        }
    
    @staticmethod
    def percent_to_pwm(percent: float) -> int:
        """
        Convert percentage (0-100) to PWM value (0-65535)
        
        For dual-PWM motor drivers, use NORMAL mapping:
        - 0% speed → PWM 0 (motor stopped)
        - 100% speed → PWM 65535 (motor full speed)
        
        Note: The previous INVERTED mapping was for different motor drivers
        """
        # Ensure percent is within bounds
        percent = max(0, min(100, percent))
        
        # NORMAL PWM calculation (not inverted)
        # 0% → 0, 100% → 65535
        pwm = int((percent / 100.0) * 65535)
        
        logger.debug(f"Converting {percent}% to PWM: {pwm}")
        return pwm
    
    @staticmethod
    def pwm_to_percent(pwm: int) -> float:
        """
        Convert PWM value (0-65535) to percentage (0-100)
        
        Using NORMAL mapping:
        - PWM 0 = 0% speed
        - PWM 65535 = 100% speed
        """
        # NORMAL calculation (not inverted)
        return round((pwm / 65535.0) * 100, 1)
    
    def set_motor(self, motor_id: int, direction: str, speed_percent: float) -> Dict[str, Any]:
        """
        Set motor speed and direction
        
        Args:
            motor_id: Motor ID (0-3)
            direction: Direction ("forward", "backward", "brake")
            speed_percent: Speed in percentage (0-100)
        
        Returns:
            Dict containing operation result
        """
        # Validate inputs
        if motor_id < 0 or motor_id > 3:
            return {
                "success": False,
                "error": "Invalid motor ID. Must be 0-3"
            }
        
        if direction not in ["forward", "backward", "brake"]:
            return {
                "success": False,
                "error": "Invalid direction. Must be 'forward', 'backward', or 'brake'"
            }
        
        if not isinstance(speed_percent, (int, float)) or speed_percent < 0 or speed_percent > 100:
            return {
                "success": False,
                "error": "Invalid speed. Must be 0-100"
            }
        
        # Convert to PWM with NORMAL mapping
        if direction == "brake":
            # Brake always uses PWM 0
            speed_pwm = 0
        else:
            # Use normal PWM mapping: 0% = PWM 0, 100% = PWM 65535
            speed_pwm = self.percent_to_pwm(speed_percent)
        
        # Call ROS service (connection is handled in call_service)
        service_args = {
            "motor_id": motor_id,
            "direction": direction,
            "speed": speed_pwm
        }
        
        logger.info(f"Sending to ROS - Motor: {motor_id}, Direction: {direction}, Speed: {speed_percent}% (PWM: {speed_pwm})")
        
        success, response = self.ros_bridge.call_service(
            "/set_motor", 
            service_args,
            f"motor_cmd_{motor_id}"
        )
        
        if success:
            # Update internal state
            self.motor_states[motor_id] = {
                "direction": direction,
                "speed_percent": speed_percent,
                "speed_pwm": speed_pwm
            }
            
            logger.info(f"Motor {motor_id} set to {direction} at {speed_percent}% (PWM: {speed_pwm})")
            
            return {
                "success": True,
                "motor_id": motor_id,
                "direction": direction,
                "speed_percent": speed_percent,
                "speed_pwm": speed_pwm,
                "response": response
            }
        else:
            return {
                "success": False,
                "error": response.get("error", "Unknown error"),
                "motor_id": motor_id
            }
    
    def stop_all_motors(self) -> Dict[str, Any]:
        """
        Emergency stop - brake all motors
        
        Returns:
            Dict containing results for all motors
        """
        results = []
        
        for motor_id in range(4):
            # Brake with speed 0
            result = self.set_motor(motor_id, "brake", 0)
            results.append(result)
        
        all_success = all(r["success"] for r in results)
        
        return {
            "success": all_success,
            "results": results
        }
    
    def get_motor_state(self, motor_id: int) -> Optional[Dict[str, Any]]:
        """
        Get current state of a motor
        
        Args:
            motor_id: Motor ID (0-3)
        
        Returns:
            Dict with motor state or None if invalid ID
        """
        if motor_id in self.motor_states:
            return self.motor_states[motor_id].copy()
        return None
    
    def get_all_motor_states(self) -> Dict[int, Dict[str, Any]]:
        """Get current state of all motors"""
        return self.motor_states.copy()

class ServoPublisher:
    """High-level servo control interface using ROSBridge"""
    
    def __init__(self, ros_bridge: ROSBridgeConnection):
        """
        Initialize servo publisher
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.topic_name = "/servo_position_cmd"
        self.msg_type = "servo_interfaces/msg/ServoPosition"
    
    def publish_position(self, pan_angle: float, tilt_angle: float) -> bool:
        """
        Publish servo position command
        
        Args:
            pan_angle: Pan servo angle (75-195 degrees)
            tilt_angle: Tilt servo angle (75-195 degrees)
        
        Returns:
            bool: True if successful
        """
        # Prepare message
        msg_data = {
            "pan_angle": pan_angle,
            "tilt_angle": tilt_angle
        }
        
        # Publish to topic
        success = self.ros_bridge.publish_topic(
            self.topic_name,
            self.msg_type,
            msg_data
        )
        
        if success:
            logger.info(f"Published servo position: pan={pan_angle}, tilt={tilt_angle}")
        else:
            logger.error(f"Failed to publish servo position")
        
        return success

# Create singleton instances for easy import
_ros_bridge = None
_motor_controller = None
_servo_publisher = None

def get_ros_bridge(host: str = None, port: int = None) -> ROSBridgeConnection:
    """Get or create ROSBridge connection instance"""
    global _ros_bridge
    
    # If host/port provided, update or create new connection
    if host is not None or port is not None:
        if _ros_bridge:
            # Update existing connection
            if host:
                _ros_bridge.host = host
                _ros_bridge.url = f"ws://{host}:{_ros_bridge.port}"
            if port:
                _ros_bridge.port = port
                _ros_bridge.url = f"ws://{_ros_bridge.host}:{port}"
        else:
            # Create new connection with provided settings
            _ros_bridge = ROSBridgeConnection(
                host or "192.168.2.4", 
                port or 9090
            )
    elif _ros_bridge is None:
        # Create with defaults if not exists
        _ros_bridge = ROSBridgeConnection()
    
    return _ros_bridge

def get_motor_controller() -> MotorController:
    """Get or create MotorController instance"""
    global _motor_controller
    if _motor_controller is None:
        _motor_controller = MotorController(get_ros_bridge())
    return _motor_controller

def get_servo_publisher() -> ServoPublisher:
    """Get or create ServoPublisher instance"""
    global _servo_publisher
    if _servo_publisher is None:
        _servo_publisher = ServoPublisher(get_ros_bridge())
    return _servo_publisher

# Convenience function for servo control to match the expected interface
async def publish_servo_position(pan_angle: float, tilt_angle: float) -> bool:
    """
    Publish servo position (async wrapper for compatibility)
    
    Args:
        pan_angle: Pan servo angle
        tilt_angle: Tilt servo angle
    
    Returns:
        bool: Success status
    """
    servo_pub = get_servo_publisher()
    return servo_pub.publish_position(pan_angle, tilt_angle)
================================================================================


================================================================================
FILE: robot-dashboard/backend/sensors/__init__.py
Category: Python | Size: 280.0 B | Lines: 13
================================================================================
"""
Sensor modules for ROS 2 robot
"""

from .lidar import LidarSensor, get_lidar_sensor
from .thermal_camera import ThermalCameraSensor, get_thermal_camera_sensor

__all__ = [
    'LidarSensor',
    'get_lidar_sensor',
    'ThermalCameraSensor',
    'get_thermal_camera_sensor'
]
================================================================================


================================================================================
FILE: robot-dashboard/backend/sensors/lidar.py
Category: Python | Size: 8.0 KB | Lines: 243
================================================================================
#!/usr/bin/env python3
"""
Lidar sensor module for ROS 2
Handles lidar data subscription and processing
"""

import json
import logging
import threading
import time
from typing import Dict, Any, Optional, Callable, List
import numpy as np
from websocket import create_connection

logger = logging.getLogger(__name__)

class LidarSensor:
    """Subscribe to and process lidar scan data via ROSBridge"""
    
    def __init__(self, ros_bridge):
        """
        Initialize lidar sensor
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.scan_callback = None
        self.latest_scan = None
        self.subscription_active = False
        self._ws = None
        self._ws_thread = None
        self._stop_thread = False
        
    def subscribe(self, callback: Optional[Callable] = None, 
                 processed_data: bool = True) -> bool:
        """
        Subscribe to /scan topic
        
        Args:
            callback: Optional callback function for new scan data
            processed_data: If True, return processed data; if False, return raw
        
        Returns:
            bool: Success status
        """
        try:
            # Create a dedicated connection for subscription
            self._ws = create_connection(self.ros_bridge.url, timeout=5)
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": "/scan",
                "type": "sensor_msgs/LaserScan"
            }
            
            self._ws.send(json.dumps(subscribe_msg))
            logger.info("Subscribed to /scan topic")
            
            # Start receiving thread
            self.subscription_active = True
            self._stop_thread = False
            self._ws_thread = threading.Thread(
                target=self._receive_scan_data, 
                args=(callback, processed_data)
            )
            self._ws_thread.daemon = True
            self._ws_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to scan: {e}")
            return False
    
    def _receive_scan_data(self, callback, processed_data):
        """Receive scan data in separate thread"""
        while self.subscription_active and not self._stop_thread:
            try:
                response = self._ws.recv()
                data = json.loads(response)
                
                if data.get("op") == "publish" and data.get("topic") == "/scan":
                    msg = data["msg"]
                    
                    if processed_data:
                        # Process the data for easier use
                        processed = self._process_scan_data(msg)
                        self.latest_scan = processed
                        
                        if callback:
                            callback(processed)
                    else:
                        # Return raw data
                        self.latest_scan = msg
                        
                        if callback:
                            callback(msg)
                            
            except Exception as e:
                if self.subscription_active:
                    logger.error(f"Error receiving scan data: {e}")
                break
        
        if self._ws:
            self._ws.close()
        logger.info("Scan subscription thread ended")
    
    def _process_scan_data(self, scan_msg: Dict) -> Dict[str, Any]:
        """
        Process raw scan data into more useful format
        
        Args:
            scan_msg: Raw LaserScan message
            
        Returns:
            Dict with processed data including points for visualization
        """
        ranges = scan_msg["ranges"]
        angle_min = scan_msg["angle_min"]
        angle_increment = scan_msg["angle_increment"]
        
        # Filter out invalid readings (0.0 or inf)
        valid_ranges = [(i, r) for i, r in enumerate(ranges) 
                       if r > 0.1 and r < 10.0]
        
        if not valid_ranges:
            return {
                "min_distance": float('inf'),
                "min_angle": 0,
                "obstacles": [],
                "safe_directions": ["all"],
                "points": [],
                "timestamp": time.time(),
                "point_count": 0
            }
        
        # Find minimum distance
        min_idx, min_dist = min(valid_ranges, key=lambda x: x[1])
        min_angle = angle_min + min_idx * angle_increment
        
        # Convert to cartesian coordinates for visualization
        points = []
        obstacles = []
        
        for idx, dist in valid_ranges:
            angle = angle_min + idx * angle_increment
            x = dist * np.cos(angle)
            y = dist * np.sin(angle)
            
            points.append({
                "x": float(x),
                "y": float(y),
                "r": float(dist),
                "theta": float(angle),
                "theta_deg": float(np.degrees(angle))
            })
            
            # Detect obstacles (anything closer than 0.5m)
            if dist < 0.5:
                obstacles.append({
                    "angle": float(angle),
                    "angle_deg": float(np.degrees(angle)),
                    "distance": float(dist),
                    "x": float(x),
                    "y": float(y)
                })
        
        # Determine safe directions
        safe_directions = self._calculate_safe_directions(valid_ranges, angle_min, angle_increment)
        
        return {
            "min_distance": float(min_dist),
            "min_angle": float(min_angle),
            "min_angle_deg": float(np.degrees(min_angle)),
            "obstacles": obstacles,
            "safe_directions": safe_directions,
            "obstacle_count": len(obstacles),
            "points": points,
            "point_count": len(points),
            "timestamp": time.time()
        }
    
    def _calculate_safe_directions(self, valid_ranges, angle_min, angle_increment):
        """Calculate safe movement directions based on scan data"""
        safe_directions = []
        
        # Check sectors (front, left, right, back)
        sectors = {
            "front": (-30, 30),
            "left": (60, 120),
            "right": (-120, -60),
            "back": (150, 180)  # and (-180, -150)
        }
        
        for direction, (start_deg, end_deg) in sectors.items():
            start_rad = np.radians(start_deg)
            end_rad = np.radians(end_deg)
            
            # Check if sector is clear
            sector_clear = True
            for idx, dist in valid_ranges:
                angle = angle_min + idx * angle_increment
                
                # Handle back sector wraparound
                if direction == "back":
                    if (angle > np.radians(150) or angle < np.radians(-150)):
                        if dist < 0.5:
                            sector_clear = False
                            break
                else:
                    if start_rad <= angle <= end_rad and dist < 0.5:
                        sector_clear = False
                        break
            
            if sector_clear:
                safe_directions.append(direction)
        
        return safe_directions
    
    def get_latest_scan(self) -> Optional[Dict[str, Any]]:
        """Get the most recent scan data"""
        return self.latest_scan
    
    def unsubscribe(self):
        """Stop subscription"""
        self.subscription_active = False
        self._stop_thread = True
        if self._ws_thread:
            self._ws_thread.join(timeout=2)
        logger.info("Unsubscribed from scan topic")

# Singleton instance
_lidar_sensor = None

def get_lidar_sensor():
    """Get or create LidarSensor instance"""
    global _lidar_sensor
    if _lidar_sensor is None:
        from backend.ros_bridge import get_ros_bridge
        _lidar_sensor = LidarSensor(get_ros_bridge())
    return _lidar_sensor
================================================================================


================================================================================
FILE: robot-dashboard/backend/sensors/thermal_camera.py
Category: Python | Size: 7.7 KB | Lines: 222
================================================================================
#!/usr/bin/env python3
"""
Thermal camera sensor module for MLX90640
Handles thermal data subscription and processing
"""

import json
import logging
import threading
import time
from typing import Dict, Any, Optional, Callable
import numpy as np
from websocket import create_connection

logger = logging.getLogger(__name__)

class ThermalCameraSensor:
    """Subscribe to and process thermal camera data via ROSBridge"""
    
    def __init__(self, ros_bridge):
        """
        Initialize thermal camera sensor
        
        Args:
            ros_bridge: ROSBridgeConnection instance
        """
        self.ros_bridge = ros_bridge
        self.thermal_callback = None
        self.latest_frame = None
        self.subscription_active = False
        self._ws = None
        self._ws_thread = None
        self._stop_thread = False
        
    def subscribe(self, callback: Optional[Callable] = None) -> bool:
        """
        Subscribe to /thermal_frame topic
        
        Args:
            callback: Optional callback function for new thermal data
        
        Returns:
            bool: Success status
        """
        try:
            # Create a dedicated connection for subscription
            self._ws = create_connection(self.ros_bridge.url, timeout=5)
            
            # Subscribe message
            subscribe_msg = {
                "op": "subscribe",
                "topic": "/thermal_frame",
                "type": "mlx90640_interfaces/ThermalFrame"
            }
            
            self._ws.send(json.dumps(subscribe_msg))
            logger.info("Subscribed to /thermal_frame topic")
            
            # Start receiving thread
            self.subscription_active = True
            self._stop_thread = False
            self._ws_thread = threading.Thread(
                target=self._receive_thermal_data, 
                args=(callback,)
            )
            self._ws_thread.daemon = True
            self._ws_thread.start()
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to thermal camera: {e}")
            return False
    
    def _receive_thermal_data(self, callback):
        """Receive thermal data in separate thread"""
        while self.subscription_active and not self._stop_thread:
            try:
                response = self._ws.recv()
                data = json.loads(response)
                
                if data.get("op") == "publish" and data.get("topic") == "/thermal_frame":
                    msg = data["msg"]
                    
                    # Process the thermal frame data
                    processed = self._process_thermal_data(msg)
                    self.latest_frame = processed
                    
                    if callback:
                        callback(processed)
                        
            except Exception as e:
                if self.subscription_active:
                    logger.error(f"Error receiving thermal data: {e}")
                break
        
        if self._ws:
            self._ws.close()
        logger.info("Thermal camera subscription thread ended")
    
    def _process_thermal_data(self, frame_msg: Dict) -> Dict[str, Any]:
        """
        Process raw thermal frame data for visualization
        
        Args:
            frame_msg: Raw ThermalFrame message
            
        Returns:
            Dict with processed data including heatmap
        """
        try:
            # Extract frame data
            width = frame_msg.get("width", 32)
            height = frame_msg.get("height", 24)
            data = frame_msg.get("data", [])
            
            # Reshape to 2D array
            thermal_array = np.array(data).reshape((height, width))
            
            # Calculate temperature ranges for better visualization
            min_temp = frame_msg.get("min_temp", 20.0)
            max_temp = frame_msg.get("max_temp", 30.0)
            avg_temp = frame_msg.get("avg_temp", 25.0)
            center_temp = frame_msg.get("center_temp", 25.0)
            
            # Normalize data to 0-255 for color mapping
            if max_temp > min_temp:
                normalized = ((thermal_array - min_temp) / (max_temp - min_temp) * 255).astype(np.uint8)
            else:
                normalized = np.full((height, width), 128, dtype=np.uint8)
            
            # Find hotspots (temperatures above average + threshold)
            threshold = (max_temp - min_temp) * 0.7 + min_temp
            hotspots = []
            for y in range(height):
                for x in range(width):
                    if thermal_array[y, x] > threshold:
                        hotspots.append({
                            "x": x,
                            "y": y,
                            "temp": float(thermal_array[y, x])
                        })
            
            # Convert to list for JSON serialization
            thermal_list = thermal_array.tolist()
            normalized_list = normalized.tolist()
            
            return {
                "width": width,
                "height": height,
                "thermal_data": thermal_list,
                "normalized_data": normalized_list,
                "min_temp": min_temp,
                "max_temp": max_temp,
                "avg_temp": avg_temp,
                "center_temp": center_temp,
                "frame_count": frame_msg.get("frame_count", 0),
                "hotspots": hotspots,
                "hotspot_count": len(hotspots),
                "timestamp": time.time()
            }
            
        except Exception as e:
            logger.error(f"Error processing thermal data: {e}")
            return {
                "width": 32,
                "height": 24,
                "thermal_data": [[20.0] * 32 for _ in range(24)],
                "normalized_data": [[128] * 32 for _ in range(24)],
                "min_temp": 20.0,
                "max_temp": 30.0,
                "avg_temp": 25.0,
                "center_temp": 25.0,
                "frame_count": 0,
                "hotspots": [],
                "hotspot_count": 0,
                "timestamp": time.time()
            }
    
    def get_latest_frame(self) -> Optional[Dict[str, Any]]:
        """Get the most recent thermal frame data"""
        return self.latest_frame
    
    def get_thermal_frame_once(self) -> Optional[Dict[str, Any]]:
        """Request a single thermal frame via service call"""
        try:
            # Call the get_thermal_frame service
            success, response = self.ros_bridge.call_service(
                "/get_thermal_frame",
                {},
                "get_thermal_frame"
            )
            
            if success and response.get("values", {}).get("success"):
                frame_data = response["values"]["frame"]
                return self._process_thermal_data(frame_data)
            else:
                logger.error("Failed to get thermal frame via service")
                return None
                
        except Exception as e:
            logger.error(f"Error calling thermal frame service: {e}")
            return None
    
    def unsubscribe(self):
        """Stop subscription"""
        self.subscription_active = False
        self._stop_thread = True
        if self._ws_thread:
            self._ws_thread.join(timeout=2)
        logger.info("Unsubscribed from thermal camera topic")

# Singleton instance
_thermal_camera_sensor = None

def get_thermal_camera_sensor():
    """Get or create ThermalCameraSensor instance"""
    global _thermal_camera_sensor
    if _thermal_camera_sensor is None:
        from backend.ros_bridge import get_ros_bridge
        _thermal_camera_sensor = ThermalCameraSensor(get_ros_bridge())
    return _thermal_camera_sensor
================================================================================


================================================================================
FILE: robot-dashboard/run.py
Category: Python | Size: 341.0 B | Lines: 16
================================================================================
#!/usr/bin/env python3
"""
Main entry point for the ROS 2 Motor Control application
Run this file to start the Flask backend server
"""

import sys
from pathlib import Path

# Add the current directory to Python path
sys.path.insert(0, str(Path(__file__).parent))

from backend.host_backend import main

if __name__ == '__main__':
    main()
================================================================================


================================================================================
FILE: servo_controller_py/launch/servo_controller_launch.py
Category: Python | Size: 1.0 KB | Lines: 34
================================================================================
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration
import os
from ament_index_python.packages import get_package_share_directory


def generate_launch_description():
    # Get the package directory
    pkg_dir = get_package_share_directory('servo_controller_py')
    
    # Path to config file
    config_file = os.path.join(pkg_dir, 'config', 'servo_config.yaml')
    
    return LaunchDescription([
        # Declare launch arguments
        DeclareLaunchArgument(
            'config_file',
            default_value=config_file,
            description='Path to servo configuration file'
        ),
        
        # Servo controller node
        Node(
            package='servo_controller_py',
            executable='servo_controller_node',
            name='servo_controller',
            output='screen',
            parameters=[LaunchConfiguration('config_file')],
            respawn=True,
            respawn_delay=2.0
        )
    ])

================================================================================


================================================================================
FILE: servo_controller_py/servo_controller_py/__init__.py
Category: Python | Size: 0.0 B | Lines: 0
================================================================================

================================================================================


================================================================================
FILE: servo_controller_py/servo_controller_py/servo_controller_node.py
Category: Python | Size: 6.7 KB | Lines: 190
================================================================================
#!/usr/bin/env python3
"""
Simple ROS2 node for controlling pan-tilt servos on Raspberry Pi
Works like the original demo - no continuous updates, no vibration
"""

import rclpy
from rclpy.node import Node
from servo_interfaces.msg import ServoPosition, ServoState
from servo_interfaces.srv import SetServoPosition, SetServoSpeed
import RPi.GPIO as GPIO
import time


class ServoControllerNode(Node):
    def __init__(self):
        super().__init__('servo_controller_node')
        
        # Declare parameters
        self.declare_parameter('pan_pin', 13)
        self.declare_parameter('tilt_pin', 12)
        self.declare_parameter('pwm_frequency', 50)
        self.declare_parameter('min_angle', 0)
        self.declare_parameter('max_angle', 270)
        
        # Get parameters
        self.pan_pin = self.get_parameter('pan_pin').value
        self.tilt_pin = self.get_parameter('tilt_pin').value
        self.pwm_frequency = self.get_parameter('pwm_frequency').value
        self.min_angle = self.get_parameter('min_angle').value
        self.max_angle = self.get_parameter('max_angle').value
        
        # Current servo states
        self.current_pan = 135.0  # Center position
        self.current_tilt = 135.0  # Center position
        
        # Initialize GPIO
        self.init_gpio()
        
        # Create publishers
        self.state_publisher = self.create_publisher(ServoState, 'servo_state', 10)
        
        # Create subscribers
        self.position_subscriber = self.create_subscription(
            ServoPosition,
            'servo_position_cmd',
            self.position_callback,
            10
        )
        
        # Create services
        self.set_position_service = self.create_service(
            SetServoPosition,
            'set_servo_position',
            self.set_position_callback
        )
        
        # Create timer for publishing state
        self.state_timer = self.create_timer(0.5, self.publish_state)  # 2Hz is enough
        
        # Move to initial position
        self.move_servo(self.pan_pwm, self.current_pan)
        self.move_servo(self.tilt_pwm, self.current_tilt)
        
        self.get_logger().info(f'Servo controller initialized - Pan: GPIO{self.pan_pin}, Tilt: GPIO{self.tilt_pin}')
    
    def init_gpio(self):
        """Initialize GPIO and PWM"""
        # Use BCM pin numbering
        GPIO.setmode(GPIO.BCM)
        
        # Setup GPIO pins as outputs
        GPIO.setup(self.pan_pin, GPIO.OUT)
        GPIO.setup(self.tilt_pin, GPIO.OUT)
        
        # Create PWM instances (50Hz is standard for servos)
        self.pan_pwm = GPIO.PWM(self.pan_pin, self.pwm_frequency)
        self.tilt_pwm = GPIO.PWM(self.tilt_pin, self.pwm_frequency)
        
        # Start PWM with 0% duty cycle
        self.pan_pwm.start(0)
        self.tilt_pwm.start(0)
        
        # Small delay to let servos initialize
        time.sleep(0.5)
    
    def angle_to_duty_cycle(self, angle):
        """
        Convert angle (0-270 degrees) to duty cycle percentage
        
        For 50Hz PWM:
        - 0.5ms pulse (2.5% duty cycle) = 0 degrees
        - 2.5ms pulse (12.5% duty cycle) = 270 degrees
        """
        # Map angle (0-270) to duty cycle (2.5-12.5)
        duty_cycle = 2.5 + (angle / 270.0) * 10.0
        return duty_cycle
    
    def move_servo(self, servo_pwm, angle):
        """
        Move a servo to specified angle
        Same as original demo code
        """
        if self.min_angle <= angle <= self.max_angle:
            duty_cycle = self.angle_to_duty_cycle(angle)
            servo_pwm.ChangeDutyCycle(duty_cycle)
            time.sleep(0.5)  # Give servo time to move
            # Stop sending signal to reduce jitter/vibration
            servo_pwm.ChangeDutyCycle(0)
            return True
        return False
    
    def position_callback(self, msg):
        """Handle position command messages"""
        # Move pan servo if angle changed
        if msg.pan_angle != self.current_pan:
            if self.move_servo(self.pan_pwm, msg.pan_angle):
                self.current_pan = msg.pan_angle
                self.get_logger().info(f'Pan servo moved to {msg.pan_angle}°')
            else:
                self.get_logger().warn(f'Invalid pan angle: {msg.pan_angle}')
        
        # Move tilt servo if angle changed
        if msg.tilt_angle != self.current_tilt:
            if self.move_servo(self.tilt_pwm, msg.tilt_angle):
                self.current_tilt = msg.tilt_angle
                self.get_logger().info(f'Tilt servo moved to {msg.tilt_angle}°')
            else:
                self.get_logger().warn(f'Invalid tilt angle: {msg.tilt_angle}')
    
    def set_position_callback(self, request, response):
        """Handle set position service requests"""
        # Validate angles
        if not (self.min_angle <= request.pan_angle <= self.max_angle):
            response.success = False
            response.message = f"Pan angle must be between {self.min_angle} and {self.max_angle}"
            return response
        
        if not (self.min_angle <= request.tilt_angle <= self.max_angle):
            response.success = False
            response.message = f"Tilt angle must be between {self.min_angle} and {self.max_angle}"
            return response
        
        # Move servos
        self.move_servo(self.pan_pwm, request.pan_angle)
        self.current_pan = request.pan_angle
        
        self.move_servo(self.tilt_pwm, request.tilt_angle)
        self.current_tilt = request.tilt_angle
        
        response.success = True
        response.message = f"Moved to Pan: {request.pan_angle}°, Tilt: {request.tilt_angle}°"
        self.get_logger().info(response.message)
        return response
    
    def publish_state(self):
        """Publish current servo state"""
        state_msg = ServoState()
        state_msg.header.stamp = self.get_clock().now().to_msg()
        state_msg.pan_angle = self.current_pan
        state_msg.tilt_angle = self.current_tilt
        state_msg.pan_moving = False  # Simple version - no movement tracking
        state_msg.tilt_moving = False
        self.state_publisher.publish(state_msg)
    
    def cleanup(self):
        """Clean up GPIO resources"""
        self.pan_pwm.stop()
        self.tilt_pwm.stop()
        GPIO.cleanup()
        self.get_logger().info('GPIO cleaned up')


def main(args=None):
    rclpy.init(args=args)
    
    servo_controller = ServoControllerNode()
    
    try:
        rclpy.spin(servo_controller)
    except KeyboardInterrupt:
        servo_controller.get_logger().info('Shutting down servo controller...')
    finally:
        servo_controller.cleanup()
        servo_controller.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
================================================================================


================================================================================
FILE: servo_controller_py/setup.py
Category: Python | Size: 932.0 B | Lines: 30
================================================================================
from setuptools import setup
import os
from glob import glob

package_name = 'servo_controller_py'

setup(
    name=package_name,
    version='0.0.1',
    packages=[package_name],
    data_files=[
        ('share/ament_index/resource_index/packages',
            ['resource/' + package_name]),
        ('share/' + package_name, ['package.xml']),
        (os.path.join('share', package_name, 'launch'), glob('launch/*.py')),
        (os.path.join('share', package_name, 'config'), glob('config/*.yaml')),
    ],
    install_requires=['setuptools'],
    zip_safe=True,
    maintainer='Your Name',
    maintainer_email='your_email@example.com',
    description='ROS2 package for controlling pan-tilt servos on Raspberry Pi',
    license='Apache-2.0',
    tests_require=['pytest'],
    entry_points={
        'console_scripts': [
            'servo_controller_node = servo_controller_py.servo_controller_node:main',
        ],
    },
)

================================================================================


================================================================================
FILE: robot-dashboard/frontend/templates/aiming_system.html
Category: Web | Size: 24.3 KB | Lines: 747
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aiming System - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 40px 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin-bottom: 40px;
        }

        .servo-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 400px;
        }

        .servo-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
        }

        .servo-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .servo-title {
            font-size: 1.5em;
            font-weight: 500;
            color: #00aaff;
        }

        .servo-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            background: #333;
            color: #888;
            transition: all 0.3s ease;
        }

        .servo-status.active {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .angle-control {
            margin-top: auto;
        }

        .angle-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            color: #aaa;
        }

        .angle-value {
            font-size: 2.5em;
            font-weight: 700;
            color: #00ff88;
            min-width: 120px;
            text-align: right;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .angle-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            transition: all 0.3s ease;
        }

        /* Add tick marks for discrete positions */
        .angle-slider {
            background-image: linear-gradient(to right, 
                #444 0%, #444 1px,
                transparent 1px, transparent 20%,
                #444 20%, #444 21%,
                transparent 21%, transparent 40%,
                #444 40%, #444 41%,
                transparent 41%, transparent 60%,
                #444 60%, #444 61%,
                transparent 61%, transparent 80%,
                #444 80%, #444 81%,
                transparent 81%, transparent 99%,
                #444 99%, #444 100%
            );
            background-size: 100% 100%;
            background-repeat: no-repeat;
        }

        .angle-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .angle-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.7);
        }

        .angle-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .angle-marks {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            padding: 0 12px;
        }

        .angle-mark {
            font-size: 0.75em;
            color: #666;
            text-align: center;
            position: relative;
        }

        .preset-panel {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            text-align: center;
        }

        .preset-title {
            font-size: 1.5em;
            font-weight: 500;
            color: #00aaff;
            margin-bottom: 30px;
        }

        .preset-btn {
            padding: 15px 25px;
            margin: 8px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 120px;
        }

        .preset-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .preset-btn.active {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .center-btn {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            font-size: 1.2em;
            padding: 20px 40px;
            min-width: 150px;
        }

        .center-btn:hover {
            background: linear-gradient(135deg, #ff5555, #dd1111);
            box-shadow: 0 5px 20px rgba(255, 68, 68, 0.4);
        }

        .visualization-panel {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
        }

        .servo-visual {
            width: 300px;
            height: 300px;
            margin: 0 auto 20px;
            position: relative;
            background: radial-gradient(circle at center, #1a1a1a 0%, #0a0a0a 100%);
            border: 2px solid #333;
            border-radius: 15px;
            overflow: hidden;
        }

        .grid-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .safe-zone {
            position: absolute;
            border: 2px dashed #00ff88;
            border-radius: 10px;
            top: 16.67%;
            left: 16.67%;
            width: 66.66%;
            height: 66.66%;
            opacity: 0.3;
        }

        .crosshair {
            position: absolute;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }

        .crosshair::before {
            width: 100%;
            height: 2px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }

        .crosshair::after {
            width: 2px;
            height: 100%;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair-center {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #00ff88;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        .log-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            border: 1px solid #333;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            background: #252525;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #aaa;
            border-left: 3px solid #444;
        }

        .log-entry.success {
            border-left-color: #00ff88;
            color: #00ff88;
        }

        .log-entry.error {
            border-left-color: #ff4444;
            color: #ff6666;
        }

        @media (max-width: 1200px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .servo-visual {
                width: 250px;
                height: 250px;
            }
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>Aiming System Control Panel</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <span>Connection Status:</span>
        <div class="status-indicator" id="connectionStatus"></div>
        <span id="statusText">Disconnected</span>
    </div>

    <div class="main-container">
        <div class="controls-grid">
            <!-- Pan Control -->
            <div class="servo-card">
                <div class="servo-header">
                    <h2 class="servo-title">Pan Control (Horizontal)</h2>
                    <span class="servo-status" id="panStatus">IDLE</span>
                </div>
                <div class="angle-control">
                    <div class="angle-label">
                        <span>Angle Control</span>
                        <span class="angle-value" id="panValue">135°</span>
                    </div>
                    <input type="range" class="angle-slider" id="panSlider" 
                           min="75" max="195" value="135" step="30">
                    <div class="angle-marks">
                        <span class="angle-mark">75°<br>Left</span>
                        <span class="angle-mark">105°</span>
                        <span class="angle-mark">135°<br>Center</span>
                        <span class="angle-mark">165°</span>
                        <span class="angle-mark">195°<br>Right</span>
                    </div>
                </div>
            </div>

            <!-- Tilt Control -->
            <div class="servo-card">
                <div class="servo-header">
                    <h2 class="servo-title">Tilt Control (Vertical)</h2>
                    <span class="servo-status" id="tiltStatus">IDLE</span>
                </div>
                <div class="angle-control">
                    <div class="angle-label">
                        <span>Angle Control</span>
                        <span class="angle-value" id="tiltValue">135°</span>
                    </div>
                    <input type="range" class="angle-slider" id="tiltSlider" 
                           min="75" max="195" value="135" step="30">
                    <div class="angle-marks">
                        <span class="angle-mark">75°<br>Down</span>
                        <span class="angle-mark">105°</span>
                        <span class="angle-mark">135°<br>Center</span>
                        <span class="angle-mark">165°</span>
                        <span class="angle-mark">195°<br>Up</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Preset Controls -->
        <div class="preset-panel">
            <h2 class="preset-title">Quick Position Presets</h2>
            <div style="margin-bottom: 20px;">
                <button class="preset-btn" onclick="moveToPreset(135, 195)">↑ UP</button>
            </div>
            <div style="margin-bottom: 20px;">
                <button class="preset-btn" onclick="moveToPreset(75, 135)">← LEFT</button>
                <button class="preset-btn center-btn" onclick="moveToCenter()">CENTER</button>
                <button class="preset-btn" onclick="moveToPreset(195, 135)">RIGHT →</button>
            </div>
            <div>
                <button class="preset-btn" onclick="moveToPreset(135, 75)">↓ DOWN</button>
            </div>
        </div>

        <!-- Visualization -->
        <div class="visualization-panel" style="margin-top: 30px;">
            <h2 class="servo-title" style="text-align: center; margin-bottom: 20px;">Position Visualization</h2>
            <div class="servo-visual">
                <div class="grid-lines"></div>
                <div class="safe-zone"></div>
                <div class="crosshair" id="crosshair" style="left: 50%; top: 50%;">
                    <div class="crosshair-center"></div>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <h3 style="margin-bottom: 10px; color: #888;">Activity Log</h3>
            <div id="logContainer"></div>
        </div>
    </div>

    <script>
        let socket = null;
        let isConnected = false;
        let isUpdatingFromServer = false;
        let currentPanValue = 135;
        let currentTiltValue = 135;

        // Add log entry
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // Keep only last 10 entries
            while (logContainer.children.length > 10) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Initialize Socket.IO connection
        function connectWebSocket() {
            socket = io();

            socket.on('connect', function() {
                console.log('Socket.IO connected');
                isConnected = true;
                updateConnectionStatus(true);
                addLog('Connected to servo controller', 'success');
                
                // Request initial servo state
                socket.emit('request_servo_state');
            });

            socket.on('servo_state', function(data) {
                updateServoState(data);
            });

            socket.on('servo_response', function(data) {
                console.log('Servo response:', data);
                if (data.result && !data.result.success) {
                    addLog(`Error: ${data.result.error}`, 'error');
                }
            });

            socket.on('servo_error', function(data) {
                console.error('Servo error:', data);
                addLog(`Error: ${data.error}`, 'error');
            });

            socket.on('disconnect', function() {
                console.log('Socket.IO disconnected');
                isConnected = false;
                updateConnectionStatus(false);
                addLog('Connection lost - Reconnecting...', 'error');
            });

            socket.on('connect_error', function(error) {
                console.error('Socket.IO connection error:', error);
                updateConnectionStatus(false);
            });
        }

        // Update connection status display
        function updateConnectionStatus(connected) {
            const statusIndicator = document.getElementById('connectionStatus');
            const statusText = document.getElementById('statusText');
            
            if (connected) {
                statusIndicator.classList.add('connected');
                statusText.textContent = 'Connected';
            } else {
                statusIndicator.classList.remove('connected');
                statusText.textContent = 'Disconnected';
            }
        }

        // Update servo state from WebSocket data
        function updateServoState(data) {
            isUpdatingFromServer = true;
            
            // Store current values
            currentPanValue = Math.round(data.pan_angle);
            currentTiltValue = Math.round(data.tilt_angle);
            
            // Update displays
            document.getElementById('panValue').textContent = `${currentPanValue}°`;
            document.getElementById('tiltValue').textContent = `${currentTiltValue}°`;
            
            // Update status
            const panStatus = document.getElementById('panStatus');
            const tiltStatus = document.getElementById('tiltStatus');
            
            if (data.pan_moving) {
                panStatus.textContent = 'MOVING';
                panStatus.classList.add('active');
            } else {
                panStatus.textContent = 'IDLE';
                panStatus.classList.remove('active');
            }
            
            if (data.tilt_moving) {
                tiltStatus.textContent = 'MOVING';
                tiltStatus.classList.add('active');
            } else {
                tiltStatus.textContent = 'IDLE';
                tiltStatus.classList.remove('active');
            }
            
            // Update sliders only if not being manipulated by user
            const panSlider = document.getElementById('panSlider');
            const tiltSlider = document.getElementById('tiltSlider');
            
            if (!panSlider.matches(':active') && !panSlider.matches(':focus')) {
                panSlider.value = currentPanValue;
                updateSliderBackground('panSlider', currentPanValue);
            }
            
            if (!tiltSlider.matches(':active') && !tiltSlider.matches(':focus')) {
                tiltSlider.value = currentTiltValue;
                updateSliderBackground('tiltSlider', currentTiltValue);
            }
            
            // Update visualization
            updateCrosshair(currentPanValue, currentTiltValue);
            
            isUpdatingFromServer = false;
        }

        // Update slider background
        function updateSliderBackground(sliderId, value) {
            const slider = document.getElementById(sliderId);
            const min = parseFloat(slider.min);
            const max = parseFloat(slider.max);
            const percentage = ((value - min) / (max - min)) * 100;
            slider.style.background = `linear-gradient(to right, #00ff88 ${percentage}%, #2a2a2a ${percentage}%)`;
        }

        // Update crosshair position
        function updateCrosshair(pan, tilt) {
            const crosshair = document.getElementById('crosshair');
            
            // Map angles to percentages (75-195 degrees to 0-100%)
            const panPercent = ((pan - 75) / 120) * 100;
            const tiltPercent = 100 - ((tilt - 75) / 120) * 100; // Invert for visual
            
            crosshair.style.left = `${panPercent}%`;
            crosshair.style.top = `${tiltPercent}%`;
        }

        // Send servo command
        function sendServoCommand(pan, tilt) {
            if (!isConnected || !socket || isUpdatingFromServer) return;
            
            socket.emit('servo_command', {
                type: 'servo_command',
                action: 'move',
                pan_angle: parseFloat(pan),
                tilt_angle: parseFloat(tilt)
            });
            
            addLog(`Command sent: Pan ${pan}°, Tilt ${tilt}°`, 'success');
        }

        // Preset movements
        function moveToPreset(pan, tilt) {
            document.getElementById('panSlider').value = pan;
            document.getElementById('tiltSlider').value = tilt;
            updateSliderBackground('panSlider', pan);
            updateSliderBackground('tiltSlider', tilt);
            sendServoCommand(pan, tilt);
        }

        function moveToCenter() {
            moveToPreset(135, 135);
        }

        // Slider event handlers - keep track of values independently
        document.getElementById('panSlider').addEventListener('input', function(e) {
            if (isUpdatingFromServer) return;
            const value = parseInt(e.target.value);
            document.getElementById('panValue').textContent = `${value}°`;
            updateSliderBackground('panSlider', value);
        });

        document.getElementById('panSlider').addEventListener('change', function(e) {
            if (isUpdatingFromServer) return;
            const panValue = parseInt(e.target.value);
            // Use the current tilt value from state, not from the slider
            sendServoCommand(panValue, currentTiltValue);
        });

        document.getElementById('tiltSlider').addEventListener('input', function(e) {
            if (isUpdatingFromServer) return;
            const value = parseInt(e.target.value);
            document.getElementById('tiltValue').textContent = `${value}°`;
            updateSliderBackground('tiltSlider', value);
        });

        document.getElementById('tiltSlider').addEventListener('change', function(e) {
            if (isUpdatingFromServer) return;
            const tiltValue = parseInt(e.target.value);
            // Use the current pan value from state, not from the slider
            sendServoCommand(currentPanValue, tiltValue);
        });

        // Initialize on page load
        window.addEventListener('load', function() {
            connectWebSocket();
            updateSliderBackground('panSlider', 135);
            updateSliderBackground('tiltSlider', 135);
            addLog('Aiming system initialized', 'success');
            
            // Request initial state after a short delay
            setTimeout(() => {
                if (socket && isConnected) {
                    socket.emit('request_servo_state');
                }
            }, 500);
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            if (socket) {
                socket.disconnect();
            }
        });
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: robot-dashboard/frontend/templates/dashboard_home.html
Category: Web | Size: 25.4 KB | Lines: 776
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Fighting Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 30px;
            text-align: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 3em;
            font-weight: 300;
            letter-spacing: 3px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            animation: gradient 3s ease infinite;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .subtitle {
            color: #888;
            font-size: 1.2em;
            font-weight: 300;
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 60px 20px;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .components-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 40px;
            margin-bottom: 60px;
        }

        .component-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .component-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.05) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .component-card:hover::before {
            opacity: 1;
        }

        .component-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.7);
            border-color: #555;
        }

        .component-icon {
            font-size: 4em;
            margin-bottom: 20px;
            display: block;
            text-align: center;
        }

        .motor-icon {
            background: linear-gradient(45deg, #00aaff, #0088cc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .lidar-icon {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .camera-icon {
            background: linear-gradient(45deg, #ff6b6b, #ff4444);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .aiming-icon {
            background: linear-gradient(45deg, #ff00ff, #aa00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .sensor-icon {
            background: linear-gradient(45deg, #ffd93d, #ffb300);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .component-title {
            font-size: 2em;
            font-weight: 500;
            margin-bottom: 15px;
            text-align: center;
        }

        .component-description {
            color: #aaa;
            text-align: center;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .component-status {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .component-status.active {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .component-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .component-card.disabled:hover {
            transform: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .info-section {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 30px;
            margin-top: 40px;
            border: 1px solid #333;
        }

        .info-title {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #00aaff;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .info-item {
            padding: 15px;
            background: #252525;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.2em;
            font-weight: 500;
        }

        .header-controls {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .settings-btn {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        .settings-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: #1a1a1a;
            margin: 10% auto;
            padding: 30px;
            border: 1px solid #333;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }

        .modal-title {
            font-size: 1.8em;
            color: #00aaff;
        }

        .close-btn {
            font-size: 2em;
            color: #888;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-btn:hover {
            color: #fff;
        }

        .settings-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-label {
            color: #aaa;
            font-size: 1.1em;
        }

        .form-input {
            padding: 12px;
            background: #252525;
            border: 1px solid #444;
            border-radius: 8px;
            color: #fff;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #00aaff;
            box-shadow: 0 0 10px rgba(0, 170, 255, 0.3);
        }

        .form-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            color: #fff;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .btn-secondary {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #444;
        }

        .btn-secondary:hover {
            background: #3a3a3a;
        }

        .connection-info {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid #333;
        }

        .connection-info p {
            margin: 5px 0;
            color: #888;
            font-size: 0.9em;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .components-grid {
                grid-template-columns: 1fr;
            }
            
            .component-icon {
                font-size: 3em;
            }
            
            .modal-content {
                margin: 20% auto;
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Fire Fighting Robot</h1>
        <p class="subtitle">Control & Monitoring Dashboard</p>
        <div class="status-bar">
            <div class="header-controls">
                <div class="status-item">
                    <span>ROS Bridge:</span>
                    <div class="status-indicator" id="rosStatus"></div>
                    <span id="rosStatusText">Disconnected</span>
                </div>
                <button class="settings-btn" onclick="openSettings()">⚙️ Connection Settings</button>
            </div>
            <div class="status-item">
                <span>System:</span>
                <div class="status-indicator connected"></div>
                <span>Online</span>
            </div>
        </div>
    </div>

    <!-- Connection Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Connection Settings</h2>
                <span class="close-btn" onclick="closeSettings()">&times;</span>
            </div>
            <form class="settings-form" onsubmit="saveSettings(event)">
                <div class="form-group">
                    <label class="form-label">Robot IP Address</label>
                    <input type="text" 
                           id="robotIP" 
                           class="form-input" 
                           placeholder="192.168.x.x" 
                           pattern="^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
                           required>
                </div>
                <div class="form-group">
                    <label class="form-label">ROS Bridge Port</label>
                    <input type="number" 
                           id="bridgePort" 
                           class="form-input" 
                           placeholder="9090" 
                           min="1" 
                           max="65535"
                           required>
                </div>
                <div class="connection-info">
                    <p>Current Connection: <span id="currentConnection">Not configured</span></p>
                    <p>Last Connected: <span id="lastConnected">Never</span></p>
                </div>
                <div class="form-buttons">
                    <button type="submit" class="btn btn-primary">Connect</button>
                    <button type="button" class="btn btn-secondary" onclick="closeSettings()">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <div class="main-container">
        <div class="components-grid">
            <!-- Motor Control -->
            <div class="component-card" onclick="navigateTo('/motors')">
                <span class="component-icon motor-icon">⚙️</span>
                <h2 class="component-title">Motor Control</h2>
                <p class="component-description">
                    Control all 4 motors independently with forward, backward, and brake modes. 
                    Real-time speed adjustment and emergency stop.
                </p>
                <div class="component-status active">
                    <div class="status-indicator connected"></div>
                    <span>2 Motor Channels Ready</span>
                </div>
            </div>

            <!-- Aiming System -->
            <div class="component-card" onclick="navigateTo('/aiming')">
                <span class="component-icon aiming-icon">🎯</span>
                <h2 class="component-title">Aiming System</h2>
                <p class="component-description">
                    Precision pan/tilt control for targeting system. 
                    Real-time servo positioning with visual feedback.
                </p>
                <div class="component-status" id="aimingStatus">
                    <div class="status-indicator"></div>
                    <span>Click to Activate</span>
                </div>
            </div>

            <!-- Lidar Sensor -->
            <div class="component-card" onclick="navigateTo('/lidar')">
                <span class="component-icon lidar-icon">📡</span>
                <h2 class="component-title">Lidar Sensor</h2>
                <p class="component-description">
                    Real-time 360° environment scanning and obstacle detection. 
                    Visualize surroundings and safe navigation paths.
                </p>
                <div class="component-status" id="lidarStatus">
                    <div class="status-indicator"></div>
                    <span>Click to Activate</span>
                </div>
            </div>

            <!-- Thermal Camera -->
            <div class="component-card" onclick="navigateTo('/thermal')">
                <span class="component-icon camera-icon">🌡️</span>
                <h2 class="component-title">Thermal Camera</h2>
                <p class="component-description">
                    MLX90640 thermal imaging with real-time heatmap visualization. 
                    Monitor temperatures and detect heat signatures.
                </p>
                <div class="component-status" id="thermalStatus">
                    <div class="status-indicator"></div>
                    <span>Click to Activate</span>
                </div>
            </div>

            <!-- Sensors (Future) -->
            <div class="component-card disabled">
                <span class="component-icon sensor-icon">🔥</span>
                <h2 class="component-title">Fire Sensors</h2>
                <p class="component-description">
                    Smoke, flame, and gas sensors for comprehensive fire detection. 
                    Coming soon...
                </p>
                <div class="component-status">
                    <div class="status-indicator"></div>
                    <span>Not Available</span>
                </div>
            </div>
        </div>

        <div class="info-section">
            <h3 class="info-title">System Information</h3>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Robot IP</div>
                    <div class="info-value" id="robotIPInfo">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">ROS Bridge Port</div>
                    <div class="info-value" id="bridgePortInfo">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Active Components</div>
                    <div class="info-value" id="activeComponents">0</div>
                </div>
                <div class="info-item">
                    <div class="info-label">System Uptime</div>
                    <div class="info-value" id="uptime">00:00:00</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Navigation function
        function navigateTo(path) {
            window.location.href = path;
        }

        // Connection settings management
        let connectionSettings = {
            robotIP: localStorage.getItem('robotIP') || '192.168.2.1',
            bridgePort: localStorage.getItem('bridgePort') || '9090'
        };

        // Initialize settings on page load
        function initializeSettings() {
            document.getElementById('robotIP').value = connectionSettings.robotIP;
            document.getElementById('bridgePort').value = connectionSettings.bridgePort;
            updateConnectionInfo();
        }

        // Open settings modal
        function openSettings() {
            document.getElementById('settingsModal').style.display = 'block';
            initializeSettings();
        }

        // Close settings modal
        function closeSettings() {
            document.getElementById('settingsModal').style.display = 'none';
        }

        // Save settings and update connection
        async function saveSettings(event) {
            event.preventDefault();
            
            const newIP = document.getElementById('robotIP').value;
            const newPort = document.getElementById('bridgePort').value;
            
            // Save to localStorage
            localStorage.setItem('robotIP', newIP);
            localStorage.setItem('bridgePort', newPort);
            localStorage.setItem('lastConnectAttempt', new Date().toLocaleString());
            
            // Update backend configuration
            try {
                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        robot_ip: newIP,
                        rosbridge_port: parseInt(newPort)
                    })
                });
                
                if (response.ok) {
                    connectionSettings.robotIP = newIP;
                    connectionSettings.bridgePort = newPort;
                    
                    // Test the new connection
                    await checkSystemStatus();
                    
                    // Close modal and show success
                    closeSettings();
                    updateConnectionInfo();
                    
                    // Inform user that pages need to be refreshed
                    if (confirm('Connection settings updated. Refresh all open dashboard pages to apply changes?')) {
                        window.location.reload();
                    }
                } else {
                    alert('Failed to update connection settings');
                }
            } catch (error) {
                alert('Error updating settings: ' + error.message);
            }
        }

        // Update connection info display
        function updateConnectionInfo() {
            const currentConn = document.getElementById('currentConnection');
            const lastConn = document.getElementById('lastConnected');
            
            currentConn.textContent = `${connectionSettings.robotIP}:${connectionSettings.bridgePort}`;
            lastConn.textContent = localStorage.getItem('lastConnectAttempt') || 'Never';
        }

        // Check system status with current settings
        async function checkSystemStatus() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                
                // Update ROS connection status
                const rosIndicator = document.getElementById('rosStatus');
                const rosStatusText = document.getElementById('rosStatusText');
                
                if (data.connected) {
                    rosIndicator.classList.add('connected');
                    rosStatusText.textContent = 'Connected';
                    localStorage.setItem('lastSuccessfulConnection', new Date().toLocaleString());
                } else {
                    rosIndicator.classList.remove('connected');
                    rosStatusText.textContent = 'Disconnected';
                }
                
                // Update system info
                if (data.config) {
                    document.getElementById('robotIPInfo').textContent = data.config.robot_ip;
                    document.getElementById('bridgePortInfo').textContent = data.config.rosbridge_port;
                }
                
                // Update component status
                let activeCount = 0;
                if (data.components) {
                    if (data.components.motors) activeCount++;
                    
                    if (data.components.servo) {
                        activeCount++;
                        const aimingStatus = document.getElementById('aimingStatus');
                        aimingStatus.classList.add('active');
                        aimingStatus.innerHTML = '<div class="status-indicator connected"></div><span>Active</span>';
                    }
                    
                    if (data.components.lidar) {
                        activeCount++;
                        const lidarStatus = document.getElementById('lidarStatus');
                        lidarStatus.classList.add('active');
                        lidarStatus.innerHTML = '<div class="status-indicator connected"></div><span>Active</span>';
                    }
                    
                    if (data.components.thermal) {
                        activeCount++;
                        const thermalStatus = document.getElementById('thermalStatus');
                        thermalStatus.classList.add('active');
                        thermalStatus.innerHTML = '<div class="status-indicator connected"></div><span>Active</span>';
                    }
                }
                document.getElementById('activeComponents').textContent = activeCount;
                
            } catch (error) {
                console.error('Error checking status:', error);
                // If the backend isn't responding, show disconnected
                const rosIndicator = document.getElementById('rosStatus');
                const rosStatusText = document.getElementById('rosStatusText');
                rosIndicator.classList.remove('connected');
                rosStatusText.textContent = 'Error';
            }
        }

        // Update uptime
        let startTime = Date.now();
        function updateUptime() {
            const elapsed = Date.now() - startTime;
            const hours = Math.floor(elapsed / 3600000);
            const minutes = Math.floor((elapsed % 3600000) / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            
            document.getElementById('uptime').textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('settingsModal');
            if (event.target == modal) {
                closeSettings();
            }
        }

        // Initialize on page load
        window.onload = function() {
            // Check if this is first time or if settings are missing
            if (!localStorage.getItem('robotIP')) {
                openSettings();
            }
            
            checkSystemStatus();
            setInterval(checkSystemStatus, 5000);
            setInterval(updateUptime, 1000);
        }
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: robot-dashboard/frontend/templates/lidar_visualization.html
Category: Web | Size: 26.8 KB | Lines: 777
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lidar Sensor - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-height: calc(100vh - 200px);
        }

        .visualization-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 1.5em;
            color: #00ff88;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #0a0a0a;
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .controls {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .control-button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .control-button.active {
            background: linear-gradient(135deg, #00ff88, #00cc66);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }

        .control-button.danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
        }

        .info-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-item {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.3em;
            font-weight: 500;
            color: #00ff88;
        }

        .movement-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            max-width: 200px;
            margin: 20px auto;
        }

        .move-btn {
            padding: 15px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
            font-size: 1.5em;
            transition: all 0.2s ease;
        }

        .move-btn:hover {
            background: #3a3a3a;
            transform: scale(1.1);
        }

        .move-btn:active {
            background: #00ff88;
            transform: scale(0.95);
        }

        .move-btn:nth-child(2) { grid-column: 2; }
        .move-btn:nth-child(4) { grid-column: 1; }
        .move-btn:nth-child(5) { grid-column: 2; }
        .move-btn:nth-child(6) { grid-column: 3; }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>Lidar Sensor Visualization</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span>Lidar Status:</span>
            <div class="status-indicator" id="lidarStatus"></div>
            <span id="lidarStatusText">Disconnected</span>
        </div>
        <div class="status-item">
            <span>Data Rate:</span>
            <span id="dataRate">0 Hz</span>
        </div>
        <div class="status-item">
            <span>Points:</span>
            <span id="pointCount">0</span>
        </div>
    </div>

    <div class="main-container">
        <!-- Polar View -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Live Scan - Polar View</h2>
                <span id="polarFPS">0 FPS</span>
            </div>
            <div class="canvas-container">
                <canvas id="polarCanvas"></canvas>
            </div>
        </div>

        <!-- Occupancy Map -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Occupancy Map</h2>
                <span id="mapFPS">0 FPS</span>
            </div>
            <div class="canvas-container">
                <canvas id="mapCanvas"></canvas>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="control-button" id="startBtn" onclick="startLidar()">Start Scan</button>
        <button class="control-button danger" id="stopBtn" onclick="stopLidar()" disabled>Stop Scan</button>
        <button class="control-button" onclick="clearMap()">Clear Map</button>
        <button class="control-button" onclick="saveMap()">Save Map</button>
        <button class="control-button" id="followRobotBtn" onclick="toggleFollowRobot()">Follow Robot</button>
        <button class="control-button" onclick="resetView()">Reset View</button>
    </div>

    <div class="info-panel">
        <h3 style="color: #00ff88; margin-bottom: 15px;">Scan Information</h3>
        <div class="info-grid">
            <div class="info-item">
                <div class="info-label">Min Distance</div>
                <div class="info-value" id="minDistance">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Min Angle</div>
                <div class="info-value" id="minAngle">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Obstacles</div>
                <div class="info-value" id="obstacleCount">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">Safe Directions</div>
                <div class="info-value" id="safeDirections" style="font-size: 1em;">-</div>
            </div>
        </div>
    </div>

    <div class="controls">
        <h3 style="color: #00ff88; margin-bottom: 15px; text-align: center;">Robot Movement (Simulation)</h3>
        <div class="movement-controls">
            <button class="move-btn" onclick="moveRobot('forward')">↑</button>
            <button class="move-btn" onclick="moveRobot('left')">←</button>
            <button class="move-btn" onclick="moveRobot('stop')">●</button>
            <button class="move-btn" onclick="moveRobot('right')">→</button>
            <button class="move-btn" onclick="moveRobot('backward')">↓</button>
        </div>
    </div>

    <script>
        // WebSocket connection
        const socket = io();
        
        // Canvas contexts
        const polarCanvas = document.getElementById('polarCanvas');
        const polarCtx = polarCanvas.getContext('2d');
        const mapCanvas = document.getElementById('mapCanvas');
        const mapCtx = mapCanvas.getContext('2d');
        
        // State
        let scanning = false;
        let followRobot = true;
        let latestScanData = null;
        
        // Map parameters
        const MAP_SIZE = 100;  // 10m x 10m with 10cm resolution
        const MAP_RESOLUTION = 0.1;  // meters per pixel
        const occupancyMap = new Array(MAP_SIZE * MAP_SIZE).fill(0.5);  // Unknown = 0.5
        
        // Robot state
        let robotX = MAP_SIZE / 2;
        let robotY = MAP_SIZE / 2;
        let robotTheta = 0;
        const robotPath = [];
        
        // Performance monitoring
        let polarFPS = 0;
        let mapFPS = 0;
        let lastPolarUpdate = Date.now();
        let lastMapUpdate = Date.now();
        let polarFrameCount = 0;
        let mapFrameCount = 0;
        let dataRate = 0;
        let lastDataTime = Date.now();
        let dataCount = 0;
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
        });
        
        socket.on('lidar_data', (data) => {
            latestScanData = data;
            updateVisualization(data);
            
            // Update data rate
            dataCount++;
            const now = Date.now();
            if (now - lastDataTime > 1000) {
                dataRate = dataCount;
                dataCount = 0;
                lastDataTime = now;
                document.getElementById('dataRate').textContent = `${dataRate} Hz`;
            }
        });
        
        // Resize canvases
        function resizeCanvases() {
            const containers = document.querySelectorAll('.canvas-container');
            containers.forEach((container, index) => {
                const canvas = container.querySelector('canvas');
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
            });
        }
        
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();
        
        // Start/Stop lidar
        async function startLidar() {
            try {
                const response = await fetch('/api/lidar/subscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    scanning = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('lidarStatus').classList.add('connected');
                    document.getElementById('lidarStatusText').textContent = 'Connected';
                }
            } catch (error) {
                console.error('Failed to start lidar:', error);
            }
        }
        
        async function stopLidar() {
            try {
                const response = await fetch('/api/lidar/unsubscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    scanning = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                    document.getElementById('lidarStatus').classList.remove('connected');
                    document.getElementById('lidarStatusText').textContent = 'Disconnected';
                }
            } catch (error) {
                console.error('Failed to stop lidar:', error);
            }
        }
        
        // Visualization functions
        function updateVisualization(scanData) {
            // Update info panel
            document.getElementById('minDistance').textContent = `${scanData.min_distance.toFixed(2)}m`;
            document.getElementById('minAngle').textContent = `${scanData.min_angle_deg.toFixed(1)}°`;
            document.getElementById('obstacleCount').textContent = scanData.obstacle_count;
            document.getElementById('safeDirections').textContent = scanData.safe_directions.join(', ') || 'None';
            document.getElementById('pointCount').textContent = scanData.point_count;
            
            // Draw polar view
            drawPolarView(scanData);
            
            // Update occupancy map
            updateOccupancyMap(scanData);
            drawMapView();
        }
        
        function drawPolarView(scanData) {
            const width = polarCanvas.width;
            const height = polarCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) / 2 - 20;
            
            // Clear canvas
            polarCtx.fillStyle = '#0a0a0a';
            polarCtx.fillRect(0, 0, width, height);
            
            // Draw grid
            polarCtx.strokeStyle = '#333';
            polarCtx.lineWidth = 1;
            
            // Concentric circles
            for (let r = 1; r <= 4; r++) {
                polarCtx.beginPath();
                polarCtx.arc(centerX, centerY, (r / 4) * maxRadius, 0, 2 * Math.PI);
                polarCtx.stroke();
                
                // Distance labels
                polarCtx.fillStyle = '#666';
                polarCtx.font = '12px Arial';
                polarCtx.fillText(`${r}m`, centerX + 5, centerY - (r / 4) * maxRadius + 5);
            }
            
            // Radial lines
            for (let angle = 0; angle < 360; angle += 30) {
                const rad = angle * Math.PI / 180;
                polarCtx.beginPath();
                polarCtx.moveTo(centerX, centerY);
                polarCtx.lineTo(
                    centerX + maxRadius * Math.cos(rad),
                    centerY - maxRadius * Math.sin(rad)
                );
                polarCtx.stroke();
            }
            
            // Draw scan points
            if (scanData.points) {
                polarCtx.fillStyle = '#00ff88';
                scanData.points.forEach(point => {
                    if (point.r < 4.0) {  // Only show points within 4m
                        const x = centerX + (point.r / 4) * maxRadius * Math.cos(point.theta);
                        const y = centerY - (point.r / 4) * maxRadius * Math.sin(point.theta);
                        
                        polarCtx.beginPath();
                        polarCtx.arc(x, y, 2, 0, 2 * Math.PI);
                        polarCtx.fill();
                    }
                });
            }
            
            // Draw obstacles
            polarCtx.fillStyle = '#ff4444';
            scanData.obstacles.forEach(obstacle => {
                const x = centerX + (obstacle.distance / 4) * maxRadius * Math.cos(obstacle.angle);
                const y = centerY - (obstacle.distance / 4) * maxRadius * Math.sin(obstacle.angle);
                
                polarCtx.beginPath();
                polarCtx.arc(x, y, 4, 0, 2 * Math.PI);
                polarCtx.fill();
            });
            
            // Draw robot center
            polarCtx.fillStyle = '#00aaff';
            polarCtx.beginPath();
            polarCtx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            polarCtx.fill();
            
            // Update FPS
            polarFrameCount++;
            const now = Date.now();
            if (now - lastPolarUpdate > 1000) {
                polarFPS = polarFrameCount;
                polarFrameCount = 0;
                lastPolarUpdate = now;
                document.getElementById('polarFPS').textContent = `${polarFPS} FPS`;
            }
        }
        
        function updateOccupancyMap(scanData) {
            if (!scanData.points) return;
            
            // Update map with new scan data
            scanData.points.forEach(point => {
                if (point.r > 0 && point.r < 10) {
                    // Ray tracing - mark free space
                    const steps = Math.floor(point.r / MAP_RESOLUTION);
                    for (let step = 0; step < steps; step++) {
                        const r = step * MAP_RESOLUTION;
                        const x = Math.floor(robotX + r * Math.cos(point.theta + robotTheta) / MAP_RESOLUTION);
                        const y = Math.floor(robotY + r * Math.sin(point.theta + robotTheta) / MAP_RESOLUTION);
                        
                        if (x >= 0 && x < MAP_SIZE && y >= 0 && y < MAP_SIZE) {
                            const idx = y * MAP_SIZE + x;
                            occupancyMap[idx] = Math.max(0.0, occupancyMap[idx] - 0.02);
                        }
                    }
                    
                    // Mark obstacle
                    if (point.r < 4.0) {
                        const obsX = Math.floor(robotX + point.r * Math.cos(point.theta + robotTheta) / MAP_RESOLUTION);
                        const obsY = Math.floor(robotY + point.r * Math.sin(point.theta + robotTheta) / MAP_RESOLUTION);
                        
                        if (obsX >= 0 && obsX < MAP_SIZE && obsY >= 0 && obsY < MAP_SIZE) {
                            const idx = obsY * MAP_SIZE + obsX;
                            occupancyMap[idx] = Math.min(1.0, occupancyMap[idx] + 0.1);
                        }
                    }
                }
            });
        }
        
        function drawMapView() {
            const width = mapCanvas.width;
            const height = mapCanvas.height;
            const scale = Math.min(width, height) / (MAP_SIZE * MAP_RESOLUTION);
            
            // Clear canvas
            mapCtx.fillStyle = '#0a0a0a';
            mapCtx.fillRect(0, 0, width, height);
            
            // Calculate view offset
            let offsetX = 0;
            let offsetY = 0;
            if (followRobot) {
                offsetX = width / 2 - robotX * MAP_RESOLUTION * scale;
                offsetY = height / 2 - robotY * MAP_RESOLUTION * scale;
            }
            
            mapCtx.save();
            mapCtx.translate(offsetX, offsetY);
            
            // Draw occupancy map
            const imageData = mapCtx.createImageData(MAP_SIZE, MAP_SIZE);
            for (let y = 0; y < MAP_SIZE; y++) {
                for (let x = 0; x < MAP_SIZE; x++) {
                    const idx = y * MAP_SIZE + x;
                    const value = occupancyMap[idx];
                    const pixelIdx = (y * MAP_SIZE + x) * 4;
                    
                    if (value < 0.5) {
                        // Free space - green tint
                        imageData.data[pixelIdx] = 0;
                        imageData.data[pixelIdx + 1] = Math.floor(255 * (0.5 - value) * 2);
                        imageData.data[pixelIdx + 2] = 0;
                    } else if (value > 0.5) {
                        // Obstacle - red tint
                        imageData.data[pixelIdx] = Math.floor(255 * (value - 0.5) * 2);
                        imageData.data[pixelIdx + 1] = 0;
                        imageData.data[pixelIdx + 2] = 0;
                    } else {
                        // Unknown - gray
                        imageData.data[pixelIdx] = 64;
                        imageData.data[pixelIdx + 1] = 64;
                        imageData.data[pixelIdx + 2] = 64;
                    }
                    imageData.data[pixelIdx + 3] = 255;
                }
            }
            
            // Scale and draw map
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = MAP_SIZE;
            tempCanvas.height = MAP_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(imageData, 0, 0);
            
            mapCtx.imageSmoothingEnabled = false;
            mapCtx.drawImage(tempCanvas, 0, 0, MAP_SIZE * MAP_RESOLUTION * scale, MAP_SIZE * MAP_RESOLUTION * scale);
            
            // Draw robot path
            if (robotPath.length > 1) {
                mapCtx.strokeStyle = '#00ff8866';
                mapCtx.lineWidth = 2;
                mapCtx.beginPath();
                mapCtx.moveTo(robotPath[0].x * MAP_RESOLUTION * scale, robotPath[0].y * MAP_RESOLUTION * scale);
                for (let i = 1; i < robotPath.length; i++) {
                    mapCtx.lineTo(robotPath[i].x * MAP_RESOLUTION * scale, robotPath[i].y * MAP_RESOLUTION * scale);
                }
                mapCtx.stroke();
            }
            
            // Draw robot
            const robotScreenX = robotX * MAP_RESOLUTION * scale;
            const robotScreenY = robotY * MAP_RESOLUTION * scale;
            
            // Robot body
            mapCtx.fillStyle = '#00aaff';
            mapCtx.beginPath();
            mapCtx.arc(robotScreenX, robotScreenY, 8, 0, 2 * Math.PI);
            mapCtx.fill();
            
            // Robot direction
            mapCtx.strokeStyle = '#00aaff';
            mapCtx.lineWidth = 3;
            mapCtx.beginPath();
            mapCtx.moveTo(robotScreenX, robotScreenY);
            mapCtx.lineTo(
                robotScreenX + 20 * Math.cos(robotTheta),
                robotScreenY + 20 * Math.sin(robotTheta)
            );
            mapCtx.stroke();
            
            mapCtx.restore();
            
            // Draw scale
            mapCtx.fillStyle = '#fff';
            mapCtx.font = '12px Arial';
            mapCtx.fillText('1m', 10, height - 10);
            mapCtx.strokeStyle = '#fff';
            mapCtx.lineWidth = 2;
            mapCtx.beginPath();
            mapCtx.moveTo(10, height - 20);
            mapCtx.lineTo(10 + scale, height - 20);
            mapCtx.stroke();
            
            // Update FPS
            mapFrameCount++;
            const now = Date.now();
            if (now - lastMapUpdate > 1000) {
                mapFPS = mapFrameCount;
                mapFrameCount = 0;
                lastMapUpdate = now;
                document.getElementById('mapFPS').textContent = `${mapFPS} FPS`;
            }
        }
        
        // Control functions
        function clearMap() {
            occupancyMap.fill(0.5);
            robotPath.length = 0;
            robotX = MAP_SIZE / 2;
            robotY = MAP_SIZE / 2;
            robotTheta = 0;
        }
        
        function saveMap() {
            // Convert map to image and download
            const link = document.createElement('a');
            link.download = `lidar_map_${new Date().toISOString()}.png`;
            link.href = mapCanvas.toDataURL();
            link.click();
        }
        
        function toggleFollowRobot() {
            followRobot = !followRobot;
            document.getElementById('followRobotBtn').classList.toggle('active', followRobot);
        }
        
        function resetView() {
            followRobot = true;
            document.getElementById('followRobotBtn').classList.add('active');
        }
        
        // Robot movement (simulation)
        function moveRobot(direction) {
            const moveSpeed = 0.2;  // meters
            const turnSpeed = 0.1;  // radians
            
            switch (direction) {
                case 'forward':
                    robotX += moveSpeed * Math.cos(robotTheta) / MAP_RESOLUTION;
                    robotY += moveSpeed * Math.sin(robotTheta) / MAP_RESOLUTION;
                    break;
                case 'backward':
                    robotX -= moveSpeed * Math.cos(robotTheta) / MAP_RESOLUTION;
                    robotY -= moveSpeed * Math.sin(robotTheta) / MAP_RESOLUTION;
                    break;
                case 'left':
                    robotTheta -= turnSpeed;
                    break;
                case 'right':
                    robotTheta += turnSpeed;
                    break;
            }
            
            // Keep robot in bounds
            robotX = Math.max(0, Math.min(MAP_SIZE - 1, robotX));
            robotY = Math.max(0, Math.min(MAP_SIZE - 1, robotY));
            
            // Add to path
            robotPath.push({ x: robotX, y: robotY });
            if (robotPath.length > 1000) {
                robotPath.shift();
            }
            
            // Redraw if we have scan data
            if (latestScanData) {
                updateVisualization(latestScanData);
            }
        }
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    moveRobot('forward');
                    break;
                case 'ArrowDown':
                case 's':
                    moveRobot('backward');
                    break;
                case 'ArrowLeft':
                case 'a':
                    moveRobot('left');
                    break;
                case 'ArrowRight':
                case 'd':
                    moveRobot('right');
                    break;
            }
        });
        
        // Initialize
        toggleFollowRobot();  // Start with follow robot enabled
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: robot-dashboard/frontend/templates/motor_control.html
Category: Web | Size: 23.3 KB | Lines: 706
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motor Control - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #00ff88, #00aaff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 40px 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 30px;
            margin-bottom: 40px;
        }

        .motor-card {
            background: linear-gradient(145deg, #1a1a1a, #252525);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            display: flex;
            flex-direction: column;
            min-height: 350px;
        }

        .motor-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
        }

        .motor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .motor-title {
            font-size: 1.5em;
            font-weight: 500;
            color: #00aaff;
        }

        .motor-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            background: #333;
            color: #888;
            transition: all 0.3s ease;
        }

        .motor-status.active {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .direction-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .direction-btn {
            padding: 12px 8px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
        }

        .direction-btn:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .direction-btn.active {
            background: linear-gradient(135deg, #00aaff, #0088cc);
            box-shadow: 0 5px 20px rgba(0, 170, 255, 0.4);
        }

        .direction-btn.brake.active {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            box-shadow: 0 5px 20px rgba(255, 68, 68, 0.4);
        }

        .speed-control {
            margin-top: auto;
        }

        /* Speed marks container */
        .speed-marks {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            padding: 0 12px;
        }

        .speed-mark {
            font-size: 0.75em;
            color: #666;
            text-align: center;
            position: relative;
        }

        .speed-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: #aaa;
        }

        .speed-value {
            font-size: 2em;
            font-weight: 700;
            color: #00ff88;
            min-width: 80px;
            text-align: right;
        }

        .speed-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #2a2a2a;
            border-radius: 5px;
            outline: none;
            transition: all 0.3s ease;
        }

        /* Add markers for the 5 positions */
        .speed-slider {
            background-image: linear-gradient(to right, 
                #444 0%, #444 1px,
                transparent 1px, transparent 24.5%,
                #444 24.5%, #444 25.5%,
                transparent 25.5%, transparent 49.5%,
                #444 49.5%, #444 50.5%,
                transparent 50.5%, transparent 74.5%,
                #444 74.5%, #444 75.5%,
                transparent 75.5%, transparent 99%,
                #444 99%, #444 100%
            );
            background-size: 100% 100%;
            background-repeat: no-repeat;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .speed-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.7);
        }

        .speed-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: all 0.3s ease;
        }

        .emergency-stop {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff0000, #cc0000);
            border: 3px solid #ff4444;
            color: white;
            font-size: 1.2em;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(255, 0, 0, 0.5);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 1000;
        }

        .emergency-stop:hover {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(255, 0, 0, 0.7);
        }

        .emergency-stop:active {
            transform: scale(0.95);
        }

        .log-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 30px;
            border: 1px solid #333;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-entry {
            padding: 8px;
            margin: 5px 0;
            border-radius: 5px;
            background: #252525;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #aaa;
            border-left: 3px solid #444;
        }

        .log-entry.error {
            border-left-color: #ff4444;
            color: #ff6666;
        }

        .log-entry.success {
            border-left-color: #00ff88;
            color: #00ff88;
        }

        /* Responsive design */
        @media (max-width: 1600px) {
            .controls-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 900px) {
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .emergency-stop {
                width: 80px;
                height: 80px;
                font-size: 1em;
                bottom: 20px;
                right: 20px;
            }

            .direction-controls {
                grid-template-columns: 1fr;
                gap: 8px;
            }
        }

        /* For ultra-wide displays */
        @media (min-width: 2000px) {
            .main-container {
                max-width: 1900px;
            }
            
            .motor-card {
                padding: 35px;
                min-height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ROS 2 Motor Control Panel</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <span>Connection Status:</span>
        <div class="status-indicator" id="connectionStatus"></div>
        <span id="statusText">Disconnected</span>
    </div>

    <div class="main-container">
        <div class="controls-grid">
            <!-- Left Motors -->
            <div class="motor-card" data-motor="0">
                <div class="motor-header">
                    <h2 class="motor-title">Left Motors</h2>
                    <span class="motor-status">IDLE</span>
                </div>
                <div class="direction-controls">
                    <button class="direction-btn" data-direction="forward">Forward</button>
                    <button class="direction-btn" data-direction="backward">Backward</button>
                    <button class="direction-btn brake" data-direction="brake">Brake</button>
                </div>
                <div class="speed-control">
                    <div class="speed-label">
                        <span>Speed Control</span>
                        <span class="speed-value">0%</span>
                    </div>
                    <input type="range" class="speed-slider" min="0" max="100" value="0" step="25">
                    <div class="speed-marks">
                        <span class="speed-mark">0%</span>
                        <span class="speed-mark">25%</span>
                        <span class="speed-mark">50%</span>
                        <span class="speed-mark">75%</span>
                        <span class="speed-mark">100%</span>
                    </div>
                </div>
            </div>

            <!-- Right Motors -->
            <div class="motor-card" data-motor="1">
                <div class="motor-header">
                    <h2 class="motor-title">Right Motors</h2>
                    <span class="motor-status">IDLE</span>
                </div>
                <div class="direction-controls">
                    <button class="direction-btn" data-direction="forward">Forward</button>
                    <button class="direction-btn" data-direction="backward">Backward</button>
                    <button class="direction-btn brake" data-direction="brake">Brake</button>
                </div>
                <div class="speed-control">
                    <div class="speed-label">
                        <span>Speed Control</span>
                        <span class="speed-value">0%</span>
                    </div>
                    <input type="range" class="speed-slider" min="0" max="100" value="0" step="25">
                    <div class="speed-marks">
                        <span class="speed-mark">0%</span>
                        <span class="speed-mark">25%</span>
                        <span class="speed-mark">50%</span>
                        <span class="speed-mark">75%</span>
                        <span class="speed-mark">100%</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <h3 style="margin-bottom: 10px; color: #888;">Activity Log</h3>
            <div id="logContainer"></div>
        </div>
    </div>

    <button class="emergency-stop" id="emergencyStop">STOP<br>ALL</button>

    <script>
        // Motor control state
        const motorStates = {
            0: { direction: 'brake', speed: 0 },  // Left motors
            1: { direction: 'brake', speed: 0 }   // Right motors
        };

        // Command throttling
        let commandQueue = [];
        let isProcessing = false;
        const COMMAND_DELAY = 100; // 100ms between commands

        // Add log entry
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContainer.insertBefore(entry, logContainer.firstChild);
            
            // Keep only last 10 entries
            while (logContainer.children.length > 10) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Process command queue
        async function processCommandQueue() {
            if (isProcessing || commandQueue.length === 0) return;
            
            isProcessing = true;
            const command = commandQueue.shift();
            
            try {
                const response = await fetch(`/api/motor/${command.motorId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        direction: command.direction,
                        speed: command.speed
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    addLog(`Motor ${command.motorId}: ${command.direction} at ${command.speed}%`, 'success');
                } else {
                    addLog(`Motor ${command.motorId} error: ${data.error}`, 'error');
                }
            } catch (error) {
                addLog(`Motor ${command.motorId} error: ${error.message}`, 'error');
            }
            
            // Wait before processing next command
            setTimeout(() => {
                isProcessing = false;
                processCommandQueue();
            }, COMMAND_DELAY);
        }

        // Queue motor command
        function queueMotorCommand(motorId, direction, speed) {
            // Remove any pending commands for this motor
            commandQueue = commandQueue.filter(cmd => cmd.motorId !== motorId);
            
            // Add new command
            commandQueue.push({ motorId, direction, speed });
            
            // Start processing
            processCommandQueue();
        }

        // Send motor command with direction change protection
        async function sendMotorCommand(motorId, direction, speed) {
            const lastDir = motorStates[motorId].direction;
            
            // If changing from forward to backward or vice versa, insert brake command
            if ((lastDir === 'forward' && direction === 'backward') ||
                (lastDir === 'backward' && direction === 'forward')) {
                // Queue brake first
                queueMotorCommand(motorId, 'brake', 0);
                // Then queue the new direction after a delay
                setTimeout(() => {
                    queueMotorCommand(motorId, direction, speed);
                }, 150);
            } else {
                // Direct command
                queueMotorCommand(motorId, direction, speed);
            }
            
            // Update state
            motorStates[motorId].direction = direction;
            motorStates[motorId].speed = speed;
        }

        // Check connection status
        async function checkConnection() {
            try {
                const response = await fetch('/api/status');
                const data = await response.json();
                const indicator = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                
                if (data.connected) {
                    indicator.classList.add('connected');
                    statusText.textContent = 'Connected';
                } else {
                    indicator.classList.remove('connected');
                    statusText.textContent = 'Disconnected';
                }
            } catch (error) {
                const indicator = document.getElementById('connectionStatus');
                const statusText = document.getElementById('statusText');
                indicator.classList.remove('connected');
                statusText.textContent = 'Error';
            }
        }

        // Update motor UI
        function updateMotorUI(motorId) {
            const motorCard = document.querySelector(`[data-motor="${motorId}"]`);
            const state = motorStates[motorId];
            
            // Update direction buttons
            const directionBtns = motorCard.querySelectorAll('.direction-btn');
            directionBtns.forEach(btn => {
                if (btn.dataset.direction === state.direction) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            // Update status
            const status = motorCard.querySelector('.motor-status');
            if (state.direction === 'brake') {
                status.textContent = 'BRAKE';
                status.classList.remove('active');
            } else {
                status.textContent = state.direction.toUpperCase();
                status.classList.add('active');
            }
            
            // Update speed display
            const speedValue = motorCard.querySelector('.speed-value');
            speedValue.textContent = `${state.speed}%`;
            
            // Update slider
            const slider = motorCard.querySelector('.speed-slider');
            slider.value = state.speed;
            
            // Update slider background to show progress
            const percentage = state.speed / 100;
            slider.style.background = `linear-gradient(to right, #00ff88 ${percentage * 100}%, #2a2a2a ${percentage * 100}%)`;
        }

        // Initialize motor controls
        document.querySelectorAll('.motor-card').forEach(motorCard => {
            const motorId = parseInt(motorCard.dataset.motor);
            
            // Direction buttons
            motorCard.querySelectorAll('.direction-btn').forEach(btn => {
                btn.addEventListener('click', async () => {
                    const direction = btn.dataset.direction;
                    motorStates[motorId].direction = direction;
                    
                    // If brake, set speed to 0
                    if (direction === 'brake') {
                        motorStates[motorId].speed = 0;
                    }
                    
                    updateMotorUI(motorId);
                    await sendMotorCommand(motorId, direction, motorStates[motorId].speed);
                });
            });
            
            // Speed slider with throttling
            const slider = motorCard.querySelector('.speed-slider');
            let sliderTimeout;
            
            slider.addEventListener('input', (e) => {
                // IMPORTANT: Invert the slider value
                // Slider shows 0-100 left to right, but we need to send inverted values
                const sliderValue = parseInt(e.target.value);
                motorStates[motorId].speed = sliderValue;
                
                // Update UI immediately
                updateMotorUI(motorId);
                
                // Clear any existing timeout
                clearTimeout(sliderTimeout);
                
                // Only send command on discrete values (0, 25, 50, 75, 100)
                if ([0, 25, 50, 75, 100].includes(sliderValue)) {
                    // Send command immediately for discrete values
                    if (motorStates[motorId].direction !== 'brake') {
                        sendMotorCommand(motorId, motorStates[motorId].direction, sliderValue);
                    }
                }
            });
            
            // Also handle change event for when user releases the slider
            slider.addEventListener('change', (e) => {
                const sliderValue = parseInt(e.target.value);
                if (motorStates[motorId].direction !== 'brake') {
                    sendMotorCommand(motorId, motorStates[motorId].direction, sliderValue);
                }
            });
        });

        // Emergency stop button
        document.getElementById('emergencyStop').addEventListener('click', async () => {
            addLog('EMERGENCY STOP ACTIVATED!', 'error');
            
            // Clear command queue
            commandQueue = [];
            
            try {
                const response = await fetch('/api/motors/stop', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Reset only 2 motors
                    for (let i = 0; i < 2; i++) {
                        motorStates[i] = { direction: 'brake', speed: 0 };
                        updateMotorUI(i);
                    }
                    addLog('All motors stopped', 'success');
                } else {
                    addLog('Emergency stop failed!', 'error');
                }
            } catch (error) {
                addLog(`Emergency stop error: ${error.message}`, 'error');
            }
        });

        // Initial setup
        checkConnection();
        setInterval(checkConnection, 5000); // Check connection every 5 seconds
        
        // Initialize UI
        for (let i = 0; i < 2; i++) {
            updateMotorUI(i);
        }
        
        addLog('Motor control panel initialized', 'success');
    </script>
</body>
</html>
================================================================================


================================================================================
FILE: robot-dashboard/frontend/templates/thermal_camera.html
Category: Web | Size: 20.0 KB | Lines: 606
================================================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thermal Camera - Robot Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #333;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .back-button {
            padding: 10px 20px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 10px;
            color: #fff;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .back-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .status-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff3333;
            box-shadow: 0 0 10px rgba(255, 51, 51, 0.5);
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .main-container {
            flex: 1;
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-height: calc(100vh - 200px);
        }

        .visualization-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .panel-title {
            font-size: 1.5em;
            color: #ff6b6b;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            background: #0a0a0a;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
            image-rendering: pixelated;
        }

        .controls {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #333;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .control-button {
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            background: #2a2a2a;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-button:hover {
            background: #3a3a3a;
            transform: translateY(-2px);
        }

        .control-button.active {
            background: linear-gradient(135deg, #ff6b6b, #ff4444);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
        }

        .info-panel {
            background: #1a1a1a;
            border-radius: 15px;
            padding: 20px;
            border: 1px solid #333;
            margin-top: 20px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-item {
            background: #252525;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #333;
        }

        .info-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.3em;
            font-weight: 500;
            color: #ff6b6b;
        }

        .temperature-scale {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            background: #252525;
            border-radius: 10px;
        }

        .scale-gradient {
            flex: 1;
            height: 20px;
            border-radius: 5px;
            background: linear-gradient(to right, 
                #000080, #0000ff, #00ffff, #00ff00, 
                #ffff00, #ff8800, #ff0000, #ffffff);
        }

        .scale-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 0.8em;
            color: #888;
        }

        .hotspot-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .hotspot-item {
            background: #252525;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            border-left: 3px solid #ff6b6b;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="header">
        <h1>Thermal Camera Visualization</h1>
        <a href="/" class="back-button">← Back to Dashboard</a>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span>Camera Status:</span>
            <div class="status-indicator" id="thermalStatus"></div>
            <span id="thermalStatusText">Disconnected</span>
        </div>
        <div class="status-item">
            <span>Frame Rate:</span>
            <span id="frameRate">0 FPS</span>
        </div>
        <div class="status-item">
            <span>Frame Count:</span>
            <span id="frameCount">0</span>
        </div>
    </div>

    <div class="main-container">
        <!-- Thermal Heatmap -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Thermal Heatmap</h2>
                <span id="heatmapSize">32x24</span>
            </div>
            <div class="canvas-container">
                <canvas id="thermalCanvas"></canvas>
            </div>
            <div class="temperature-scale">
                <span id="minTempLabel">20°C</span>
                <div class="scale-gradient"></div>
                <span id="maxTempLabel">30°C</span>
            </div>
        </div>

        <!-- Analysis Panel -->
        <div class="visualization-panel">
            <div class="panel-header">
                <h2 class="panel-title">Thermal Analysis</h2>
            </div>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Min Temperature</div>
                    <div class="info-value" id="minTemp">-°C</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Max Temperature</div>
                    <div class="info-value" id="maxTemp">-°C</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Average</div>
                    <div class="info-value" id="avgTemp">-°C</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Center</div>
                    <div class="info-value" id="centerTemp">-°C</div>
                </div>
            </div>
            
            <div style="margin-top: 20px;">
                <h3 style="color: #ff6b6b; margin-bottom: 10px;">Hotspot Detection</h3>
                <div class="info-item">
                    <div class="info-label">Hotspots Detected</div>
                    <div class="info-value" id="hotspotCount">0</div>
                </div>
                <div class="hotspot-list" id="hotspotList"></div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="control-button" id="startBtn" onclick="startThermal()">Start Stream</button>
        <button class="control-button" id="stopBtn" onclick="stopThermal()" disabled>Stop Stream</button>
        <button class="control-button" onclick="captureFrame()">Capture Frame</button>
        <button class="control-button" onclick="saveImage()">Save Image</button>
        <button class="control-button" id="autoScaleBtn" onclick="toggleAutoScale()">Auto Scale: ON</button>
        <button class="control-button" onclick="resetView()">Reset View</button>
    </div>

    <script>
        // WebSocket connection
        const socket = io();
        
        // Canvas and context
        const canvas = document.getElementById('thermalCanvas');
        const ctx = canvas.getContext('2d');
        
        // State
        let streaming = false;
        let autoScale = true;
        let latestFrameData = null;
        
        // Performance monitoring
        let frameCount = 0;
        let lastFPSUpdate = Date.now();
        let fps = 0;
        
        // Temperature range for manual scaling
        let manualMinTemp = 20;
        let manualMaxTemp = 35;
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
        });
        
        socket.on('thermal_data', (data) => {
            latestFrameData = data;
            updateVisualization(data);
            
            // Update frame count and FPS
            frameCount++;
            const now = Date.now();
            if (now - lastFPSUpdate > 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFPSUpdate = now;
                document.getElementById('frameRate').textContent = `${fps} FPS`;
            }
        });
        
        // Color mapping function
        function temperatureToColor(temp, minTemp, maxTemp) {
            // Normalize temperature to 0-1 range
            const normalized = (temp - minTemp) / (maxTemp - minTemp);
            const clamped = Math.max(0, Math.min(1, normalized));
            
            // Color gradient: cold (blue) -> warm (red/white)
            let r, g, b;
            
            if (clamped < 0.25) {
                // Blue to cyan
                const t = clamped * 4;
                r = 0;
                g = Math.floor(t * 255);
                b = 255;
            } else if (clamped < 0.5) {
                // Cyan to green
                const t = (clamped - 0.25) * 4;
                r = 0;
                g = 255;
                b = Math.floor((1 - t) * 255);
            } else if (clamped < 0.75) {
                // Green to yellow
                const t = (clamped - 0.5) * 4;
                r = Math.floor(t * 255);
                g = 255;
                b = 0;
            } else {
                // Yellow to red to white
                const t = (clamped - 0.75) * 4;
                if (t < 0.5) {
                    r = 255;
                    g = Math.floor((1 - t * 2) * 255);
                    b = 0;
                } else {
                    r = 255;
                    g = Math.floor((t - 0.5) * 2 * 255);
                    b = Math.floor((t - 0.5) * 2 * 255);
                }
            }
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // Update visualization
        function updateVisualization(data) {
            if (!data || !data.thermal_data) return;
            
            // Update info panel
            document.getElementById('minTemp').textContent = `${data.min_temp.toFixed(1)}°C`;
            document.getElementById('maxTemp').textContent = `${data.max_temp.toFixed(1)}°C`;
            document.getElementById('avgTemp').textContent = `${data.avg_temp.toFixed(1)}°C`;
            document.getElementById('centerTemp').textContent = `${data.center_temp.toFixed(1)}°C`;
            document.getElementById('frameCount').textContent = data.frame_count || 0;
            document.getElementById('hotspotCount').textContent = data.hotspot_count || 0;
            
            // Update temperature scale
            const minTemp = autoScale ? data.min_temp : manualMinTemp;
            const maxTemp = autoScale ? data.max_temp : manualMaxTemp;
            document.getElementById('minTempLabel').textContent = `${minTemp.toFixed(1)}°C`;
            document.getElementById('maxTempLabel').textContent = `${maxTemp.toFixed(1)}°C`;
            
            // Draw heatmap
            drawHeatmap(data.thermal_data, data.width, data.height, minTemp, maxTemp);
            
            // Update hotspot list
            updateHotspotList(data.hotspots || []);
        }
        
        // Draw thermal heatmap
        function drawHeatmap(thermalData, width, height, minTemp, maxTemp) {
            // Set canvas size with scaling
            const scale = 20; // Each pixel becomes 10x10
            canvas.width = width * scale;
            canvas.height = height * scale;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw each temperature pixel
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const temp = thermalData[y][x];
                    const color = temperatureToColor(temp, minTemp, maxTemp);
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x * scale, y * scale, scale, scale);
                }
            }
            
            // Draw grid lines (optional)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= width; x++) {
                ctx.beginPath();
                ctx.moveTo(x * scale, 0);
                ctx.lineTo(x * scale, height * scale);
                ctx.stroke();
            }
            for (let y = 0; y <= height; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * scale);
                ctx.lineTo(width * scale, y * scale);
                ctx.stroke();
            }
            
            // Draw center crosshair
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            const centerX = width * scale / 2;
            const centerY = height * scale / 2;
            
            ctx.beginPath();
            ctx.moveTo(centerX - 20, centerY);
            ctx.lineTo(centerX + 20, centerY);
            ctx.moveTo(centerX, centerY - 20);
            ctx.lineTo(centerX, centerY + 20);
            ctx.stroke();
        }
        
        // Update hotspot list
        function updateHotspotList(hotspots) {
            const listContainer = document.getElementById('hotspotList');
            listContainer.innerHTML = '';
            
            hotspots.slice(0, 10).forEach((hotspot, index) => {
                const item = document.createElement('div');
                item.className = 'hotspot-item';
                item.innerHTML = `
                    <span>Hotspot ${index + 1} (${hotspot.x}, ${hotspot.y})</span>
                    <span>${hotspot.temp.toFixed(1)}°C</span>
                `;
                listContainer.appendChild(item);
            });
        }
        
        // Control functions
        async function startThermal() {
            try {
                const response = await fetch('/api/thermal/subscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    streaming = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('thermalStatus').classList.add('connected');
                    document.getElementById('thermalStatusText').textContent = 'Connected';
                }
            } catch (error) {
                console.error('Failed to start thermal camera:', error);
            }
        }
        
        async function stopThermal() {
            try {
                const response = await fetch('/api/thermal/unsubscribe', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    streaming = false;
                    document.getElementById('startBtn').disabled = false;
                    document.getElementById('stopBtn').disabled = true;
                    document.getElementById('thermalStatus').classList.remove('connected');
                    document.getElementById('thermalStatusText').textContent = 'Disconnected';
                }
            } catch (error) {
                console.error('Failed to stop thermal camera:', error);
            }
        }
        
        async function captureFrame() {
            try {
                const response = await fetch('/api/thermal/frame');
                const result = await response.json();
                
                if (result.success) {
                    updateVisualization(result.data);
                }
            } catch (error) {
                console.error('Failed to capture frame:', error);
            }
        }
        
        function saveImage() {
            const link = document.createElement('a');
            link.download = `thermal_${new Date().toISOString()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }
        
        function toggleAutoScale() {
            autoScale = !autoScale;
            document.getElementById('autoScaleBtn').textContent = `Auto Scale: ${autoScale ? 'ON' : 'OFF'}`;
            if (latestFrameData) {
                updateVisualization(latestFrameData);
            }
        }
        
        function resetView() {
            manualMinTemp = 20;
            manualMaxTemp = 35;
            if (!autoScale && latestFrameData) {
                updateVisualization(latestFrameData);
            }
        }
        
        // Add mouse hover to show temperature
        canvas.addEventListener('mousemove', (e) => {
            if (!latestFrameData || !latestFrameData.thermal_data) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = Math.floor((e.clientX - rect.left) * scaleX / 10);
            const y = Math.floor((e.clientY - rect.top) * scaleY / 10);
            
            if (x >= 0 && x < latestFrameData.width && y >= 0 && y < latestFrameData.height) {
                const temp = latestFrameData.thermal_data[y][x];
                canvas.title = `Temperature: ${temp.toFixed(1)}°C at (${x}, ${y})`;
            }
        });
    </script>
</body>
</html>
================================================================================

